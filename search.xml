<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux 服务器分析 JVM Dump 文件</title>
    <url>/2020-04-08-Linux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%9E%90%20JVM%20Dump%20%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>JVM Dump 文件传输到本地分析，通常需要等待较长时间，且本地环境配置不支持分析大内存 JVM 的 Dump 文件。因此合理的方式是使用 Eclipse 的 MAT(MemoryAnalyzeTool) 工具在服务器上分析 Dump 文件结束后将结果传输到本地查看。    </p>
<a id="more"></a>

<h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>JDK 1.8.0 以上<br>Linux 操作系统<br>MAT 工具(<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a>)    </p>
<h3 id="配置-MAT"><a href="#配置-MAT" class="headerlink" title="配置 MAT"></a>配置 MAT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip MemoryAnalyzer-*-linux.gtk.*.zip </span><br><span class="line"></span><br><span class="line">vim MemoryAnalyzer.ini </span><br><span class="line">## 修改-Xmx，通常设置的比要分析的 JVM Xmx 略大即可</span><br></pre></td></tr></table></figure>

<h3 id="JVM-Dump"><a href="#JVM-Dump" class="headerlink" title="JVM Dump"></a>JVM Dump</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -dump:format&#x3D;b,file&#x3D;PID.dump PID</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
</blockquote>
</blockquote>
<ol>
<li>如果需要 Dump Docker 下的进程，需要进入到 Docker 内找到PID，dump 到 Docker 内然后复制 Dump 文件到宿主机 </li>
<li>如果遇到了 Error attaching to core file 错误,可使用 su -m USER -c “jmap -dump:format=b,file=PID.dump PID” 命令来解决    </li>
</ol>
<h3 id="分析-Dump"><a href="#分析-Dump" class="headerlink" title="分析 Dump"></a>分析 Dump</h3><pre><code>cd mat  
sh ParseHeapDump.sh PID.dump  org.eclipse.mat.api:suspects org.eclipse.mat.api:overview org.eclipse.mat.api:top_components</code></pre><p>会产生 3 个 zip 文件: PID_Leak_Suspects.zip,PID_System_Overview.zip,PID_Top_Components.zip，即(疑似)内存泄露分析、系统内存使用概览、GC-ROOT 信息。 </p>
<h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>将三个 zip 文件传输到本地，解压后在浏览器打开 index.html 即可。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/trust-freedom/p/6744948.html" target="_blank" rel="noopener">https://www.cnblogs.com/trust-freedom/p/6744948.html</a><br><a href="http://moheqionglin.com/site/blogs/24/detail.html" target="_blank" rel="noopener">http://moheqionglin.com/site/blogs/24/detail.html</a>  </p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>.git 目录过大问题解决方案</title>
    <url>/2020-03-18-.git%E7%9B%AE%E5%BD%95%E8%BF%87%E5%A4%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>.git 目录会记录所有文件的历史操作，当提交次数很多 特别是包含大文件时，很容易导致.git 目录很大，尤其是.git/objects/pack。造成的影响有流量超限、自动化部署慢等。   </p>
<a id="more"></a>

<blockquote>
</blockquote>
<p>repo 最好配置 gitignore 文件。<br>git push 使用–force 或 -f 选项时，应通知 repo 的所有用户。<br>repo 中使用正则表达式删除时一定要慎重。    </p>
<h3 id="clone时目录大"><a href="#clone时目录大" class="headerlink" title="clone时目录大"></a>clone时目录大</h3><p>使用–depth 指定 clone 深度，仅 clone 默认分支的最近一次 commit。如果需要 clone 其他分支，可以通过设置分支来拉取其他分支。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;yyy.git</span><br><span class="line">$ git remote set-branches origin $remote_branch </span><br><span class="line">$ git fetch --depth&#x3D;1 origin $remote_branch </span><br><span class="line">$ git checkout $remote_branch</span><br></pre></td></tr></table></figure>

<h3 id="不重要-repo-可重建"><a href="#不重要-repo-可重建" class="headerlink" title="不重要 repo 可重建"></a>不重要 repo 可重建</h3><p>对于个人文件存储、传输用途等不重要的 repo，可以重建版本库。      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm -rf  .git </span><br><span class="line">$ git init</span><br><span class="line">$ git add * </span><br><span class="line">$ git commit -m &quot;reBuild&quot; </span><br><span class="line">$ git remote add origin $repo_url </span><br><span class="line">$ git push -f -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>有选择性合并历史提交，人工成本较高。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git logs </span><br><span class="line">$ git rebase -i $commitId </span><br><span class="line">pick 93a7f37 upd</span><br><span class="line">pick c70583b upd</span><br><span class="line">pick 11cb78f upd</span><br><span class="line">pick f11f716 upd</span><br><span class="line">pick d1ee55c upd</span><br><span class="line"></span><br><span class="line">将待合并的 commit id 前的 pick 字符串改成 s</span><br><span class="line">pick 93a7f37 upd</span><br><span class="line">pick c70583b upd</span><br><span class="line">pick 11cb78f upd</span><br><span class="line">s f11f716 upd</span><br><span class="line">pick d1ee55c upd</span><br><span class="line"></span><br><span class="line">这样第四个commit 会合并到第三个提交上。  </span><br><span class="line">$ git push --force </span><br><span class="line">$ git gc -prune&#x3D;now		清理本地版本库</span><br></pre></td></tr></table></figure>

<h3 id="删除特定大文件的历史记录"><a href="#删除特定大文件的历史记录" class="headerlink" title="删除特定大文件的历史记录"></a>删除特定大文件的历史记录</h3><h5 id="查询-git-目录中最大的-10-个文件"><a href="#查询-git-目录中最大的-10-个文件" class="headerlink" title="查询 .git 目录中最大的 10 个文件"></a>查询 .git 目录中最大的 10 个文件</h5><p>git rev-list –objects –all | grep -f &lt;(git verify-pack -v .git/objects/pack/*.idx| sort -k 3 -n | cut -f 1 -d “ “ | tail -10) </p>
<p>输出范例如下:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">0afba5819d9df014734e70de6a3f237f4f56e33f spark-3.0.0-SNAPSHOT-bin-custom-spark.tgz</span><br><span class="line">996132b957dc1604cb97cc0c6caaf4f17dfea90f jlz&#x2F;spark-tpc-ds-performance-test-master&#x2F;src&#x2F;data&#x2F;catalog\_sales&#x2F;catalog\_sales\_part1.dat </span><br><span class="line">5af74da26b3dac5ed53f0e7f31b4b95b31730315 jlz&#x2F;spark-tpc-ds-performance-test-master&#x2F;src&#x2F;data&#x2F;catalog\_sales&#x2F;catalog\_sales\_part2.dat</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="在版本库中删除特定文件"><a href="#在版本库中删除特定文件" class="headerlink" title="在版本库中删除特定文件"></a>在版本库中删除特定文件</h5><p>git filter-branch –index-filter ‘git rm –cached –ignore-unmatch spark-3.0.0-SNAPSHOT-bin-custom-spark.tgz catalog_sales_part*.dat’ – –all<br>rm -rf .git/refs/original<br>rm -rf .git/logs/<br>git gc –aggressive –prune=now   </p>
<h5 id="提交到远程仓库"><a href="#提交到远程仓库" class="headerlink" title="提交到远程仓库"></a>提交到远程仓库</h5><p>git push –force  </p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Adaptive Execution TPCDS 3TB BenchMark</title>
    <url>/2020-03-18-Spark-Adaptive-Execution-TPCDS-3TB-BenchMark-md/</url>
    <content><![CDATA[<p>Apache Spark 2.3.0 合并了 Spark 3.0-Preview(预览版)的 Adaptive Execution 和 Dynamic Partition Prune 两个重大特性之后, 在 3TB TPCDS 上的性能测试报告。  </p>
<p><a href="https://docs.google.com/spreadsheets/d/1g37JP4D92LjK1vs8fj5LaQ7ipAaQ6lJinS84R8xS9x4/edit#gid=0" target="_blank" rel="noopener">Spark Adaptive Execution TPCDS 3TB BenchMark</a></p>
]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
        <tag>Adaptive Execution</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Maven 常用命令</title>
    <url>/2020-02-23-Maven%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>　　</p>
<a id="more"></a> 

<h2 id="基础选项"><a href="#基础选项" class="headerlink" title="基础选项"></a>基础选项</h2><p>  -v，–version     显示 maven 版本<br>  -X，-debug       显示 debug 日志<br>  -e，–error        显示 error 日志<br>  -q,  –quite         仅仅显示 error 日志信息<br>  -o，–offline      离线构建<br>  -N，–non-recursive   仅构建当前模块，不递归到子模块<br>  -pl，–projects     仅在指定模块构建，避免构建所有模块，多模块用逗号分隔。e.g. -pl core,sql/core<br>  -am，–also-make   构建指定模块时，且构建指定模块依赖的所有模块<br>  -amd，–also-make-dependents  构建指定模块时，且构建依赖该指定模块的所有模块<br>  -D，–define     定义构建属性  e.g.  -Dhadoop.version=2.7.3，-DskipTests<br>  -P，–activate-profiles    激活pom 文件中指定 id的 profile，多个则逗号分隔。 e.g. -Pyarn,hive-1.2 
  -T, –threads    并行构建，支持数字或 NC(N*core)个线程。e.g. -T  2C 每个 core 2 个线程<br>  -h, –help  显示帮助信息  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于-am 和-amd  </span><br><span class="line"></span><br><span class="line">假设 core 模块依赖 common 模块，sql 模块依赖 core 模块。使用--am 构建 core 模块时，会额外构建 common 模块；使用--am 构建 sql 模块时，会额外构建 common 和 core 模块；使用--amd 构建 core 模块时，会额外构建 sql 模块</span><br></pre></td></tr></table></figure>

<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>Maven 运行在 JVM 中，可以使用 JVM 的优化选项。JVM 配置较多，不再赘述。  </p>
<p>-Xmx2G -Xms2G -XX:+UseG1GC       JVM 内存和垃圾回收器配置<br>-XX:+TieredCompilation -XX:TieredStopAtLevel=1     JVM只进行基础的即时编译操作   </p>
<h2 id="常用生命周期"><a href="#常用生命周期" class="headerlink" title="常用生命周期"></a>常用生命周期</h2><p>clean：删除工程的 target 目录，但是不会删除打包到本地仓库和远程仓库的 jar/war 文件<br>compile：编译配置的源代码目录到 target 的 class 目录(具体情况可能不同, e.g. scala-2.11,scala-2.12)<br>package：将 target 目录下编译过的代码文件打包成可发布的形式放到工程 target 目录下<br>install：将 package 打包的 jar/war 文件安装到本地仓库，可供本地其他工程使用<br>deploy：将jar/war 包发布到远程仓库(e.g. 私服)<br>test：使用单元测试框架运行测试<br>其他: validate、initialize、site… </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Maven 生命周期的各个阶段是前后依赖的，进行构建时 只有该阶段及其之前的阶段会被调用。调用 mvn deploy 时，以前阶段依次执行(不包含 clean)    </span><br><span class="line"></span><br><span class="line">validate              验证工程是否正确,且文件信息完整可以完成工程构建     </span><br><span class="line">initialize             初始化构建状态，如设置 properties、创建目录等  </span><br><span class="line">generate-sources     生成包含在编译阶段的任何源代码</span><br><span class="line">process-sources  	     处理源代码  </span><br><span class="line">generate-resources      生成将包含在工程中的资源文件  </span><br><span class="line">process-resources      处理工程资源文件: 变量替换、复制到 target&#x2F;classes 目录</span><br><span class="line">compile                编译工程源代码(一般在 src&#x2F;main目录)到 target&#x2F;classes</span><br><span class="line">process-classes        处理编译生成的文件，如对 class 文件做字节码优化  </span><br><span class="line">generate-test-sources   生成包含在编译阶段的任何测试源代码  </span><br><span class="line">process-test-sources     处理测试源代码 </span><br><span class="line">generate-test-resources   生成将包含在工程的测试资源文件</span><br><span class="line">process-test-resources     处理工程测试资源文件: 变量替换、复制到 target&#x2F;test-classes 目录</span><br><span class="line">test-compile         编译工程测试源代码(一般在 src&#x2F;test 目录)到 target&#x2F;test-classes </span><br><span class="line">process-test-classes     处理测试编译生成的文件，如对 class 文件做字节码优化  </span><br><span class="line">test                 使用单元测试框架运行测试   </span><br><span class="line">prepare-package    为打包做准备  </span><br><span class="line">package              使用已编译好的 classes 和 test-classes，打包成可发布的形式放到工程 target 目录下</span><br><span class="line">pre-integration-test   集成测试前的准备工作，如搭建集成测试环境</span><br><span class="line">integration-test       集成测试  </span><br><span class="line">post-integration-test   集成测试后的工作，如清理集成测试环境  </span><br><span class="line">verify          检查工程可发布包有效且达到质量标准  </span><br><span class="line">install           将 target 目录下的可发布包安装到本地仓库，使其可被本地其他工程使用  </span><br><span class="line">deploy      将本地仓库下的可发布包安装到远程仓库(e.g. mvn repository)，使其可被其他工程、开发人员下载使用</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>MAVEN_OPTS=”-Xmx2G -Xms2G -XX:+UseG1GC XX:+TieredCompilation -XX:TieredStopAtLevel=1”<br>mvn -T 2C clean install -pl module1,module2 -am -offline &gt; install.log   </p>
<p>mvn install:install-file -Dfile=$file -DgroupId=$groupId –DartifactId=$artifactId -Dversion=$version -Dpackaging=jar   </p>
<p>mvn dependency:tree  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>生命周期  <a href="https://www.runoob.com/maven/maven-build-life-cycle.html" target="_blank" rel="noopener">https://www.runoob.com/maven/maven-build-life-cycle.html</a><br>TieredCompilation   <a href="https://www.jianshu.com/p/318617435789" target="_blank" rel="noopener">https://www.jianshu.com/p/318617435789</a></p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Spark TPC-DS 性能测试数据</title>
    <url>/2020-02-14-Apache%20Spark%20TPCDS%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h2 id="关于-TPC-DS"><a href="#关于-TPC-DS" class="headerlink" title="关于 TPC-DS"></a>关于 TPC-DS</h2><p>TPC(Transaction Process Performance Council, 事务处理性能委员会)是制定商务应用基准程序(Benchmark)的标准规范、性能和价格度量的非营利性组织。TPC-DS 是一个决策支持标准测试，它对决策支持系统的普适性建模，包括查询和数据修改维护。作为一个通用的决策支持标准测试，其提供了具有代表性的性能评估，测试结果包括单用户模式下的查询相应时间、多用户模式下的查询吞吐量、在受控复杂多用户决策支持的工作负载下给定硬件 操作系统 数据处理系统软件配置的数据维护性能。TPC-DS 决策支持标准测试目的是为行业用户提供客观的性能数据。TPC-DS 决策支持一些新兴技术，例如 Hadoop、Spark等大数据解决方案。</p>
<a id="more"></a>

<h2 id="TPC-DS-数据模型"><a href="#TPC-DS-数据模型" class="headerlink" title="TPC-DS 数据模型"></a>TPC-DS 数据模型</h2><p>TPC-DS 使用零售业务建模，schema 包括客户、订单、销售、退货和产品数据等业务信息。标准测试模拟了任何成熟的决策支持系统都必须具备的两个重要组成部分:  </p>
<ol>
<li>用户查询: 数据分析、挖掘，可将运营事实转换为商业智能  </li>
<li>数据维护: 可将管理分析过程与其所依赖的可操作外部数据源同步  </li>
</ol>
<p>TPC-DS 使用星型、雪花模型建模，有多个维度和事实表。每个维度表都有主键，事实表使用外键与维度表主键关联。
维度表可以分为以下类型:  </p>
<ol>
<li>静态：表内容在数据库加载期间仅加载一次，且数据不随着时间变化而变化。  </li>
<li>历史记录：为单个业务实体创建多行来保存维度数据更改的历史记录，每行包括创建/修改时间的列。”项目”是历史记录维度信息的一个范例。  </li>
<li>非历史记录：不保留对维度数据所做更改的历史记录。随着维度数据的更新，之前保留的信息将被覆盖。所有事实表都与维度信息的最新值关联。”客户信息”是非历史记录维度信息的一个范例。  </li>
</ol>
<p>TPC-DS 有 7 个事实表和 17 个维度表，平均每个表列数在 20 左右，且数据分布是真实而不均匀的，存在数据倾斜，与真实场景非常接近。因此TPC-DS成为客观衡量不同 Hadoop 版本以及 SQL on Hadoop 技术的最佳测试数据集。<br>事实表包含 商店、仓库和互联网三个销售渠道中每个渠道的建模产品销售和退货事实表；库存事实表。<br>维度表用于和每个销售渠道相关信息关联。  </p>
<p>注： ER 图设计及事实表和维度表表结构详见官方文档(specification.pdf)    </p>
<h2 id="TPC-DS-查询语句"><a href="#TPC-DS-查询语句" class="headerlink" title="TPC-DS 查询语句"></a>TPC-DS 查询语句</h2><p>由标准建模的查询语句(q1~q99)具有以下特征：  </p>
<ol>
<li>解决复杂的业务问题 </li>
<li>使用各种访问模式、查询短语、运算符和约束  </li>
<li>使用会在各种查询过程之间变化的查询参数  </li>
</ol>
<h2 id="下载-TP-CDS-kit"><a href="#下载-TP-CDS-kit" class="headerlink" title="下载 TP-CDS kit"></a>下载 TP-CDS kit</h2><p>TPCDS  kit 是生成测试数据的工具  </p>
<p>方法一: 官网下载 <a href="http://www.tpc.org/tpc_documents_current_versions/current_specifications.asp" target="_blank" rel="noopener">http://www.tpc.org/tpc_documents_current_versions/current_specifications.asp</a><br>    填写自己的邮箱后，官方会将下载链接发送到邮箱内，下载即可，文件包大小为 5MB 左右。<br>方法二: github 下载 <a href="https://github.com/gregrahn/tpcds-kit/tree/master" target="_blank" rel="noopener">https://github.com/gregrahn/tpcds-kit/tree/master</a>  </p>
<p>解压后目录数如下，  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree -d v2.11.0rc2&#x2F;  </span><br><span class="line"></span><br><span class="line">v2.11.0rc2&#x2F;</span><br><span class="line">├── answer_sets</span><br><span class="line">├── query_templates</span><br><span class="line">├── query_variants</span><br><span class="line">├── specification</span><br><span class="line">├── tests</span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure>
<p>其中 specification为 tpcds 说明书，包括工具说明、数据模型、ER 图、度量信息等；query_templates 为查询语句模板；query_variants 为查询语句模板的参数；answer_sets 为查询结果集；tools 为数据集生成及查询语句生成工具集。Apache Spark sql/core module 内置了org.apache.spark.sql.execution.benchmark.TPCDSQueryBenchmark 测试入口和 tpcds q1~q99 查询语句。因此只需将测试数据准备好即可。  </p>
<h2 id="生成-TPC-DS"><a href="#生成-TPC-DS" class="headerlink" title="生成 TPC-DS"></a>生成 TPC-DS</h2><p>TPC-DS 可根据模拟场景产生以 GB 为最小粒度的数据集，常见的有 1TB、3TB、10TB、30TB、100TB等。  </p>
<h3 id="编译-tpcds-kit"><a href="#编译-tpcds-kit" class="headerlink" title="编译 tpcds kit"></a>编译 tpcds kit</h3><p>需要在每个节点上编译tpcds kit  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc make flex bison byacc git  </span><br><span class="line">cd v2.11.0rc2&#x2F;tools  </span><br><span class="line">make clean &amp;&amp; make OS&#x3D;LINUX</span><br></pre></td></tr></table></figure>
<p>编译完成后，在 tools 目录下会多出两个可执行文件: dsdgen,dsqgen。dsdgen 用于生成测试数据，dsqgen 用于生成在不同 SQL 标准下的查询语句。  </p>
<h3 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h3><p>databricks 为 Spark SQL 制作的数据生成工具 spark-sql-perf，似乎不如其宣传的那么好用。<br>spak-sql-perf github 地址:  <a href="https://github.com/databricks/spark-sql-perf" target="_blank" rel="noopener">https://github.com/databricks/spark-sql-perf</a>    </p>
<p>其原理是: 依次为每个表 并行调用 tpcds kit的 dsdgen 命令生成数据(本地磁盘、text格式、’|’分割、无压缩) 作为表数据集，即生成的所有数据为 DataFrame、每个并行调用 dsdgen 产生的数据为 DataFrame 的分区。 然后将此数据集转换(读取再存储)为 hdfs上的 parquet+snappy 文件，并创建为 Hive 的外部表。核心代码如下    </p>
<p>调用 dsdgen 命令生成分区数据<br>[DSDGEN.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DSDGEN(dsdgenDir: String) extends DataGenerator &#123;</span><br><span class="line">  val dsdgen &#x3D; s&quot;$dsdgenDir&#x2F;dsdgen&quot;</span><br><span class="line">  def generate(sparkContext: SparkContext, name: String, partitions: Int, scaleFactor: String) &#x3D; &#123;</span><br><span class="line">    val generatedData &#x3D; &#123;</span><br><span class="line">      sparkContext.parallelize(1 to partitions, partitions).flatMap &#123; i &#x3D;&gt;</span><br><span class="line">        val localToolsDir &#x3D; if (new java.io.File(dsdgen).exists) &#123;</span><br><span class="line">          dsdgenDir</span><br><span class="line">        &#125; else if (new java.io.File(s&quot;&#x2F;$dsdgen&quot;).exists) &#123;</span><br><span class="line">          s&quot;&#x2F;$dsdgenDir&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          sys.error(s&quot;Could not find dsdgen at $dsdgen or &#x2F;$dsdgen. Run install&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        val parallel &#x3D; if (partitions &gt; 1) s&quot;-parallel $partitions -child $i&quot; else &quot;&quot;</span><br><span class="line">        val commands &#x3D; Seq(</span><br><span class="line">          &quot;bash&quot;, &quot;-c&quot;,</span><br><span class="line">          s&quot;cd $localToolsDir &amp;&amp; .&#x2F;dsdgen -table $name -filter Y -scale $scaleFactor -RNGSEED 100 $parallel&quot;)</span><br><span class="line">        println(commands)</span><br><span class="line">        BlockingLineStream(commands)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    generatedData.setName(s&quot;$name, sf&#x3D;$scaleFactor, strings&quot;)</span><br><span class="line">    generatedData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spark-sql-perf 拼接的并行 dsdgen 命令类似于:  cd tpcds/v2.11.0rc2/tools &amp;&amp; ./dsdgen -table catalog_sales -filter Y -scale 3000 -RNGSEED 100 -parallel 2000 -child 8，scala=3000意为生成 3000G数据集，-table= catalog_sales 当前生成表，-filter=Y 意为输出数据到 stdout，-RNGSEED=100 意为 RNG seed 值，-parallel=2000 意为并行度 2000 生成数据，-child 为当前并行的标识 用于命名本地数据文件。  </p>
<p>命令存在的问题(tpcds-kit 分支 master、v2.10、v2.5、v2.3均存在):  </p>
<ol>
<li>tpcds kit 的识别的 option 为 _filter,但是 spark-sql-perf 拼接的命令为 -filter    </li>
<li>tpcds 数据模型之间有依赖关系，不能独立生成，表数据之间不是完全独立的，e.g. 销售表和退货表。 
为 table = catalog_returns 生成数据时 dsdgen 会抛出错误 ERROR: Table catalog_returns is a child; it is populated during the build of its parent (e.g., catalog_sales builds catalog_returns)   </li>
</ol>
<p>尝试切换了 master、v2.10、 v2.5、 v2.3等分支 均无法解决上述问题。<br>针对上述，我采用的方案是 依旧以 spark-sql-perf 为主体(表结构、dsdgen 生成数据、数据转换 parquet 到 hdfs、创建 hive 外部表等)，修改点如下： </p>
<ol>
<li>修改数据并行生成命令   <pre><code>val commands = Seq(
 &quot;bash&quot;, &quot;-c&quot;,
 s&quot;cd $localToolsDir &amp;&amp; ./dsdgen -_filter Y -scale $scaleFactor -RNGSEED 100 $parallel&quot;)</code></pre></li>
<li>增加 并行数据生成后，把生成的数据上传到 hdfs 上的逻辑    </li>
<li>修改表 DataFrame(RDD)生成逻辑，原有的逻辑为 dsdgen 命令包装为BlockingLineStream，修改为从 hdfs 上读取 $tableName*.dat 的逻辑</li>
<li>text 文本转 parquet + snappy 逻辑不变、创建 hive 外部表关联到 parquet 文件的逻辑不变。  </li>
</ol>
<p>3TB 测试数据集文件上传到 hdfs 后，使用 spark 来转换数据为 parquet 并注册外部表程序如下<br>3TB 测试数据集使用 Spark 程序转换格式时，spark.executor.memory+spark.executor.memoryOverhead 不低于 10GB。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spark-shell --master yarn-client --name &quot;transformation&quot; --queue high --executor-memory 8G --driver-memory 4G --num-executors 200 --conf &quot;spark.executor.memoryOverhead&#x3D;8G&quot; --jars ~&#x2F;tpcds&#x2F;spark-sql-perf_2.11-0.5.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">import scala.sys.process._</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue</span><br><span class="line">import scala.collection.immutable.Stream</span><br><span class="line">import com.databricks.spark.sql.perf.BlockingLineStream</span><br><span class="line">import com.databricks.spark.sql.perf.BlockingLineStream.Spawn </span><br><span class="line">import com.databricks.spark.sql.perf.BlockingLineStream.BlockingStreamed</span><br><span class="line">import com.databricks.spark.sql.perf.tpcds.TPCDSTables</span><br><span class="line">import org.apache.spark.sql._</span><br><span class="line"></span><br><span class="line">val partitions &#x3D; 200</span><br><span class="line">val scaleFactor &#x3D; &quot;3000&quot; </span><br><span class="line">val localToolsDir &#x3D; &quot;&#x2F;home&#x2F;jiulong.zhu&#x2F;tpcds&#x2F;v2.11.0rc2&#x2F;tools&quot;</span><br><span class="line">val rootDir: String &#x3D; &quot;hdfs:&#x2F;&#x2F;pub1&#x2F;user&#x2F;jiulong.zhu&#x2F;tpcds3t&quot; </span><br><span class="line">val databaseName &#x3D; &quot;tpcds3t&quot;</span><br><span class="line">val sqlContext &#x3D; new SQLContext(sc)</span><br><span class="line">val format &#x3D; &quot;parquet&quot;</span><br><span class="line">sc.parallelize(1 to partitions,partitions).flatMap &#123; i &#x3D;&gt;</span><br><span class="line">        val parallel &#x3D; if (partitions &gt; 1) s&quot;-parallel $partitions -child $i&quot; else &quot;&quot;</span><br><span class="line">        val commands &#x3D; Seq(</span><br><span class="line">          &quot;bash&quot;, &quot;-c&quot;,</span><br><span class="line">          s&quot;cd $localToolsDir &amp;&amp; .&#x2F;dsdgen -dir data&#x2F; -_filter Y -scale $scaleFactor -RNGSEED 100 $parallel -force Y&quot;)</span><br><span class="line">        println(commands)</span><br><span class="line">        val streamed &#x3D; com.databricks.spark.sql.perf.BlockingLineStream.BlockingStreamed[String](true)</span><br><span class="line">        val process &#x3D; commands.run(BasicIO(false, streamed.process, None))</span><br><span class="line">        Spawn(streamed.done(process.exitValue()))</span><br><span class="line">        val hdfsCommand &#x3D;  Seq(</span><br><span class="line">          &quot;bash&quot;, &quot;-c&quot;,</span><br><span class="line">          s&quot;cd $localToolsDir &amp;&amp; .hadoop fs -put data&#x2F;*.dat temp&#x2F;&quot;)</span><br><span class="line">          val putProcess &#x3D; hdfsCommand.run(BasicIO(false, streamed.process, None))</span><br><span class="line">        Spawn(streamed.done(putProcess.exitValue()))          </span><br><span class="line">        Seq(streamed.stream())</span><br><span class="line">      &#125;.collect()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Run:</span><br><span class="line">val tables &#x3D; new TPCDSTables(sqlContext,</span><br><span class="line">    dsdgenDir &#x3D; localToolsDir, &#x2F;&#x2F; location of dsdgen</span><br><span class="line">    scaleFactor &#x3D; scaleFactor,</span><br><span class="line">    useDoubleForDecimal &#x3D; false, &#x2F;&#x2F; true to replace DecimalType with DoubleType</span><br><span class="line">    useStringForDate &#x3D; false) &#x2F;&#x2F; true to replace DateType with StringType</span><br><span class="line"></span><br><span class="line">tables.genData(</span><br><span class="line">    location &#x3D; rootDir,</span><br><span class="line">    format &#x3D; format,</span><br><span class="line">    overwrite &#x3D; true, &#x2F;&#x2F; overwrite the data that is already there</span><br><span class="line">    partitionTables &#x3D; true, &#x2F;&#x2F; create the partitioned fact tables</span><br><span class="line">    clusterByPartitionColumns &#x3D; true, &#x2F;&#x2F; shuffle to get partitions coalesced into single files.</span><br><span class="line">    filterOutNullPartitionValues &#x3D; false, &#x2F;&#x2F; true to filter out the partition with NULL key value</span><br><span class="line">    tableFilter &#x3D; &quot;&quot;, &#x2F;&#x2F; &quot;&quot; means generate all tables</span><br><span class="line">    numPartitions &#x3D; 2000) &#x2F;&#x2F; how many dsdgen partitions to run - number of input tasks.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create the specified database</span><br><span class="line">sql(s&quot;create database if not exists $databaseName&quot;)</span><br><span class="line">&#x2F;&#x2F; Create metastore tables in a specified database for your data.</span><br><span class="line">&#x2F;&#x2F; Once tables are created, the current database will be switched to the specified database.</span><br><span class="line">tables.createExternalTables(rootDir, &quot;parquet&quot;, databaseName, overwrite &#x3D; true, discoverPartitions &#x3D; true)</span><br></pre></td></tr></table></figure>

<p>tpcds 3TB 数据集在 text无压缩格式下为 2.7TB，转为 parquet snappy 格式后约为 900GB，orc snappy 格式约为 800GB。</p>
<h2 id="测试-SparkSQL"><a href="#测试-SparkSQL" class="headerlink" title="测试 SparkSQL"></a>测试 SparkSQL</h2><p>nohup sh TPCDSBench.sh &amp;<br>TPCDSBench.sh  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SPARK_HOME&#x3D;&#x2F;home&#x2F;jiulong.zhu&#x2F;spark-2.3.0-bin-hadoop2.7</span><br><span class="line">MASTER&#x3D;yarn-client</span><br><span class="line">APP_NAME&#x3D;AE_ENABLED</span><br><span class="line">DRIVER_MEMORY&#x3D;8G</span><br><span class="line">EXECUTOR_MEMORY&#x3D;10G</span><br><span class="line">NUM_EXECUTORS&#x3D;100</span><br><span class="line">EXECUTOR_CORES&#x3D;5</span><br><span class="line">EX_JARS&#x3D;&#x2F;home&#x2F;jiulong.zhu&#x2F;tpcds&#x2F;spark-sql_2.11-2.3.1-SNAPSHOT-tests.jar</span><br><span class="line">AE_ENABLE&#x3D;false</span><br><span class="line"></span><br><span class="line">spark-submit --master $MASTER --name $&#123;APP_NAME&#125;_$&#123;AE_ENABLE&#125; \</span><br><span class="line">--conf &quot;spark.executor.instances&#x3D;$NUM_EXECUTORS&quot; \</span><br><span class="line">--conf &quot;spark.executor.cores&#x3D;$EXECUTOR_CORES&quot; \</span><br><span class="line">--conf &quot;spark.sql.crossJoin.enabled&#x3D;true&quot; \</span><br><span class="line">--conf &quot;spark.sql.autoBroadcastJoinThreshold&#x3D;21971520&quot; \</span><br><span class="line">--conf &quot;spark.default.parallelism&#x3D;1000&quot; \</span><br><span class="line">--conf &quot;spark.sql.shuffle.partitions&#x3D;1000&quot; \</span><br><span class="line">--conf &quot;spark.sql.parquet.compression.codec&#x3D;snappy&quot; \</span><br><span class="line">--conf &quot;spark.sql.adaptive.enabled&#x3D;$&#123;AE_ENABLE&#125;&quot; \</span><br><span class="line">--conf &quot;spark.dynamicAllocation.enabled&#x3D;false&quot; \</span><br><span class="line">--conf &quot;spark.executor.memoryOverhead&#x3D;10G&quot; \</span><br><span class="line">--conf &quot;spark.sql.adaptive.minNumPostShufflePartitions&#x3D;1000&quot; \</span><br><span class="line">--queue high \</span><br><span class="line">--driver-memory $DRIVER_MEMORY --executor-memory $EXECUTOR_MEMORY \</span><br><span class="line">--class org.apache.spark.sql.execution.benchmark.TPCDSQueryBenchmark $EX_JARS \</span><br><span class="line">--data-location hdfs:&#x2F;&#x2F;pub1&#x2F;user&#x2F;jiulong.zhu&#x2F;tpcds3t</span><br></pre></td></tr></table></figure>

<h2 id="附录及参考"><a href="#附录及参考" class="headerlink" title="附录及参考"></a>附录及参考</h2><ol>
<li>从大数据平台二次开发、性能优化方面，准备一套合适的性能测试数据、通用查询语句、工具和测试流程对于性能提升量化和成果量化有非比寻常的意义。    </li>
<li>可以试试 IBM 的 spark-tpc-ds-performance-test(<a href="https://github.com/IBM/spark-tpc-ds-performance-test)，但是仍旧需要自备一套" target="_blank" rel="noopener">https://github.com/IBM/spark-tpc-ds-performance-test)，但是仍旧需要自备一套</a> TPCDS 测试数据集。   </li>
<li>参考:<br>　　<a href="https://databricks.com/session/spark-sql-2-0-experiences-using-tpc-ds" target="_blank" rel="noopener">https://databricks.com/session/spark-sql-2-0-experiences-using-tpc-ds</a><br>　　<a href="https://github.com/databricks/spark-sql-perf" target="_blank" rel="noopener">https://github.com/databricks/spark-sql-perf</a>   </li>
</ol>
]]></content>
      <tags>
        <tag>Spark 2.3</tag>
        <tag>Adaptive Execution</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Executor 内存动态扩展方案</title>
    <url>/2020-01-10-Spark%20Executor%20%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E6%8B%93%E5%B1%95%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spark Application 提交之后 Executor 内存被固定，业务环境上的长流程或长时处理任务经常由于 Executor 内存不足失败，导致人工干预、流程延迟且 Application 级恢复成本比较高。这种情况下，希望有套机制能够在 Executor 失败后再申请更大内存的 Executor 、对 Task 层面有更好的容错，在一定程度上减少 Task 由内存不足失败导致的 Application 失败恢复和人工干预成本。  </p>
<a id="more"></a>

<p>前置条件:   </p>
<ol>
<li>Spark On Yarn  </li>
<li>开启动态资源分配(spark.dynamicAllocation.enabled)  </li>
</ol>
<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">RDD#action -&gt;&gt; SparkContext : 1.runJob(rdd,func,partitions,resultHandler)</span><br><span class="line">SparkContext -&gt;&gt; DAGScheduler : 2. submitJob(rdd,func,partitions,resultHandler)</span><br><span class="line">DAGScheduler -&gt;&gt; DAGScheduler : 3. JobSubmitted &amp;&amp; createResultStage &amp;&amp; getOrCreateParentStages &amp;&amp; submitStages &amp;&amp; submitMissingTasks</span><br><span class="line">DAGScheduler -&gt;&gt; TaskScheduler : 4.submitTasks(createTaskSet)</span><br><span class="line">TaskScheduler -&gt;&gt; SchedulerBackEnd : 5.reviveOffers</span><br><span class="line"></span><br><span class="line">loop period &amp; event</span><br><span class="line">	SchedulerBackEnd -&gt;&gt; TaskScheduler : 6.makeOffers &amp;&amp; resourceOffers</span><br><span class="line">	Driver -&gt;&gt; Executor : 7.LaunchTask</span><br><span class="line">end</span><br><span class="line">SchedulerBackEnd --&gt;&gt; - RDD#action : 8. statusUpdate &amp;&amp; callBack</span><br></pre></td></tr></table></figure>

<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><ol>
<li>Container(或 Executor) 由于内存超限被杀死的原因有两个: 物理内存(-104,137)/虚拟内存(-103,137)超限被 Yarn 资源监控线程杀死；堆内存 OOM 导致 JVM 进程被 kill，退出码是 143。退出码的不同决定了要增加的内存配置不同: -104,-103 和 137需要增加 Container 整体内存；143 需要增加堆内存。(YarnAllocator#allocateResource 拿到 Yarn 新分配的 container 和正常及异常退出的 container)   </li>
<li>内存拓展的 Executor 启动参数修改: Executor 内存提升次数(默认0)，堆内存，全内存。主要用于 Executor 向 Driver 注册时标识自身的特征，该特征可以使 TaskScheduler将 OOM Task 调度到该 Executor。(YarnAllocator#allocator 拿到 Yarn 新分配的 container,ExecutorRunnable,CoarseGrainedExecutorBackend,RegisterExecutor 数据结构修改)    </li>
<li>内存拓展的 Executor 注册/注销 -&gt;&gt; 额外维护的可运行 OOM Task 的 Executor 列表更新，ExecutorAdd、ExecutorLost、KillExecutor 等。(CoarseGrainedSchedulerBackEnd,ExecutorId和[提升次数,堆内存,全内存]的映射,提升次数和 ExecutorId 集合的映射)      </li>
<li>普通 Task, OOM Task 失败的处理 -&gt;&gt; OOM Task失败则必须调度到内存拓展过的 Executor，已经在内存拓展过的 Executor 失败的 OOM Task 后要调度到更大或当前最大内存的 Executor，非 OOM 失败的 task 走现有容错调度(TaskSchedulerImpl)  </li>
<li>大内存 ExecutorLost -&gt;&gt; 根据维护的ExecutorId 和[提升次数,堆内存,全内存]映射及 Container 退出码及内存拓展算法来决定下一次申请的 ContainerResource和 JVM 启动的 XMX    </li>
<li>因动态资源分配功能超时退出 或 Yarn 抢占导致的 ExecutorLost在 YarnAllocator 使用大根堆或 最大值来记录资源信息,在下一次申请时不通过内存提升算法。   </li>
<li>OOM Task 容错: OOM Task 加入到一个特定的 pending 队列,以和普通错误 Task 做区分。TaskScheduler/ExecutorAdd/TaskCompletion 触发的 reviveOffer时,优先从特定 pending 队列调度 判断 ExecutorId 能否可能支撑该 Task(原所属失败的 Executor 提升内存次数必须小于当前 ExecutorId 提升内存次数)。若能则调度,若不能则不调度该任务,调度普通 pending 队列。  </li>
<li>动态资源分配使用 running tasks和 pending tasks 及 spark.task.cores 来推测需要的总 Executor 数量。在系统的某时刻，可能有 OOM Task 但是却无内存拓展过的 Executor,推测可能也不需要新的 Executor。即: 当有 OOM Task 却无拓展内存的 Executor 时,需要在 CoarseGrainedSchedulerBackend 通过 ExecutorAllocationClient 的 requestTotalExecutor/requestExecutor 接口来触发申请 Executor。数量为 Max{当前 Executor数量/5,1},取 Max 是为了增加本地化可能性，多申请的资源由动态资源分配来管理。    </li>
<li>YarnAllocator 维护的状态需要有复原功能: OOM 时下一批次申请的 Executor 都是拓展过内存的，随后复原，以适配动态资源分配功能。YarnAllocator 取消堆积在 RM 的 ResourceRequest 时,优先取消没有拓展过内存的,不足则取消拓展过内存的 ResourceRequest。  </li>
</ol>
<h2 id="Task-失败处理线"><a href="#Task-失败处理线" class="headerlink" title="Task 失败处理线"></a>Task 失败处理线</h2><ol>
<li>DriverEndPoint 首先接收到任务 StatusUpdate 事件转交由 CoarseGrainedSchedulerBackEnd 处理  </li>
<li>CoarseGrainedSchedulerBackEnd 交由 TaskSchedulerImpl 处理 StatusUpdate 事件  </li>
<li>TaskSchedulerImpl 解析 StatusUpdate 事件的任务状态,并判断其成功/失败，若失败则需要交由 TaskSetManager 维护状态，加入到特定的失败堆积队列  </li>
<li>a.若此时全局无大内存 Executor，则需要绕过动态资源分配主动申请大内存 Executor，但此时全局无大内存 Executor 故暂不处理当前 OOM Task。 b.若有则阶梯式分配 OOM Task: 判断原有运行该 Task 的 Executor 提升次数，将失败任务分配到更高/最高提升次数的 Executor 上。若原有运行 Executor 内存已经最大，则依据加内存次数抛出异常终止 Application 或主动申请更大内存 Executor，暂不处理当前 OOM Task([3G,4G,5G] 3G上失败任务可指派给最高阶梯 5G,也可以指派给较高阶梯 4G)。  </li>
<li>对某个 Executor 分配任务(TaskCompletion/ExecutorAdd)时，对 Executor 进行判断，在内存满足的情况下，优先分配特定失败堆积队列的任务，再指派 TaskSetManager 中普通任务或 pending 任务。 </li>
</ol>
<h2 id="Executor-失败处理线"><a href="#Executor-失败处理线" class="headerlink" title="Executor 失败处理线"></a>Executor 失败处理线</h2><p>基于 AM 和 RM 资源申请模式，AM updateResourceRequest 更新最新 ResourceRequest 给 RM，RM 响应 AM 的 allocateResource 请求通知新分配的 container,正常异常退出的 container。由此 AM 在新分配的 container 上启动新的 Executor，判断退出的 container 的退出码确定退出原因   </p>
<ol>
<li>YarnAllocator 判断容器退出原因，若为 Yarn 抢占或 AM 主动杀死则记录到最大堆中，若为内存问题则使用内存拓展算法计算出下一次 updateResourceRequest 时 Container 配置、 Jvm 配置和内存拓展次数    </li>
<li>动态资源分配或主动申请容器时 判断是否需要提升内存，若是则通过 updateResourceRequest 来修改;若否则使用大跟堆中的配置  </li>
<li>动态资源分配当当前需要的 Executor 总量低于已有量时，取消 ResourceRequest 优先取消普通内存配置的 ResourceRequest，不足则取消内存拓展过的 Executor </li>
</ol>
<h2 id="内存增加算法"><a href="#内存增加算法" class="headerlink" title="内存增加算法"></a>内存增加算法</h2><ol>
<li>需要考虑 Yarn 规整(申请的 Container Resource 会被规整到 yarn.scheduler.minimum-allocation-mb 的整数倍)； </li>
<li>增加 Container 整体资源量时需要按比例分配(堆内:堆外默认为 10:1,可适当修改)；  </li>
<li>从低内存跃迁至高内存的次数不能太大,即提升快然后迅速收敛以降低中间的失败尝试次数，可选择初始高增量快速降低的方式(e.g. 对数或固定系数，第一次提升0.5,第二次0.3,第三次 0.1,超出最大允许拓展次数后如果OOM 则快速抛出异常终止任务人为干预)。  </li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>DAGScheduler 处理的事件类型:    </p>
<ul>
<li>JobSubmitted   </li>
<li>JobCancelled  </li>
<li>JobGroupCancelled  </li>
<li>AllJobsCancelled  </li>
<li>MapStageSubmitted   </li>
<li>ResubmitFailedStages  </li>
<li>StageCancelled  </li>
<li>ExecutorAdded  </li>
<li>ExecutorLost  </li>
<li>WorkerRemoved  </li>
<li>TaskSetFailed  </li>
<li>BeginEvent   </li>
<li>CompletionEvent </li>
<li>SpeculativeTaskSubmitted  </li>
<li>GettingResultEvent     </li>
</ul>
<p>CoarseGrainedSchedulerBackEnd(Driver) 处理的事件类型:   </p>
<ul>
<li>RegisterExecutor  </li>
<li>StopDriver  </li>
<li>StopExecutors  </li>
<li>RemoveWorker  </li>
<li>RetrieveSparkAppConfig    </li>
<li>StatusUpdate  </li>
<li>ReviveOffers  </li>
<li>KillTask  </li>
<li>KillExecutorsOnHost  </li>
<li>UpdateDelegationTokens  </li>
<li>RemoveExecutor  </li>
</ul>
]]></content>
      <tags>
        <tag>Spark 2.3</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Spark 3.0 Preview 新特性和改动</title>
    <url>/2019-12-27-Apache%20Spark%203.0%20Preview%20%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E6%94%B9%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Apache Spark 3.0 Preview(预览版)发布于 2019-11-23。就 API 和功能而言预览版不是稳定版本，本文将列出预览版的重要新特性和改动。  </p>
<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="Adaptive-Execution-Of-SparkSQL-适应性执行-AE"><a href="#Adaptive-Execution-Of-SparkSQL-适应性执行-AE" class="headerlink" title="Adaptive Execution Of SparkSQL(适应性执行,AE)"></a>Adaptive Execution Of SparkSQL(适应性执行,AE)</h3><p>适应性执行使用运行时的统计数据进行动态优化。通过使物理计划分阶段(不同于DAG的stage)并在运行期可修改，主要的优化点有:  </p>
<ol>
<li>BroadcastHashJoin(BHJ): 基础表的大小/行数来自于表 Statistics，中间操作产生的数据集大小/行数靠估计，基础表统计数据可能是错误的，中间数据集统计数据可能失真(e.g. 数据倾斜)。导致运行前制定的物理计划不适合运行时，例如运行前估计的中间数据集大小为 1GB 而选择 SortMergeJoin 但运行时发现中间数据集大小为 10MB 可以修改 join 策略为 BHJ。  </li>
<li>分区数确定问题: 当分区输入数据量很小时(数据空洞,数据倾斜)，可以使一个task 处理多个连续分区的数据量(总量不超过指定值, e.g. 64MB)。      </li>
<li>数据倾斜问题: 当分区输入数据量大于所有分区输入量中位数的指定倍数时，认为该分区数据倾斜，对此分区使用多个线程并行处理。    </li>
</ol>
<a id="more"></a>
<p>注:  </p>
<ol>
<li><a href="https://issues.apache.org/jira/browse/SPARK-9850" target="_blank" rel="noopener">SPARK-9850</a>  </li>
<li><a href="https://github.com/Intel-bigdata/spark-adaptive.git" target="_blank" rel="noopener">Intel Spark AE</a>  </li>
</ol>
<h3 id="Dynamic-Partition-Pruning-动态分区裁剪-DPP"><a href="#Dynamic-Partition-Pruning-动态分区裁剪-DPP" class="headerlink" title="Dynamic Partition Pruning(动态分区裁剪,DPP)"></a>Dynamic Partition Pruning(动态分区裁剪,DPP)</h3><p>Spark3.0引入了动态分区裁剪特性，这是 SQL 分析工作的一项重大性能改进，可以与 BI 工具集成得更好。动态分区裁剪的原理是将应用在维度表上的过滤器集合直接应用到事实表上，因此可以跳过扫描非必需的分区，减少事实表扫描的数据量。在逻辑计划和物理计划上均可以实施 DPP 策略，DPP 加速了大部分 TCPDS 查询并且在无需非规范化表的情况下很好的兼容星型模型。  </p>
<p>注:   </p>
<ol>
<li>非规范化是一种在规范化数据库之前应用以提升性能的策略。原理是通过数据冗余减少数据关联 牺牲数据的写性能以提升读性能。  </li>
<li><a href="https://databricks.com/session_eu19/dynamic-partition-pruning-in-apache-spark" target="_blank" rel="noopener">Dynamic Partition Prunning</a>    </li>
</ol>
<h3 id="Enhanced-Support-for-Deep-Learning"><a href="#Enhanced-Support-for-Deep-Learning" class="headerlink" title="Enhanced Support for Deep Learning"></a>Enhanced Support for Deep Learning</h3><p>加强了对深度学习的支持。在 Spark 3.0之前，Spark MLlib 并不专注于深度学习 没有提供图像/NLP 相关的深度学习算法。yahoo 的 TensorFlowOnSpark 等工程提供了在 Spark 上深度学习的可能，但是有很大的问题: 对 Spark 弹性计算兼容不足，单分区训练失败将在所有分区上再训练。Spark 3.0解决了这个问题，并兼容了Nvidia、AMD、Intel 等多类型 GPU    </p>
<h3 id="DataSourceV2"><a href="#DataSourceV2" class="headerlink" title="DataSourceV2"></a>DataSourceV2</h3><p>DataSourceV1 对数据源的处理有一些劣势: 过于依赖 SQLContext/DataFrame,导致底层 API 依赖高层 API；不支持列式存储的批处理接口；不支持 SQLOnStreaming 等<br>Spark 3.0对 DataSourceV2的优化:  </p>
<ol>
<li>改进谓词下推机制，可通过减少数据加载来加速查询  </li>
<li>执行可插拔的 Catalog 插件</li>
<li>支持列式存储批处理接口以提高性能  </li>
<li>支持读二进制文件 Binary File DataSource,但不支持写二进制 DataFrame 到外部数据源      </li>
</ol>
<p>注:<br><a href="https://issues.apache.org/jira/browse/SPARK-15689" target="_blank" rel="noopener">SPARK-15689</a>  </p>
<h3 id="Spark-Delta-Lake"><a href="#Spark-Delta-Lake" class="headerlink" title="Spark Delta Lake"></a>Spark Delta Lake</h3><p>Delta Lake 是一个引入了 ACID事务的开源存储层，保证了数据湖的可靠性、性能和生命周期管理。Delta Lake 可以插件式得实现或升级现有程序来事务性删除/修改大数据中的小数据。对流处理(e.g. 流式数据仓库)、数仓中拉链表等场景提供了新的方案。    </p>
<p>注:<br><a href="https://docs.databricks.com/delta/quick-start.html" target="_blank" rel="noopener">Delta Lake</a></p>
<h3 id="Graph-Feature-存疑"><a href="#Graph-Feature-存疑" class="headerlink" title="Graph Feature(存疑)"></a>Graph Feature(存疑)</h3><p>Spark 3.0加入了SparkGraph 模块用于进行图处理，可以使用 Neo4J开发的 Cypher 语言操作图模型及图算法。Neo4J 图数据库是单节点的，不适用于大数据量，SparkGraph 如何解决这个问题的?(未知)。    </p>
<h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><p>Spark 3.0 可以在 Yarn 集群上自动发现GPU，并可以在 GPU 节点上调度任务(task)。   </p>
<h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Spark 2 时代对Kubernetes 的支持相对不太成熟，在生产环境中相比 Yarn 来说更难使用且性能较差。Spark3.0 引入了新的 Shuffle Service On Kubernetes 且支持 GPU 的 Pod 级隔离。  </p>
<h2 id="改动"><a href="#改动" class="headerlink" title="改动"></a>改动</h2><h3 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h3><p>预览版及其后版本支持 Python3、Scala 2.12和 JDK11。Python2 将被弃用。  </p>
<h3 id="hadoop支持"><a href="#hadoop支持" class="headerlink" title="hadoop支持"></a>hadoop支持</h3><p>支持 Hadoop 3，预览版默认为 Hadoop2.7.4。  </p>
<h3 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h3><p>删除了不高于 Spark2.2.0 的 deprecated API、参数和功能等。</p>
<h2 id="issues附录"><a href="#issues附录" class="headerlink" title="issues附录"></a>issues附录</h2><p><a href="https://issues.apache.org/jira/sr/jira.issueviews:searchrequest-printable/temp/SearchRequest.html?jqlQuery=statusCategory+%3D+done+AND+project+%3D+12315420+AND+fixVersion+%3D+12339177+ORDER+BY+priority+DESC%2C+key+ASC&tempMax=1000" target="_blank" rel="noopener">issues</a></p>
]]></content>
      <tags>
        <tag>Spark 3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkSQL 文件读取及划分分区源码解析</title>
    <url>/2019-12-13-SparkSQL%20%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%86%E5%8C%BA%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>不考虑 SQL 文本在 SparkSQL 中的全生命周期，仅关注 SQL 物理计划读取文件及分区划分的部分逻辑    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux&gt; spark-shell --master yarn --queue high</span><br><span class="line">scala&gt; val sql&#x3D;&quot;SELECT count(1) FROM utest.u_tbl_ifs_cost_aggregations&quot;</span><br><span class="line">scala&gt; val df &#x3D; spark.sql(sql)</span><br><span class="line">scala&gt; df.queryExecution.sparkPlan</span><br><span class="line">res0: org.apache.spark.sql.execution.SparkPlan &#x3D;</span><br><span class="line">HashAggregate(keys&#x3D;[], functions&#x3D;[count(1)], output&#x3D;[count(1)#47L])</span><br><span class="line">+- HashAggregate(keys&#x3D;[], functions&#x3D;[partial_count(1)], output&#x3D;[count#96L])</span><br><span class="line">   +- FileScan orc utest.u_tbl_ifs_cost_aggregations[] Batched: true, Format: ORC, Location: InMemoryFileIndex[hdfs:&#x2F;&#x2F;bj2&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;utest.db&#x2F;u_tbl_ifs_cost_aggregations], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;&gt;</span><br></pre></td></tr></table></figure>

<p>即 SparkSQL 中读取表部分实际是委托给 FileSourceScanExec 来处理  </p>
<a id="more"></a>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>第一步: 读取逻辑分区(可能包含多个物理文件)做为数据迭代器<br>第二步: 按照是否分桶分别处理(分桶情况下，分区数和桶数量相关)<br>[FileSourceScanExec.scala]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private lazy val inputRDD: RDD[InternalRow] &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F; 第一步</span><br><span class="line">       &#x2F;&#x2F; filters 为可下推到物理文件的过滤器(e.g. 分区)</span><br><span class="line">    val readFile: (PartitionedFile) &#x3D;&gt; Iterator[InternalRow] &#x3D;</span><br><span class="line">      relation.fileFormat.buildReaderWithPartitionValues(</span><br><span class="line">        sparkSession &#x3D; relation.sparkSession,</span><br><span class="line">        dataSchema &#x3D; relation.dataSchema,</span><br><span class="line">        partitionSchema &#x3D; relation.partitionSchema,</span><br><span class="line">        requiredSchema &#x3D; requiredSchema,</span><br><span class="line">        filters &#x3D; pushedDownFilters,</span><br><span class="line">        options &#x3D; relation.options,</span><br><span class="line">        hadoopConf &#x3D; relation.sparkSession.sessionState.newHadoopConfWithOptions(relation.options))</span><br><span class="line">        &#x2F;&#x2F; 第二步</span><br><span class="line">    relation.bucketSpec match &#123;</span><br><span class="line">      case Some(bucketing) if relation.sparkSession.sessionState.conf.bucketingEnabled &#x3D;&gt;</span><br><span class="line">        createBucketedReadRDD(bucketing, readFile, selectedPartitions, relation)</span><br><span class="line">      case _ &#x3D;&gt;</span><br><span class="line">        createNonBucketedReadRDD(readFile, selectedPartitions, relation)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>按照未分桶的情况来看  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private def createNonBucketedReadRDD(</span><br><span class="line">      readFile: (PartitionedFile) &#x3D;&gt; Iterator[InternalRow],</span><br><span class="line">      selectedPartitions: Seq[PartitionDirectory],</span><br><span class="line">      fsRelation: HadoopFsRelation): RDD[InternalRow] &#x3D; &#123;</span><br><span class="line">      &#x2F;&#x2F; 单(逻辑)分区最大数据量，默认 128 MB</span><br><span class="line">    val defaultMaxSplitBytes &#x3D;</span><br><span class="line">      fsRelation.sparkSession.sessionState.conf.filesMaxPartitionBytes</span><br><span class="line">      &#x2F;&#x2F; 打开文件的代价,默认 4MB。一般理解为单(逻辑)分区最小数据量，物理小文件较多时合并多个物理文件为一个逻辑分区</span><br><span class="line">      &#x2F;&#x2F; 避免过多的小任务</span><br><span class="line">    val openCostInBytes &#x3D; fsRelation.sparkSession.sessionState.conf.filesOpenCostInBytes</span><br><span class="line">    &#x2F;&#x2F; 默认并行度,取的是 CoarseGrainedSchedulerBackend#defaultParallelism</span><br><span class="line">    val defaultParallelism &#x3D; fsRelation.sparkSession.sparkContext.defaultParallelism</span><br><span class="line">    &#x2F;&#x2F; 文件夹下所有文件累计大小</span><br><span class="line">    val totalBytes &#x3D; selectedPartitions.flatMap(_.files.map(_.getLen + openCostInBytes)).sum</span><br><span class="line">    &#x2F;&#x2F; 每个 core 分均处理数据量  </span><br><span class="line">    val bytesPerCore &#x3D; totalBytes &#x2F; defaultParallelism</span><br><span class="line">    val files &#x3D; fsRelation.inputFiles.mkString(&quot;,&quot;)</span><br><span class="line">    logInfo(s&quot;$&#123;fsRelation.toString&#125;, sizeInBytes: $&#123;fsRelation.location.sizeInBytes&#125;, files: $&#123;files&#125;&quot;)</span><br><span class="line">    val log &#x3D; s&quot;defaultParallelism: $&#123;defaultParallelism&#125;, totalBytes: $&#123;totalBytes&#125;, bytesPerCore: $&#123;bytesPerCore&#125;&quot;</span><br><span class="line">    logInfo(log)</span><br><span class="line">    &#x2F;&#x2F; 期望分区大小。 公式含义: 在单分区处理数据量不超过 128M 且不低于 4MB的条件下,所有数据负载均衡给各并发处理</span><br><span class="line">    val maxSplitBytes &#x3D; Math.min(defaultMaxSplitBytes, Math.max(openCostInBytes, bytesPerCore))</span><br><span class="line">    logInfo(s&quot;Planning scan with bin packing, max size: $maxSplitBytes bytes, &quot; +</span><br><span class="line">      s&quot;open cost is considered as scanning $openCostInBytes bytes.&quot;)</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; selectedPartitions 是分区下推之后的所有分区目录,非分区表或无需分区下推的情况下,为表在 hdfs 目录</span><br><span class="line">    val splitFiles &#x3D; selectedPartitions.flatMap &#123; partition &#x3D;&gt;</span><br><span class="line">      partition.files.flatMap &#123; file &#x3D;&gt;</span><br><span class="line">        val blockLocations &#x3D; getBlockLocations(file)</span><br><span class="line">        &#x2F;&#x2F; 若文件可分割,则按照&quot;期望分区大小&quot;来划分作为 逻辑上的文件</span><br><span class="line">        &#x2F;&#x2F; 若文件不可分割,每个物理文件作为一个 逻辑上的文件</span><br><span class="line">        if (fsRelation.fileFormat.isSplitable(</span><br><span class="line">            fsRelation.sparkSession, fsRelation.options, file.getPath)) &#123;</span><br><span class="line">          (0L until file.getLen by maxSplitBytes).map &#123; offset &#x3D;&gt;</span><br><span class="line">            val remaining &#x3D; file.getLen - offset</span><br><span class="line">            &#x2F;&#x2F; 文件尾部不足则剩余作为一个逻辑上的文件</span><br><span class="line">            val size &#x3D; if (remaining &gt; maxSplitBytes) maxSplitBytes else remaining</span><br><span class="line">            val hosts &#x3D; getBlockHosts(blockLocations, offset, size)</span><br><span class="line">            PartitionedFile(</span><br><span class="line">              partition.values, file.getPath.toUri.toString, offset, size, hosts)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          val hosts &#x3D; getBlockHosts(blockLocations, 0, file.getLen)</span><br><span class="line">          Seq(PartitionedFile(</span><br><span class="line">            partition.values, file.getPath.toUri.toString, 0, file.getLen, hosts))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.toArray.sortBy(_.length)(implicitly[Ordering[Long]].reverse)</span><br><span class="line"> 	</span><br><span class="line">    &#x2F;&#x2F; splitFiles 对大文件切分有效,但是如果小文件较多的话,则会产生与文件数相同的逻辑文件</span><br><span class="line">    &#x2F;&#x2F; 需要将逻辑文件合并为逻辑分区,每个逻辑分区对于一个 spark task  </span><br><span class="line">    </span><br><span class="line">    val partitions &#x3D; new ArrayBuffer[FilePartition]</span><br><span class="line">    val currentFiles &#x3D; new ArrayBuffer[PartitionedFile]</span><br><span class="line">    var currentSize &#x3D; 0L</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 截断并新建一个逻辑分区</span><br><span class="line">   def closePartition(): Unit &#x3D; &#123;</span><br><span class="line">      if (currentFiles.nonEmpty) &#123;</span><br><span class="line">        val newPartition &#x3D;</span><br><span class="line">          FilePartition(</span><br><span class="line">            partitions.size,</span><br><span class="line">            currentFiles.toArray.toSeq) </span><br><span class="line">        partitions +&#x3D; newPartition</span><br><span class="line">      &#125;</span><br><span class="line">      currentFiles.clear()</span><br><span class="line">      currentSize &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    splitFiles.foreach &#123; file &#x3D;&gt;</span><br><span class="line">      &#x2F;&#x2F; 如果已有数据量加上当前逻辑文件的长度超过了 期望分区大小,则不添加当前文件 截断为一个新的逻辑分区</span><br><span class="line">      if (currentSize + file.length &gt; maxSplitBytes) &#123;</span><br><span class="line">        closePartition()</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      currentSize +&#x3D; file.length + openCostInBytes</span><br><span class="line">      currentFiles +&#x3D; file</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 余量作为一个新的逻辑分区</span><br><span class="line">    closePartition()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建 RDD,分区为所有的逻辑分区,readFile为文件读取逻辑 </span><br><span class="line">    new FileScanRDD(fsRelation.sparkSession, readFile, partitions)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>[CoarseGrainedSchedulerBackend.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override def defaultParallelism(): Int &#x3D; &#123;</span><br><span class="line">    conf.getInt(&quot;spark.default.parallelism&quot;, math.max(totalCoreCount.get(), 2))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>综上:<br>val maxSplitBytes = Math.min(defaultMaxSplitBytes, Math.max(openCostInBytes, bytesPerCore))<br>即分区大小的逻辑取决于三个值:<br>defaultMaxSplitBytes: 单分区最大数据量,默认128MB<br>openCostInBytes: 单分区最小数据量,默认 4MB<br>bytesPerCore: 平均每 core 处理数据量, totalBytes/defaultParallelism<br>defaultParallelism: 取值为配置项 spark.default.parallelism (默认未配置),然后是 totalCoreCount 与 2 的较大者<br>totalCoreCount: 随 executor 的注册/注销动态变化(变化量为 spark.executor.cores),开启动态资源管理的情况下难以预估。<br>即在单分区数据量不低于 4MB,不高于 128MB 的情况下,所有数据均衡给所有并发数处理   </p>
<h2 id="修改分区数"><a href="#修改分区数" class="headerlink" title="修改分区数"></a>修改分区数</h2><p>defaultMaxSplitBytes 决定了上限，openCostInBytes决定了下限  </p>
<ol>
<li>减小分区数<br>提高下限 openCostInBytes 值，并注意上限 defaultMaxSplitBytes即可  </li>
<li>增加分区数<br>配置合理的 spark.default.parallelism 值, 并注意下限 openCostInBytes 值即可  </li>
</ol>
<p>注: 高压缩率 ORC 文件 4MB 解压后有 4G 左右的大小，可能需要降低下限    </p>
]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
        <tag>源码解析</tag>
        <tag>Spark SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkSQL源码解析(3):从 ResolvedLogicPlan 到 OptimizedLogicPlan</title>
    <url>/2019-12-10-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(3):%E4%BB%8E%20ResolvedLogicPlan%20%E5%88%B0%20OptimizedLogicPlan/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Parser 模块负责将 SQL 文本解析为 UnResolvedLogicPlan，Analyzer 模块负责将 UnResolvedLogicPlan 绑定解析为 ResolvedLogicPlan。Rule-Based Optimizer，简称 RBO 或 Optimizer 模块负责基于规则优化逻辑计划，主要思路是基于各类型规则对 ResolvedLogicPlan 进行优化达到减少每个逻辑计划树节点输入数据量或计算代价的目的，大名鼎鼎的列裁剪和谓词下推、常量折叠就是出自于 Optimizer 模块。      </p>
<a id="more"></a>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>[QueryExecution.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一步: 使用 CacheManager 替换逻辑计划为已解析过的逻辑计划</span><br><span class="line">lazy val withCachedData: LogicalPlan &#x3D; &#123;</span><br><span class="line">    assertAnalyzed()</span><br><span class="line">    assertSupported()</span><br><span class="line">    sparkSession.sharedState.cacheManager.useCachedData(analyzed)</span><br><span class="line">  &#125;</span><br><span class="line"> &#x2F;&#x2F; 第二步: 基于规则优化逻辑计划树</span><br><span class="line">  lazy val optimizedPlan: LogicalPlan &#x3D; sparkSession.sessionState.optimizer.execute(withCachedData)</span><br></pre></td></tr></table></figure>

<h3 id="CacheManager"><a href="#CacheManager" class="headerlink" title="CacheManager"></a>CacheManager</h3><p>[CacheManager.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val cachedData &#x3D; new java.util.LinkedList[CachedData]</span><br><span class="line"></span><br><span class="line">def useCachedData(plan: LogicalPlan): LogicalPlan &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 先序遍历</span><br><span class="line">    val newPlan &#x3D; plan transformDown &#123;</span><br><span class="line">      case hint: ResolvedHint &#x3D;&gt; hint</span><br><span class="line">      case currentFragment &#x3D;&gt;</span><br><span class="line">        &#x2F;&#x2F; 检索 CacheManager</span><br><span class="line">        lookupCachedData(currentFragment)</span><br><span class="line">           &#x2F;&#x2F; 使用当前计划的输出字段替换原有的</span><br><span class="line">          .map(_.cachedRepresentation.withOutput(currentFragment.output))</span><br><span class="line">          .getOrElse(currentFragment)</span><br><span class="line">    &#125;</span><br><span class="line">    newPlan transformAllExpressions &#123;</span><br><span class="line">      &#x2F;&#x2F; 剥去子查询别名外壳</span><br><span class="line">      case s: SubqueryExpression &#x3D;&gt; s.withNewPlan(useCachedData(s.plan))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> def lookupCachedData(plan: LogicalPlan): Option[CachedData] &#x3D; readLock &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历对比CacheManager 中是否存在和当前计划一致的  </span><br><span class="line">    cachedData.asScala.find(cd &#x3D;&gt; plan.sameResult(cd.plan))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常判断两个查询计划是否相同是很复杂的问题，因此可能实际相同也可以返回 false，但是实际不同一定不能返回 true。这种行为不会影响正确性，仅仅相当于弃用了 CacheManager，多做了一些重复处理而已。这种思想有点像 BloomFilter 的误判率: 函数判断在集合但是实际上可能不在，仅仅是多个 hash 函数得到的位置在 bitmap 中恰好非 0；返回不在集合时一定不在。<br>[QueryPlan.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将逻辑计划规范化之后再做比较</span><br><span class="line">final def sameResult(other: PlanType): Boolean &#x3D; this.canonicalized &#x3D;&#x3D; other.canonicalized</span><br><span class="line">&#x2F;&#x2F; 规范化 逻辑计划涉及的所有字段的 id(从 0 递增)。</span><br><span class="line">protected def doCanonicalize(): PlanType &#x3D; &#123;</span><br><span class="line">    val canonicalizedChildren &#x3D; children.map(_.canonicalized)</span><br><span class="line">    var id &#x3D; -1</span><br><span class="line">    mapExpressions &#123;</span><br><span class="line">      case a: Alias &#x3D;&gt;</span><br><span class="line">        id +&#x3D; 1</span><br><span class="line">        val normalizedChild &#x3D; QueryPlan.normalizeExprId(a.child, allAttributes)</span><br><span class="line">        Alias(normalizedChild, &quot;&quot;)(ExprId(id), a.qualifier)</span><br><span class="line"></span><br><span class="line">      case ar: AttributeReference if allAttributes.indexOf(ar.exprId) &#x3D;&#x3D; -1 &#x3D;&gt;</span><br><span class="line">        id +&#x3D; 1</span><br><span class="line">        ar.withExprId(ExprId(id)).canonicalized</span><br><span class="line"></span><br><span class="line">      case other &#x3D;&gt; QueryPlan.normalizeExprId(other, allAttributes)</span><br><span class="line">    &#125;.withNewChildren(canonicalizedChildren)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>有必要提一下 InMemoryRelation 这个类，这是 CacheManager 缓存已被 RBO 优化过的内存数据结构，包括：逻辑计划的输出字段，是否压缩(spark.sql.inMemoryColumnarStorage.compressed，默认 true，SparkSQL 将根据元数据信息自动匹配编码器)，批处理大小(spark.sql.inMemoryColumnarStorage.batchSize，默认 10000，控制列式存储的批处理大小，较大的值能提高内存利用率和压缩率 但是读数据时可能会 OOM)，存储等级(默认 MEMORY_AND_DISK)，RBO 优化完成的物理计划 SparkPlan，表名，对应 RDD[CachedBatch]，物理数据字节数，额外有一个<b> statsOfPlanToCache 暂时不知用途</b><br>[InMemoryRelation.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case class InMemoryRelation(</span><br><span class="line">    output: Seq[Attribute],</span><br><span class="line">    useCompression: Boolean,</span><br><span class="line">    batchSize: Int,</span><br><span class="line">    storageLevel: StorageLevel,</span><br><span class="line">    @transient child: SparkPlan,</span><br><span class="line">    tableName: Option[String])(</span><br><span class="line">    @transient var _cachedColumnBuffers: RDD[CachedBatch] &#x3D; null,</span><br><span class="line">    val sizeInBytesStats: LongAccumulator &#x3D; child.sqlContext.sparkContext.longAccumulator,</span><br><span class="line">    statsOfPlanToCache: Statistics)</span><br><span class="line">  extends logical.LeafNode with MultiInstanceRelation</span><br></pre></td></tr></table></figure>
<p>CachedBatch 用以表明 batch 中数据行数，序列化的列数据 buffer，数据的元数据类型。<br>[CachedBatch.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case class CachedBatch(numRows: Int, buffers: Array[Array[Byte]], stats: InternalRow)</span><br></pre></td></tr></table></figure>

<h3 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h3><p>SessionState 初始化时指定的 Optimizer 为 SparkOptimizer，SparkOptimizer 继承自 Optimizer，Optimizer 与 Analyzer 均继承自 RuleExecutor，都使用RuleExecutor#execute 方法遍历逻辑计划树应用 Optimizer/Analyzer 各自指定的规则库和执行策略 优化每个逻辑计划。故不再引用 RuleExecutor#execute 方法。<br>[BaseSessionStateBuilder.scala]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected def optimizer: Optimizer &#x3D; &#123;</span><br><span class="line">    new SparkOptimizer(catalog, experimentalMethods) &#123;</span><br><span class="line">      override def extendedOperatorOptimizationRules: Seq[Rule[LogicalPlan]] &#x3D;</span><br><span class="line">        super.extendedOperatorOptimizationRules ++ customOperatorOptimizationRules</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>除了类似于前后拦截器功能的 preOptimizationBatches、postHocOptimizationBatches 和拓展规则之外，SparkOptimizer 主要引用了 Optimizer 定义的通用规则，还有 4 个自定义规则:  </p>
<ol>
<li>OptimizeMetadataOnlyQuery，优化那些只遍历表分区键级别的元数据就可以完成的逻辑计划   　<ul>
<li>在分区键上做聚合。e.g. SELECT col FROM tbl GROUP by col;   </li>
<li>在分区键上去重并使用聚合函数。e.g. SELECT col1,count(DISTINCT col2) FROM tbl GROUP BY col1;   </li>
<li>在分区键上应用有去重功能的聚合函数。e.g. SELECT col1, Max(col2) FROM tbl GROUP BY col1;   </li>
</ul>
</li>
<li>ExtractPythonUDFFromAggregate，提取聚合操作中所有 PythonUDF。十分不推荐使用 pyspark   </li>
<li>PruneFileSourcePartitions，物理文件分区下推。 读取 hadoop 目录时尽可能将过滤条件下推到分区键上，避免扫描所有文件。   </li>
<li>PushDownOperatorsToDataSource  过滤操作下推到数据源，以提高性能。  </li>
</ol>
<p>[SparkOptimizer.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override def batches: Seq[Batch] &#x3D; (preOptimizationBatches ++ super.batches :+</span><br><span class="line">    Batch(&quot;Optimize Metadata Only Query&quot;, Once, OptimizeMetadataOnlyQuery(catalog)) :+</span><br><span class="line">    Batch(&quot;Extract Python UDF from Aggregate&quot;, Once, ExtractPythonUDFFromAggregate) :+</span><br><span class="line">    Batch(&quot;Prune File Source Table Partitions&quot;, Once, PruneFileSourcePartitions) :+</span><br><span class="line">    Batch(&quot;Push down operators to data source scan&quot;, Once, PushDownOperatorsToDataSource)) ++</span><br><span class="line">    postHocOptimizationBatches :+</span><br><span class="line">    Batch(&quot;User Provided Optimizers&quot;, fixedPoint, experimentalMethods.extraOptimizations: _*)</span><br></pre></td></tr></table></figure>
<p>[Optimizer.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def batches: Seq[Batch] &#x3D; &#123;</span><br><span class="line">    val operatorOptimizationRuleSet &#x3D;</span><br><span class="line">      Seq(</span><br><span class="line">        &#x2F;&#x2F; Operator push down</span><br><span class="line">        PushProjectionThroughUnion,</span><br><span class="line">        ReorderJoin,</span><br><span class="line">        EliminateOuterJoin,</span><br><span class="line">        PushPredicateThroughJoin,</span><br><span class="line">        PushDownPredicate,</span><br><span class="line">        LimitPushDown,</span><br><span class="line">        ColumnPruning,</span><br><span class="line">        InferFiltersFromConstraints,</span><br><span class="line">        &#x2F;&#x2F; Operator combine</span><br><span class="line">        CollapseRepartition,</span><br><span class="line">        CollapseProject,</span><br><span class="line">        CollapseWindow,</span><br><span class="line">        CombineFilters,</span><br><span class="line">        CombineLimits,</span><br><span class="line">        CombineUnions,</span><br><span class="line">        &#x2F;&#x2F; Constant folding and strength reduction</span><br><span class="line">        NullPropagation,</span><br><span class="line">        ConstantPropagation,</span><br><span class="line">        FoldablePropagation,</span><br><span class="line">        OptimizeIn,</span><br><span class="line">        ConstantFolding,</span><br><span class="line">        ReorderAssociativeOperator,</span><br><span class="line">        LikeSimplification,</span><br><span class="line">        BooleanSimplification,</span><br><span class="line">        SimplifyConditionals,</span><br><span class="line">        RemoveDispensableExpressions,</span><br><span class="line">        SimplifyBinaryComparison,</span><br><span class="line">        PruneFilters,</span><br><span class="line">        EliminateSorts,</span><br><span class="line">        SimplifyCasts,</span><br><span class="line">        SimplifyCaseConversionExpressions,</span><br><span class="line">        RewriteCorrelatedScalarSubquery,</span><br><span class="line">        EliminateSerialization,</span><br><span class="line">        RemoveRedundantAliases,</span><br><span class="line">        RemoveRedundantProject,</span><br><span class="line">        SimplifyCreateStructOps,</span><br><span class="line">        SimplifyCreateArrayOps,</span><br><span class="line">        SimplifyCreateMapOps,</span><br><span class="line">        CombineConcats) ++</span><br><span class="line">        extendedOperatorOptimizationRules</span><br><span class="line"></span><br><span class="line">    val operatorOptimizationBatch: Seq[Batch] &#x3D; &#123;</span><br><span class="line">      val rulesWithoutInferFiltersFromConstraints &#x3D;</span><br><span class="line">        operatorOptimizationRuleSet.filterNot(_ &#x3D;&#x3D; InferFiltersFromConstraints)</span><br><span class="line">      Batch(&quot;Operator Optimization before Inferring Filters&quot;, fixedPoint,</span><br><span class="line">        rulesWithoutInferFiltersFromConstraints: _*) ::</span><br><span class="line">      Batch(&quot;Infer Filters&quot;, Once,</span><br><span class="line">        InferFiltersFromConstraints) ::</span><br><span class="line">      Batch(&quot;Operator Optimization after Inferring Filters&quot;, fixedPoint,</span><br><span class="line">        rulesWithoutInferFiltersFromConstraints: _*) :: Nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (Batch(&quot;Eliminate Distinct&quot;, Once, EliminateDistinct) ::</span><br><span class="line">    &#x2F;&#x2F; 译: 从技术上将，”Finish Analysis“中的部分规则不是 optimizer rule 而是 analyzer rule，因为它们是保证正确性必须的。</span><br><span class="line">    &#x2F;&#x2F; 但是 因为我们使用 analyzer 来规范化查询(视图定义)，我们在 analyzer 中不去除子查询或计算当前时间</span><br><span class="line">    Batch(&quot;Finish Analysis&quot;, Once,</span><br><span class="line">      EliminateSubqueryAliases,</span><br><span class="line">      EliminateView,</span><br><span class="line">      ReplaceExpressions,</span><br><span class="line">      ComputeCurrentTime,</span><br><span class="line">      GetCurrentDatabase(sessionCatalog),</span><br><span class="line">      RewriteDistinctAggregates,</span><br><span class="line">      ReplaceDeduplicateWithAggregate) ::</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; Optimizer rules start here</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">      &#x2F;&#x2F; 译: 在应用主要的优化规则之前先调用 CombineUnions,因为可以减少迭代次数，而其他规则可以在两个相邻的 Union操作符之间添加&#x2F;移动额外的操作符</span><br><span class="line">      &#x2F;&#x2F; 在规则库&quot;Operator Optimizations&quot;中再次调用 CombineUnions,是因为其他操作符可能会导致两个单独的 Union 变得相邻。</span><br><span class="line">    Batch(&quot;Union&quot;, Once,</span><br><span class="line">      CombineUnions) ::</span><br><span class="line">    Batch(&quot;Pullup Correlated Expressions&quot;, Once,</span><br><span class="line">      PullupCorrelatedPredicates) ::</span><br><span class="line">    Batch(&quot;Subquery&quot;, Once,</span><br><span class="line">      OptimizeSubqueries) ::</span><br><span class="line">    Batch(&quot;Replace Operators&quot;, fixedPoint,</span><br><span class="line">      ReplaceIntersectWithSemiJoin,</span><br><span class="line">      ReplaceExceptWithFilter,</span><br><span class="line">      ReplaceExceptWithAntiJoin,</span><br><span class="line">      ReplaceDistinctWithAggregate) ::</span><br><span class="line">    Batch(&quot;Aggregate&quot;, fixedPoint,</span><br><span class="line">      RemoveLiteralFromGroupExpressions,</span><br><span class="line">      RemoveRepetitionFromGroupExpressions) :: Nil ++</span><br><span class="line">    operatorOptimizationBatch) :+</span><br><span class="line">    Batch(&quot;Join Reorder&quot;, Once,</span><br><span class="line">      CostBasedJoinReorder) :+</span><br><span class="line">    Batch(&quot;Decimal Optimizations&quot;, fixedPoint,</span><br><span class="line">      DecimalAggregates) :+</span><br><span class="line">    Batch(&quot;Object Expressions Optimization&quot;, fixedPoint,</span><br><span class="line">      EliminateMapObjects,</span><br><span class="line">      CombineTypedFilters) :+</span><br><span class="line">    Batch(&quot;LocalRelation&quot;, fixedPoint,</span><br><span class="line">      ConvertToLocalRelation,</span><br><span class="line">      PropagateEmptyRelation) :+</span><br><span class="line">    &#x2F;&#x2F; The following batch should be executed after batch &quot;Join Reorder&quot; and &quot;LocalRelation&quot;.</span><br><span class="line">    Batch(&quot;Check Cartesian Products&quot;, Once,</span><br><span class="line">      CheckCartesianProducts) :+</span><br><span class="line">    Batch(&quot;RewriteSubquery&quot;, Once,</span><br><span class="line">      RewritePredicateSubquery,</span><br><span class="line">      ColumnPruning,</span><br><span class="line">      CollapseProject,</span><br><span class="line">      RemoveRedundantProject)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>按规则(库)应用的顺序串行列出(下述规则均在 SparkOptimizer中规则之前)，<b>欢迎指出错误</b>       </p>
<table>
<thead>
<tr>
<th align="left">规则库名</th>
<th align="left">规则类名</th>
<th align="left">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Eliminate Distinct</td>
<td align="left">EliminateDistinct</td>
<td align="left">去除 MAX/MIN 函数内的 DISTINCT</td>
<td align="left">SELECT MAX(DISTINCT(age)) FROM a</td>
</tr>
<tr>
<td align="left">Finish Analysis</td>
<td align="left">EliminateSubqueryAliases</td>
<td align="left">去除子查询别名,子查询仅仅提供查询属性集的作用,analyzer 阶段结束后便可去除子查询别名</td>
<td align="left">Finish Analysis 规则不在 analyzer 中删除的意义是保存原始的 analyzed logic plan</td>
</tr>
<tr>
<td align="left">Finish Analysis</td>
<td align="left">EliminateView</td>
<td align="left">去除视图操作符</td>
<td align="left">视图的输出属性集必须和子查询输出属性集完全一致</td>
</tr>
<tr>
<td align="left">Finish Analysis</td>
<td align="left">ReplaceExpressions</td>
<td align="left">将RuntimeReplaceable 表达式替换为可执行表达式</td>
<td align="left">一般用来兼容各类数据库，例如用 coalesce 替换 nvl 函数</td>
</tr>
<tr>
<td align="left">Finish Analysis</td>
<td align="left">ComputeCurrentTime</td>
<td align="left">记录当前时间,SQL 中任意位置和执行顺序的操作时间(date,timestamp)都会返回一致的结果</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Finish Analysis</td>
<td align="left">GetCurrentDatabase</td>
<td align="left">使用 SessionCatalog 的数据库作为当前数据库返回</td>
<td align="left">CurrentDataBase 函数没必要在执行阶段一条条计算,在 RBO 阶段获取完作为常量替换了函数表达式</td>
</tr>
<tr>
<td align="left">Finish Analysis</td>
<td align="left">RewriteDistinctAggregates</td>
<td align="left">重写 count(distinct xx),展开数据通过一次聚合即可算出结果</td>
<td align="left">SELECT count(distinct name) as name_cnt, count(distinct(age)) as age_cnt,sum(age) as age_sum FROM p GROUP BY year=&gt; 将数据展开成[[year,null,null,type0,ageVal],[year,name,null,type1,null],[year,null,age,type2,ageVal]]],group by (year,name,age,type,age),sum(if(type1,ageVal,0));sum(if(type2,1,0));sum(if(type3,1,0))…</td>
</tr>
<tr>
<td align="left">Finish Analysis</td>
<td align="left">ReplaceDeduplicateWithAggregate</td>
<td align="left">替换 Deduplicate 操作为 Aggregate</td>
<td align="left">没找到 Deduplicate 对应的语法,FIX ME</td>
</tr>
<tr>
<td align="left">Union</td>
<td align="left">CombineUnions</td>
<td align="left">将有父子关系的 union all 汇集叶子节点一层</td>
<td align="left">SELECT * FROM(SELECT * FROM a UNION ALL SELECT * FROM b) UNION ALL SELECT * FROM c =&gt; SELECT * FROM (a,b,c)</td>
</tr>
<tr>
<td align="left">Pullup Correlated Expressions</td>
<td align="left">PullupCorrelatedPredicates</td>
<td align="left">?</td>
<td align="left">?</td>
</tr>
<tr>
<td align="left">Subquery</td>
<td align="left">OptimizeSubqueries</td>
<td align="left">RBO 优化子查询</td>
<td align="left">子查询的父阶段为 SubQueryExpression,当解析到 SubQueryExpression 时,使用 RBO 优化子查询逻辑计划</td>
</tr>
<tr>
<td align="left">Replace Operators</td>
<td align="left">ReplaceIntersectWithSemiJoin</td>
<td align="left">将 intersect 操作符转化为 left semi join 后再 distinct</td>
<td align="left">left semi join 保留在右表中能关联到的左表选取列.SELECT name,age FROM a INTERSECT SELECT name,age FROM b =&gt; SELECT  DISTINCT name,age FROM a LEFT SEMI JOIN b ON a.name=b.name AND a.age=b.age</td>
</tr>
<tr>
<td align="left">Replace Operators</td>
<td align="left">ReplaceExceptWithFilter</td>
<td align="left">将两个相同查询计划的子句 except操作符转为 Filter 后 Distinct</td>
<td align="left">SELECT a1,a2 FROM t WHERE a2=12 EXCEPT SELECT a1,a2 FROM t WHERE a1=5  =&gt;SELECT DISTINCT a1,a2 FROM t WHERE a2=12 AND NOT(a1=5)。需要相同查询计划子句才能执行此转换</td>
</tr>
<tr>
<td align="left">Replace Operators</td>
<td align="left">ReplaceExceptWithAntiJoin</td>
<td align="left">不同查询计划的子句 except 操作符转为 left anti join 操作后 DISTINCT</td>
<td align="left">SELECT a1,a2 FROM t1 EXCEPT SELECT b1,b2 FROM t2 =&gt; SELECT DISTINCT a1,a2 FROM t1 LEFT ANTI JOIN t2 ON t1.a1=t2.b1 AND t1.a2=t2.b2</td>
</tr>
<tr>
<td align="left">Replace Operators</td>
<td align="left">ReplaceDistinctWithAggregate</td>
<td align="left">将 distinct 操作符转为 group by</td>
<td align="left">SELECT DISTINCT a,b FROM t =&gt; SELECT a,b FROM t GROUP BY a,b</td>
</tr>
<tr>
<td align="left">Aggregate</td>
<td align="left">RemoveLiteralFromGroupExpressions</td>
<td align="left">去除 group by 条件中的常量和可折叠常量表达式,不影响聚合结果但会减少 key 数据量</td>
<td align="left">SELECT a,b FROM t GROUP BY a,b,1,1&lt;0 =&gt;SELECT a,b FROM t GROUP BY a,b</td>
</tr>
<tr>
<td align="left">Aggregate</td>
<td align="left">RemoveRepetitionFromGroupExpressions</td>
<td align="left">去除 group by 条件中的重复表达式,不影响聚合结果但会减少 key 数据量</td>
<td align="left">SELECT a,b FROM t GROUP BY a,b,b =&gt;</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">PushProjectionThroughUnion</td>
<td align="left">将查询列下推到各 union all 子句</td>
<td align="left">SELECT a FROM (SELECT a,b FROM t1 UNION ALL SELECT c,d FROM t2) tbl_a =&gt; SELECT a FROM (SELECT a FROM t1 UNION ALL SELECT c FROM t2) tbl_a</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">ReorderJoin</td>
<td align="left">按照逻辑计划数据行数启发式寻找星型模型的事实表和维度表,事实表在左以避免大表加载到内存,并以此重定义连接顺序</td>
<td align="left">取决于spark.sql.cbo.starSchemaDetection 和 spark.sql.cbo.enabled,默认不开启。SELECT * FROM a,b,c where a.key=b.key and a.val=c.val =&gt; SELECT * FROM a join c on a.val=c.val join b on a.key=b.key , 大表居左小表居右</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">EliminateOuterJoin</td>
<td align="left">尽可能转换 full join=&gt;right/left join=&gt;inner join</td>
<td align="left">如果存在谓词可以削减 null-supplying 行(当输入数据为 null 时,谓词返回值为 null 或 false),则可以削弱 outer join. full join 可以转为 left/right/inner join,left/join join 可以转为 inner join. SELECT * FROM a left join b on a.key=b.key WHERE b.key IS NOT NULL =&gt;SELECT * FROM a inner join b on a.key=b.key</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">PushPredicateThroughJoin</td>
<td align="left">join 谓词下推</td>
<td align="left">包含两层含义: where 条件下推到 join 条件,join 条件下推到子查询</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">PushDownPredicate</td>
<td align="left">对于确定性的操作和谓词且谓词不能改变行的逻辑计划,尽可能下推谓词以减少输入数据量</td>
<td align="left">对于支持类似 BloomFilter 的列式存储,有极大提升</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">LimitPushDown</td>
<td align="left">旨在减少输入数据量。1. union all 上级和下级 limit 数值不同则下级取 min 2.left join 上级和下级 limit 数值不同则下级左侧limit 取 min;right join 同理</td>
<td align="left">SELECT * FROM (SELECT * FORM a limit 20 UNION ALL SELECT * FORM b limit 15) temp LIMIT 10 或者 SELECT * FROM (SELECT * FROM a LEFT JOIN b ON a.key=b.key) temp LIMIT 10</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">ColumnPruning</td>
<td align="left">列裁剪</td>
<td align="left">去掉在查询/聚合/窗口函数/union 等用不到的列读取</td>
</tr>
<tr>
<td align="left">Operator push down</td>
<td align="left">InferFiltersFromConstraints</td>
<td align="left">在子查询后或者关联后的约束条件中删掉子查询内或者关联子节点内已有的约束条件</td>
<td align="left">在当前规则库会被过滤掉,在 Infer Filters 规则库执行</td>
</tr>
<tr>
<td align="left">Operator combine</td>
<td align="left">CollapseRepartition</td>
<td align="left">折叠有父子关系的再分区操作</td>
<td align="left">当父节点和子节点均为再分区操作,但父节点无 shuffle(coalesce api)子节点有 shuffle 且父节点再分区数大于子节点再分区数则删除父节点,若再分区数不大于子节点则不改变结构。若 shuffle 关系不为(false,true)及其他情况则折叠子节点 RepartitionOperation</td>
</tr>
<tr>
<td align="left">Operator combine</td>
<td align="left">CollapseProject</td>
<td align="left">折叠有父子关系的父节点 Projection 操作</td>
<td align="left">SELECT age FROM (SELECT name,age+1 as age FROM p) temp=&gt;SELECT age+1 as age FROM p</td>
</tr>
<tr>
<td align="left">Operator combine</td>
<td align="left">CollapseWindow</td>
<td align="left">折叠分区字段一致、排序方式一致且表达式相互独立、有父子关系的子节点 Window 操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Operator combine</td>
<td align="left">CombineFilters</td>
<td align="left">折叠有父子关系的父节点 Filter 操作</td>
<td align="left">SELECT name,age FROM (SELECT name,age FROM p where name is not null)temp where age&gt;10 =&gt;SELECT name,age FROM p WHERE name is not null AND age&gt;10</td>
</tr>
<tr>
<td align="left">Operator combine</td>
<td align="left">CombineLimits</td>
<td align="left">折叠有父子关系的父节点 Limit 操作,limit 数值取 minimum</td>
<td align="left">Limit 分为 GlobalLimit,LocalLimit 两类,GlobalLimit 需要shuffle,LocalLimit 不需要。GlobalLimit(Union(A,B))可以转化为 GlobalLimit(Union(LocalLimit(A),LocalLimit(B)))来降低 shuffle 数据量</td>
</tr>
<tr>
<td align="left">Operator combine</td>
<td align="left">CombineUnions</td>
<td align="left">重复规则,同 Union规则库的 CombineUnion 规则</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">NullPropagation</td>
<td align="left">null 值替换</td>
<td align="left">将表达式中可评估的 null 值替换为等效常量,count(name)=&gt;count(1)</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">ConstantPropagation</td>
<td align="left">Filter 操作中常量替换</td>
<td align="left">SELECT * FROM p WHERE age=10 and age2=age+3 =&gt; SELECT * FROM p WHERE age=10 AND age2=13</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">FoldablePropagation</td>
<td align="left">可折叠表达式替换</td>
<td align="left">尽可能将属性替换为原始可折叠表达式,其他优化规则将利用可折叠表达式进行优化。SELECT 1.0 as x,’abc’ as y,now() as z order by x,y,z =&gt; SELECT 1.0 as x,’abc’ as y,now() as z ORDER BY 1.0,’abc’,now(); 这样其他规则可以去掉 order by 操作符</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">OptimizeIn</td>
<td align="left">IN 优化</td>
<td align="left">尽可能优化 IN 谓词: 1.当 in 列表为空且指定列不可为空时直接返回 false 2.当 in 列表元素数量超过配置(默认 10),将列表转为 HashSet 以去重和使用哈希索引提高性能。In(value,seq[Literal])=&gt;InSet(value,HashSet[Literal])</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">ConstantFolding</td>
<td align="left">常量折叠</td>
<td align="left">将可静态计算的表达式替换为等效常量.SELECT 1+2 as a FROM p=&gt;SELECT 3 FROM p</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">ReorderAssociativeOperator</td>
<td align="left">重排序所有整数类型运算符,将所有确定性整数折叠计算为一个结果</td>
<td align="left">和 ConstantFolding 折叠不同，ConstantFolding 要在整个表达式都静态可计算(确定性)时才会应用。ReorderAssociativeOperator 这里尽管有不确定性部分，但会尽可能将确定性部分计算出来。SELECT (age+1)+2 as a FROM p =&gt;SELECT age+3 as a FROM p</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">LikeSimplification</td>
<td align="left">正则匹配简化</td>
<td align="left">尽可能将 rlike正则匹配简化为字符串startWith,endWith,equal,container 等操作</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">BooleanSimplification</td>
<td align="left">布尔表达式简化</td>
<td align="left">尽可能简化 boolean 表达式/快速中断/删除不必要的 not 。false AND e=&gt;false,true AND e=&gt;e,a AND b=&gt;Not(a).semanticEquals(b) =&gt; false,Not(Not(a))=&gt;a</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">SimplifyConditionals</td>
<td align="left">条件表达式简化(if(condition,trueVal,falseVal),case when)</td>
<td align="left">如果 if表达式 恒定true或 false 则修改逻辑计划为相应的 val;如果 case when 表达式中有恒 false 值则删除其分支，若所有分支恒 false 则取 else 语句值；若 case when 第一个表达式恒 true，则取其值；恒 true 分支会删除其后续所有分支</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">RemoveDispensableExpressions</td>
<td align="left">删除 UnaryPositive 节点(仅有标识子节点表达式作用)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">SimplifyBinaryComparison</td>
<td align="left">简化比较</td>
<td align="left">1.将&lt;=&gt;替换为 true;2.将=和&lt;=和&gt;= 在两侧均非空且逻辑计划结果一致时替换为 true;3. 将&gt;和&lt;在两侧均非空且逻辑计划结果一致时替换为 false。age&lt;AGE  =&gt;false</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">PruneFilters</td>
<td align="left">约束条件简化</td>
<td align="left">1. 当约束条件恒 true 时,删除父节点;2.当约束条件恒 false 或 null 时,替换父节点的输入为空集;3.在父节点约束条件中去除子节点已有的约束条件</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">EliminateSorts</td>
<td align="left">删除无效的排序</td>
<td align="left">删除排序中确定性的排序方式,甚至不排序.SELECT name,age FROM p ORDER BY 1 ASC, age DESC</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">SimplifyCasts</td>
<td align="left">强制类型转换简化</td>
<td align="left">当强制转化的类型相同(仅限于 基础数据类型相同 或 Array 内嵌数据类型相同 或 Map 内嵌 key 和 value 类型均相同)时,去除 Cast (col to type) 操作</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">SimplifyCaseConversionExpressions</td>
<td align="left">简化大小写转换表达式</td>
<td align="left">内部转换会被外部转换覆盖 Upper(Lower(x))=&gt;Upper(x),Lower(Lower(x))=&gt;Lower(x)</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">RewriteCorrelatedScalarSubquery</td>
<td align="left">？？</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">EliminateSerialization</td>
<td align="left">删除不必要的在 object 和 InternalRow 之间的(循环)序列化/反序列化操作</td>
<td align="left">1.反序列化为父节点,序列化为子节点且操作字段相同;2.将数据反序列化并追加数据到末尾时AppendColumns可替换AppendColumnsWithObject操作符 直接操作序列化后的数据(类似于 UnsafeSortShuffle) 3. TypedFilter为父节点,序列化为子节点时 4.反序列化为父节点,TypedFilter 为子节点时</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">RemoveRedundantAliases</td>
<td align="left">删除无效别名</td>
<td align="left">无效别名是指在子查询或者关联中不改变列名/列元数据的别名</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">RemoveRedundantProject</td>
<td align="left">删除无效查询</td>
<td align="left">无效查询是指父查询和子查询目标字段相同</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">SimplifyCreateStructOps</td>
<td align="left">结构体创建简化</td>
<td align="left">named_struct(‘name’,name,’age’,age).age=&gt;age</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">SimplifyCreateArrayOps</td>
<td align="left">数组创建简化</td>
<td align="left">1.当对创建的数组按下标取值时,减少创建数组的数据量.Array(elem0,elem1…)(1)=&gt;elems(1);2.Array(named_stuct(name,”nA”),named_struct(age,12))[0].name=&gt;named_struct(name,”nA”).name</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">SimplifyCreateMapOps</td>
<td align="left">映射创建简化</td>
<td align="left">map(key1-&gt;val2,key2-&gt;val2).key2 =&gt; case when key2</td>
</tr>
<tr>
<td align="left">Constant folding and strength reduction</td>
<td align="left">CombineConcats</td>
<td align="left">合并 concat</td>
<td align="left">将有父子关系的 concat 所有子节点扁平化 合并</td>
</tr>
<tr>
<td align="left">Infer Filters</td>
<td align="left">InferFiltersFromConstraints</td>
<td align="left">InferFiltersFromConstraints</td>
<td align="left">在子查询后或者关联后的约束条件中删掉子查询内或者关联子节点内已有的约束条件</td>
</tr>
<tr>
<td align="left">Join Reorder</td>
<td align="left">CostBasedJoinReorder</td>
<td align="left">？</td>
<td align="left">？</td>
</tr>
<tr>
<td align="left">Decimal Optimizations</td>
<td align="left">DecimalAggregates</td>
<td align="left">加速浮点数运算</td>
<td align="left">float 和 double 运算中一般需要控制精度(precision) 和小数位(scale)。窗口函数内聚合和普通聚合的 sum/avg 场景下将浮点计算转为长整形计算并在结束时转回来</td>
</tr>
<tr>
<td align="left">Object Expressions Optimization</td>
<td align="left">EliminateMapObjects</td>
<td align="left">简化 MapObject 操作</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Object Expressions Optimization</td>
<td align="left">CombineTypedFilters</td>
<td align="left">简化 TypedFilter</td>
<td align="left">去除具有父子关系的子节点 TypedFilter,合并两者的约束条件</td>
</tr>
<tr>
<td align="left">LocalRelation</td>
<td align="left">ConvertToLocalRelation</td>
<td align="left">简化为 LocalRelation</td>
<td align="left">在 LocalRelation 上取 Limit 时,直接转化为 LocalRelation 在数据上取 Limit 减少输入数据数量</td>
</tr>
<tr>
<td align="left">LocalRelation</td>
<td align="left">PropagateEmptyRelation</td>
<td align="left">空 Relation 优化</td>
<td align="left">对于上述优化规则(e.g. 列裁剪谓词下推)产生的或基础数据为空的 Relation 进行优化. 1,关联时按照左右空 Relation 和Join 类型分别讨论,左空 &amp;&amp; 左外连接=&gt;Empty 2.union all 所有子节点都空直接返回空数据集 3.一元节点的所有子节点都是空 Relation 则直接返回空数据集合, Select/Limit/Repartition 且 children 都为空 Relation=&gt;空数据集合</td>
</tr>
<tr>
<td align="left">Check Cartesian Products</td>
<td align="left">CheckCartesianProducts</td>
<td align="left">笛卡尔积检测</td>
<td align="left">检测逻辑计划树中是否有全外连接</td>
</tr>
<tr>
<td align="left">RewriteSubquery</td>
<td align="left">RewritePredicateSubquery</td>
<td align="left">重写谓词子查询</td>
<td align="left">将 in/exists 转为 semi join,将 not in / not exists 转为 anti join</td>
</tr>
<tr>
<td align="left">RewriteSubquery</td>
<td align="left">ColumnPruning</td>
<td align="left">列裁剪</td>
<td align="left">同 Aggregate规则库中的 ColumnPruning,去掉在查询/聚合/窗口函数/union 等用不到的列读取</td>
</tr>
<tr>
<td align="left">RewriteSubquery</td>
<td align="left">CollapseProject</td>
<td align="left">折叠有父子关系的父节点 Projection 操作</td>
<td align="left">同 Aggregate 规则库的 RewriteSubquery</td>
</tr>
<tr>
<td align="left">RewriteSubquery</td>
<td align="left">RemoveRedundantProject</td>
<td align="left">删除无效查询</td>
<td align="left">同 Aggregate 规则库的RemoveRedundantProject,无效查询是指父查询和子查询目标字段相同</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
        <tag>源码解析</tag>
        <tag>Spark SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkSQL源码解析(2):从 UnsolvedLogicPlan 到 ResolvedLogicPlan</title>
    <url>/2019-11-29-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(2):%E4%BB%8E%20UnresolvedLogicPlan%20%E5%88%B0%20ResolvedLogicPlan/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Parser 模块负责将原始 SQL 文本解析成 UnResolvedLogicPlan，Anayzer 模块负责将 UnResolvedLogicPlan(Relation|Attribute|Function) 通过 SessionCatalog 信息绑定到真正可操作的实体上(File|Column|MainClass)，即 SolvedLogicPlan，并校验其是否合法。   </p>
<a id="more"></a>

<p>则关键点在于:   </p>
<ol>
<li>SessionCatalog 存在目的        </li>
<li>如何绑定，将 UnresolvedLogicPlan 转换为 ResolvedLogicPlan    </li>
<li>如何校验 ResolvedLogicPlan 合法  </li>
</ol>
<p>1.Analyzer 对 UnresolvedLogicPlan应用各类规则(Rule),并对各个 UnresolvedLogicPlan节点绑定 CataLog 信息,将 UnresolvedLogicPlan中的UnresolvedRelation 和 UnresolvedAttribute解析成有类型(Typed)的对象,生成解析后的逻辑算子树 SolvedLogicPlan.<br>2.对 UnresolvedLogicPlan 的大部分操作,如绑定解析优化等,主要方法都是基于规则(Rule)的,然后通过模式匹配对UnresolvedLogicPlan进行相应处理.<br>3.Catalog信息在Analyzer的构造函数中.  </p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>调用栈<br>-&gt;SparkSession#sql<br>　-&gt;DataSet#ofRows<br>　　-&gt;QueryExecution#assertAnalyzed<br>　　　-&gt;QueryExecution#analyzed (lazy)<br>　　　　-&gt;Analyzer#executeAndCheck<br>[Anayzer.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def executeAndCheck(plan: LogicalPlan): LogicalPlan &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一步: 绑定</span><br><span class="line">    val analyzed &#x3D; execute(plan)</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 第二步: 校验</span><br><span class="line">      checkAnalysis(analyzed)</span><br><span class="line">      &#x2F;&#x2F; 将 LogicPlan 的 AnalysisBarrier 装箱去掉(如果存在)</span><br><span class="line">      EliminateBarriers(analyzed)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case e: AnalysisException &#x3D;&gt;</span><br><span class="line">        val ae &#x3D; new AnalysisException(e.message, e.line, e.startPosition, Option(analyzed))</span><br><span class="line">        ae.setStackTrace(e.getStackTrace)</span><br><span class="line">        throw ae</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SessionCatalog"><a href="#SessionCatalog" class="headerlink" title="SessionCatalog"></a>SessionCatalog</h3><p>SessionCatalog 是 SparkSession 索引维护的信息库，SessionCatalog 一方面可以管理 SparkSession 创建的临时视图和 UDF，一方面可以作为外部元数据库的代理以便 SparkSession 获取外部源数据库信息(e.g. HiveSessionCatalog 操作 Hive metastore)。    </p>
<table>
<thead>
<tr>
<th align="left">成员变量</th>
<th align="left">数据类型</th>
<th align="left">功能</th>
<th align="left">Catalog 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tableRelationCache</td>
<td align="left">Cache[QualifiedTableName, LogicalPlan]</td>
<td align="left">表全限定名与逻辑计划的映射</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">tempViews</td>
<td align="left">HashMap[String, LogicalPlan]</td>
<td align="left">临时视图名与逻辑计划的映射</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">globalTempViewManager</td>
<td align="left">GlobalTempViewManager</td>
<td align="left">全局视图管理</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">externalCatalog</td>
<td align="left">ExternalCatalog</td>
<td align="left">外部元数据库的代理,从获得连接到库表分区函数等信息获取接口</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">functionRegistry</td>
<td align="left">FunctionRegistry</td>
<td align="left">函数(builtin,UDF)操作代理</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">parser</td>
<td align="left">ParserInterface</td>
<td align="left">SQL 文本解析 Parser</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">functionResourceLoader</td>
<td align="left">FunctionResourceLoader</td>
<td align="left">加载函数主类资源加载器</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">metastoreCatalog</td>
<td align="left">HiveMetastoreCatalog</td>
<td align="left">HiveExternalCatalog 的旧接口,deprecated</td>
<td align="left">HiveSessionCatalog</td>
</tr>
</tbody></table>
<p>引用一个通过表名绑定逻辑计划的函数: 通过表所属数据库名在全局视图，外部元数据库和临时视图内搜索以绑定逻辑计划<br>[SessionCatalog.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def lookupRelation(name: TableIdentifier): LogicalPlan &#x3D; &#123;</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      val db &#x3D; formatDatabaseName(name.database.getOrElse(currentDb))</span><br><span class="line">      val table &#x3D; formatTableName(name.table)</span><br><span class="line">      &#x2F;&#x2F; 全局视图</span><br><span class="line">      if (db &#x3D;&#x3D; globalTempViewManager.database) &#123;</span><br><span class="line">        globalTempViewManager.get(table).map &#123; viewDef &#x3D;&gt;</span><br><span class="line">          SubqueryAlias(table, viewDef)</span><br><span class="line">        &#125;.getOrElse(throw new NoSuchTableException(db, table))</span><br><span class="line">      &#125; else if (name.database.isDefined || !tempViews.contains(table)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 外部元数据库</span><br><span class="line">        val metadata &#x3D; externalCatalog.getTable(db, table)</span><br><span class="line">        if (metadata.tableType &#x3D;&#x3D; CatalogTableType.VIEW) &#123;</span><br><span class="line">          val viewText &#x3D; metadata.viewText.getOrElse(sys.error(&quot;Invalid view without text.&quot;))</span><br><span class="line">          val child &#x3D; View(</span><br><span class="line">            desc &#x3D; metadata,</span><br><span class="line">            output &#x3D; metadata.schema.toAttributes,</span><br><span class="line">            child &#x3D; parser.parsePlan(viewText))</span><br><span class="line">          SubqueryAlias(table, child)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          SubqueryAlias(table, UnresolvedCatalogRelation(metadata))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 临时视图</span><br><span class="line">        SubqueryAlias(table, tempViews(table))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>Anayzer 模块对 UnResolvedLogicPlan 应用多批规则库，其中主要是 Resolution(解析)规则库和 Substitution(转换)规则库，直到每批规则库达到了指定的迭代次数或者规则库无法再优化逻辑计划为止。  </p>
<p>调用栈<br>Analyzer#executeAndCheck<br>　-&gt;Analyzer#execute<br>　　-&gt;Analyzer#executeSameContext<br>　　　-&gt;RuleExecutor#execute<br>[RuleExecutor.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 规则批次间和批次内都是串行执行</span><br><span class="line"> * 逻辑计划在此处被 Analyzed 之后就替换了(result&#x2F;curPlan和返回值)</span><br><span class="line"> *&#x2F;</span><br><span class="line">def execute(plan: TreeType): TreeType &#x3D; &#123;</span><br><span class="line">  var curPlan &#x3D; plan</span><br><span class="line">  batches.foreach &#123; batch &#x3D;&gt;</span><br><span class="line">    val batchStartPlan &#x3D; curPlan</span><br><span class="line">    var iteration &#x3D; 1</span><br><span class="line">    var lastPlan &#x3D; curPlan	&#x2F;&#x2F;tempPlan</span><br><span class="line">    var continue &#x3D; true</span><br><span class="line">    &#x2F;&#x2F; foldLeft 依次执行规则 batch 中的所有规则,直到达到了规则的最大执行次数或者逻辑算子树不再变化</span><br><span class="line">    while (continue) &#123;</span><br><span class="line">      curPlan &#x3D; batch.rules.foldLeft(curPlan) &#123; </span><br><span class="line">        case (plan, rule) &#x3D;&gt;</span><br><span class="line">        &#x2F;&#x2F; 在逻辑计划上应用规则处理</span><br><span class="line">          val result &#x3D; rule(plan) &#x2F;&#x2F;rule.apply(plan)</span><br><span class="line">          if (!result.fastEquals(plan)) &#123;</span><br><span class="line">            logTrace(</span><br><span class="line">              s&quot;&quot;&quot;</span><br><span class="line">                |&#x3D;&#x3D;&#x3D; Applying Rule $&#123;rule.ruleName&#125; &#x3D;&#x3D;&#x3D;</span><br><span class="line">                |$&#123;sideBySide(plan.treeString, result.treeString).mkString(&quot;\n&quot;)&#125;</span><br><span class="line">              &quot;&quot;&quot;.stripMargin)</span><br><span class="line">          &#125;</span><br><span class="line">          queryExecutionMetrics.incExecutionTimeBy(rule.ruleName, runTime)</span><br><span class="line">          queryExecutionMetrics.incNumExecution(rule.ruleName)</span><br><span class="line">          ....</span><br><span class="line">           result</span><br><span class="line">      &#125;</span><br><span class="line">      iteration +&#x3D; 1</span><br><span class="line">       &#x2F;&#x2F; 达到了该规则批策略的最大迭代次数</span><br><span class="line">      if (iteration &gt; batch.strategy.maxIterations) &#123;</span><br><span class="line">        ...</span><br><span class="line">        continue &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 这批规则已经不能再优化逻辑计划了</span><br><span class="line">      if (curPlan.fastEquals(lastPlan)) &#123;</span><br><span class="line">        logTrace(</span><br><span class="line">          s&quot;Fixed point reached for batch $&#123;batch.name&#125; after $&#123;iteration - 1&#125; iterations.&quot;)</span><br><span class="line">        continue &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlan &#x3D; curPlan</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  curPlan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是其中的 rule(plan)方法，即 Rule#apply(plan)。各规则子类依据自身的功能解析转换 TreeNode，包括绑定 UnResolvedLogicPlan 为 ResolvedLogicPlan<br> [Rule.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Rule[TreeType &lt;: TreeNode[_]] extends Logging &#123;</span><br><span class="line">  val ruleName: String &#x3D; &#123;</span><br><span class="line">    val className &#x3D; getClass.getName</span><br><span class="line">    if (className endsWith &quot;$&quot;) className.dropRight(1) else className</span><br><span class="line">  &#125;</span><br><span class="line">  def apply(plan: TreeType): TreeType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则的具体功能列表参考”附录：规则功能列表”   </p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>调用栈<br>Analyze#executeAndCheck<br>　-&gt;CheckAndAnalysis#checkAnalysis  </p>
<p>检查 ResolvedLogicPlan 中不合乎语法规范的错误，使用后序遍历(先子节点后当前节点)的方式尽可能抛出最先导致失败的错误<br>[CheckAndAnaysis.scala]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def checkAnalysis(plan: LogicalPlan): Unit &#x3D; &#123;</span><br><span class="line">    plan.foreachUp &#123;</span><br><span class="line">      case u: UnresolvedRelation &#x3D;&gt;</span><br><span class="line">        u.failAnalysis(s&quot;Table or view not found: $&#123;u.tableIdentifier&#125;&quot;)</span><br><span class="line"></span><br><span class="line">      case operator: LogicalPlan &#x3D;&gt;</span><br><span class="line">        operator transformExpressionsUp &#123;</span><br><span class="line">          case a: Attribute if !a.resolved &#x3D;&gt;</span><br><span class="line">            val from &#x3D; operator.inputSet.map(_.qualifiedName).mkString(&quot;, &quot;)</span><br><span class="line">            a.failAnalysis(s&quot;cannot resolve &#39;$&#123;a.sql&#125;&#39; given input columns: [$from]&quot;)</span><br><span class="line"></span><br><span class="line">          case e: Expression if e.checkInputDataTypes().isFailure &#x3D;&gt;</span><br><span class="line">            e.checkInputDataTypes() match &#123;</span><br><span class="line">              case TypeCheckResult.TypeCheckFailure(message) &#x3D;&gt;</span><br><span class="line">                e.failAnalysis(</span><br><span class="line">                  s&quot;cannot resolve &#39;$&#123;e.sql&#125;&#39; due to data type mismatch: $message&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          case c: Cast if !c.resolved &#x3D;&gt;</span><br><span class="line">            failAnalysis(</span><br><span class="line">              s&quot;invalid cast from $&#123;c.child.dataType.simpleString&#125; to $&#123;c.dataType.simpleString&#125;&quot;)</span><br><span class="line"></span><br><span class="line">          case g: Grouping &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;grouping() can only be used with GroupingSets&#x2F;Cube&#x2F;Rollup&quot;)</span><br><span class="line">          case g: GroupingID &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;grouping_id() can only be used with GroupingSets&#x2F;Cube&#x2F;Rollup&quot;)</span><br><span class="line"></span><br><span class="line">          case w @ WindowExpression(AggregateExpression(_, _, true, _), _) &#x3D;&gt;</span><br><span class="line">            failAnalysis(s&quot;Distinct window functions are not supported: $w&quot;)</span><br><span class="line"></span><br><span class="line">          case w @ WindowExpression(_: OffsetWindowFunction,</span><br><span class="line">            WindowSpecDefinition(_, order, frame: SpecifiedWindowFrame))</span><br><span class="line">             if order.isEmpty || !frame.isOffset &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;An offset window function can only be evaluated in an ordered &quot; +</span><br><span class="line">              s&quot;row-based window frame with a single offset: $w&quot;)</span><br><span class="line"></span><br><span class="line">          case w @ WindowExpression(e, s) &#x3D;&gt;</span><br><span class="line">            &#x2F;&#x2F; Only allow window functions with an aggregate expression or an offset window</span><br><span class="line">            &#x2F;&#x2F; function.</span><br><span class="line">            e match &#123;</span><br><span class="line">              case _: AggregateExpression | _: OffsetWindowFunction | _: AggregateWindowFunction &#x3D;&gt;</span><br><span class="line">                w</span><br><span class="line">              case _ &#x3D;&gt;</span><br><span class="line">                failAnalysis(s&quot;Expression &#39;$e&#39; not supported within a window function.&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          case s: SubqueryExpression &#x3D;&gt;</span><br><span class="line">            checkSubqueryExpression(operator, s)</span><br><span class="line">            s</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operator match &#123;</span><br><span class="line">          case etw: EventTimeWatermark &#x3D;&gt;</span><br><span class="line">            etw.eventTime.dataType match &#123;</span><br><span class="line">              case s: StructType</span><br><span class="line">                if s.find(_.name &#x3D;&#x3D; &quot;end&quot;).map(_.dataType) &#x3D;&#x3D; Some(TimestampType) &#x3D;&gt;</span><br><span class="line">              case _: TimestampType &#x3D;&gt;</span><br><span class="line">              case _ &#x3D;&gt;</span><br><span class="line">                failAnalysis(</span><br><span class="line">                  s&quot;Event time must be defined on a window or a timestamp, but &quot; +</span><br><span class="line">                  s&quot;$&#123;etw.eventTime.name&#125; is of type $&#123;etw.eventTime.dataType.simpleString&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">          case f: Filter if f.condition.dataType !&#x3D; BooleanType &#x3D;&gt;</span><br><span class="line">            failAnalysis(</span><br><span class="line">              s&quot;filter expression &#39;$&#123;f.condition.sql&#125;&#39; &quot; +</span><br><span class="line">                s&quot;of type $&#123;f.condition.dataType.simpleString&#125; is not a boolean.&quot;)</span><br><span class="line"></span><br><span class="line">          case Filter(condition, _) if hasNullAwarePredicateWithinNot(condition) &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;Null-aware predicate sub-queries cannot be used in nested &quot; +</span><br><span class="line">              s&quot;conditions: $condition&quot;)</span><br><span class="line"></span><br><span class="line">          case j @ Join(_, _, _, Some(condition)) if condition.dataType !&#x3D; BooleanType &#x3D;&gt;</span><br><span class="line">            failAnalysis(</span><br><span class="line">              s&quot;join condition &#39;$&#123;condition.sql&#125;&#39; &quot; +</span><br><span class="line">                s&quot;of type $&#123;condition.dataType.simpleString&#125; is not a boolean.&quot;)</span><br><span class="line">	..........</span><br><span class="line">	&#x2F;&#x2F; 自定义的规则检查在内置规则检查之后才能开始</span><br><span class="line">    extendedCheckRules.foreach(_(plan))</span><br><span class="line">    plan.foreachUp &#123;</span><br><span class="line">      case AnalysisBarrier(child) if !child.resolved &#x3D;&gt; checkAnalysis(child)</span><br><span class="line">      case o if !o.resolved &#x3D;&gt; failAnalysis(s&quot;unresolved operator $&#123;o.simpleString&#125;&quot;)</span><br><span class="line">      case _ &#x3D;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>UnResolvedLogicPlan 在绑定了 Catalog 之后可以转换为 RDD 模式来执行了，但是由于提交的 SQL 质量参差不齐，按照 ResolvedLogicPlan 按部就班的执行会导致代价/效率差距很大 且 要求用户对执行引擎的执行模式很了解并熟悉 SQL 优化手段才能写出效率高执行快的 SQL。所以为了尽可能忽略用户的代码质量，对SQL 优化的熟悉程度，SparkSQL 都需要以很高的效率执行，SparkSQL 在后续阶段需要对 UnResolvedLogicPlan 进行优化，即 Rule-Based Optimizer，也称为 RBO。    </p>
<h2 id="附录：规则功能列表"><a href="#附录：规则功能列表" class="headerlink" title="附录：规则功能列表"></a>附录：规则功能列表</h2><p>规则库 Batch: 在 UnResolvedLogicPlan 上应用规则库 rules 的执行策略 strategy。 
[Batch.scala]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case class Batch(name: String, strategy: Strategy, rules: Rule[TreeType]*)</span><br></pre></td></tr></table></figure>
<p>Strategy 表示规则批的最大迭代次数，有两个子类: Once 表明只需应用一次规则库即可；FixedPoint 表示最大可以应用规则库 maxIterations 次，如果应用中途无法再优化逻辑计划则跳出。   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Strategy &#123; def maxIterations: Int &#125;</span><br><span class="line">case object Once extends Strategy &#123; val maxIterations &#x3D; 1 &#125;</span><br><span class="line">case class FixedPoint(maxIterations: Int) extends Strategy</span><br></pre></td></tr></table></figure>
<p>规则 Rule 的子类有很多,在 Analyze.scala 中使用的所有规则如下<br>[Analyzer.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy val batches: Seq[Batch] &#x3D; Seq(</span><br><span class="line">  Batch(&quot;Hints&quot;, fixedPoint,</span><br><span class="line">    new ResolveHints.ResolveBroadcastHints(conf),</span><br><span class="line">    ResolveHints.RemoveAllHints),</span><br><span class="line">  Batch(&quot;Simple Sanity Check&quot;, Once,</span><br><span class="line">    LookupFunctions),</span><br><span class="line">  Batch(&quot;Substitution&quot;, fixedPoint,</span><br><span class="line">    CTESubstitution,</span><br><span class="line">    WindowsSubstitution,</span><br><span class="line">    EliminateUnions,</span><br><span class="line">    new SubstituteUnresolvedOrdinals(conf)),</span><br><span class="line">  Batch(&quot;Resolution&quot;, fixedPoint,</span><br><span class="line">    ResolveTableValuedFunctions ::</span><br><span class="line">    ResolveRelations ::</span><br><span class="line">    ResolveReferences ::</span><br><span class="line">    ResolveCreateNamedStruct ::</span><br><span class="line">    ResolveDeserializer ::</span><br><span class="line">    ResolveNewInstance ::</span><br><span class="line">    ResolveUpCast ::</span><br><span class="line">    ResolveGroupingAnalytics ::</span><br><span class="line">    ResolvePivot ::</span><br><span class="line">    ResolveOrdinalInOrderByAndGroupBy ::</span><br><span class="line">    ResolveAggAliasInGroupBy ::</span><br><span class="line">    ResolveMissingReferences ::</span><br><span class="line">    ExtractGenerator ::</span><br><span class="line">    ResolveGenerate ::</span><br><span class="line">    ResolveFunctions ::</span><br><span class="line">    ResolveAliases ::</span><br><span class="line">    ResolveSubquery ::</span><br><span class="line">    ResolveSubqueryColumnAliases ::</span><br><span class="line">    ResolveWindowOrder ::</span><br><span class="line">    ResolveWindowFrame ::</span><br><span class="line">    ResolveNaturalAndUsingJoin ::</span><br><span class="line">    ExtractWindowExpressions ::</span><br><span class="line">    GlobalAggregates ::</span><br><span class="line">    ResolveAggregateFunctions ::</span><br><span class="line">    TimeWindowing ::</span><br><span class="line">    ResolveInlineTables(conf) ::</span><br><span class="line">    ResolveTimeZone(conf) ::</span><br><span class="line">    TypeCoercion.typeCoercionRules(conf) ++</span><br><span class="line">    extendedResolutionRules : _*),</span><br><span class="line">  Batch(&quot;Post-Hoc Resolution&quot;, Once, postHocResolutionRules: _*),</span><br><span class="line">  Batch(&quot;View&quot;, Once,</span><br><span class="line">    AliasViewChild(conf)),</span><br><span class="line">  Batch(&quot;Nondeterministic&quot;, Once,</span><br><span class="line">    PullOutNondeterministic),</span><br><span class="line">  Batch(&quot;UDF&quot;, Once,</span><br><span class="line">    HandleNullInputsForUDF),</span><br><span class="line">  Batch(&quot;FixNullability&quot;, Once,</span><br><span class="line">    FixNullability),</span><br><span class="line">  Batch(&quot;Subquery&quot;, Once,</span><br><span class="line">    UpdateOuterReferences),</span><br><span class="line">  Batch(&quot;Cleanup&quot;, fixedPoint,</span><br><span class="line">    CleanupAliases)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中最重要的规则库是Substitution(替换)和Resolution(解析绑定)。这些规则库之间及规则库之内都是有序的，使用规则时也是串行执行的。打乱了顺序可能有转换不充分等未知的错误<br>下表主要参照 org.apache.spark.sql.catalyst.parser.SqlBase.g4 文件和源码，带问号的为不确定的。</p>
<table>
<thead>
<tr>
<th>规则批次</th>
<th>规则</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Hints</td>
<td>ResolveBroadcastHints</td>
<td>广播</td>
<td>mapjoin</td>
</tr>
<tr>
<td>Hints</td>
<td>RemoveAllHints</td>
<td>删除无效标识符</td>
<td></td>
</tr>
<tr>
<td>Simple Sanity Check</td>
<td>LookupFunctions</td>
<td>函数存在性检验</td>
<td></td>
</tr>
<tr>
<td>Substitution</td>
<td>CTESubstitution</td>
<td>with,合并计划</td>
<td>with a as something select * from a</td>
</tr>
<tr>
<td>Substitution</td>
<td>WindowsSubstitution</td>
<td>窗口函数</td>
<td>row_number() over (partitioned by a sort by b desc)</td>
</tr>
<tr>
<td>Substitution</td>
<td>EliminateUnions</td>
<td>union的计划只有一个时删除 union</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveTableValuedFunctions</td>
<td>解析可作为表的函数</td>
<td>range函数</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveRelations</td>
<td>表绑定catalog中的逻辑计划</td>
<td>对应createXXXView接口</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveReferences</td>
<td>展开星号绑定列</td>
<td>select a.* from</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveCreateNamedStruct</td>
<td>解析结构体构造方法</td>
<td>?,没见过hql中使用结构体</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveDeserializer</td>
<td>解析反序列化类</td>
<td>decoder</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveNewInstance</td>
<td>解析创建实例</td>
<td>encoder</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveUpCast</td>
<td>解析类型转换</td>
<td>cast,在丢失精度时抛异常</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveGroupingAnalytics</td>
<td>解析rollup多维度分析</td>
<td>group by a,b,c with rollup 等价于 group by a,b,c grouping sets((a,b,c),(a,b),(a),())</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolvePivot</td>
<td>行转列</td>
<td>pivot 接口</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveOrdinalInOrderByAndGroupBy</td>
<td>解析order/sort/group by语句的下标数字</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveAggAliasInGroupBy</td>
<td>解析聚合时的表达式</td>
<td>group by case when then x else y end</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveMissingReferences</td>
<td>解析在排序时不存在的列,加上但隐藏该列</td>
<td>select a from … order by b</td>
</tr>
<tr>
<td>Resolution</td>
<td>ExtractGenerator</td>
<td>解析UDTF生成器</td>
<td>select explode(xx) from ..</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveGenerate</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveFunctions</td>
<td>解析函数为表达式</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveAliases</td>
<td>解析生成别名表达式</td>
<td>?</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveSubquery</td>
<td>解析子查询</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveSubqueryColumnAliases</td>
<td>解析子查询列别名</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveWindowOrder</td>
<td>解析窗口函数中的排序</td>
<td>over partitioned by .. order by..</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveWindowFrame</td>
<td>解析检验窗口函数</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveNaturalAndUsingJoin</td>
<td>通过输出列解析自然连接</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ExtractWindowExpressions</td>
<td>提取窗口函数表达式</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>GlobalAggregates</td>
<td>解析全局聚合</td>
<td>select max(a) from tbl</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveAggregateFunctions</td>
<td>解析不在聚合中的聚合函数</td>
<td>having/order by</td>
</tr>
<tr>
<td>Resolution</td>
<td>TimeWindowing</td>
<td>解析滑动时间窗口</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveInlineTables</td>
<td>解析内联表为LocalRelation</td>
<td>select * fom values(..),(..) as (columns)</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveTimeZone</td>
<td>解析时区表达式</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>TypeCoercion.typeCoercionRules</td>
<td>强制转换为兼容类型</td>
<td>在比较和 union 时使用,不损失精度</td>
</tr>
<tr>
<td>Resolution</td>
<td>extendedResolutionRules</td>
<td>拓展规则,空集合</td>
<td>?</td>
</tr>
<tr>
<td>Post-Hoc Resolution</td>
<td>postHocResolutionRules</td>
<td>Resolution 规则后执行的规则.空集合</td>
<td></td>
</tr>
<tr>
<td>View</td>
<td>AliasViewChild</td>
<td>视图的分析规则</td>
<td></td>
</tr>
<tr>
<td>Nondeterministic</td>
<td>PullOutNondeterministic</td>
<td>提取非确定性表达式,放到child 中</td>
<td>?</td>
</tr>
<tr>
<td>UDF</td>
<td>HandleNullInputsForUDF</td>
<td>对UDF增加基本数据类型null处理(空输入则空输出)</td>
<td></td>
</tr>
<tr>
<td>FixNullability</td>
<td>FixNullability</td>
<td>通过 child 字段的 Nullablity 修复父逻辑计划字段的 Nullablity</td>
<td></td>
</tr>
<tr>
<td>Subquery</td>
<td>UpdateOuterReferences</td>
<td>聚合表达式下推</td>
<td>?</td>
</tr>
<tr>
<td>Cleanup</td>
<td>CleanupAliases</td>
<td>删除不需要的别名</td>
<td></td>
</tr>
</tbody></table>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with a  as … select * from a 语法是 SQL 语句中的一个特殊 case，with 子句打乱了 SQL 解析的通用模式，无法从上至下从左至右进行解析，只能将整个语句解析为两个相对独立的逻辑算子树，然后通过别名将 with 语句的逻辑算子树加入到主体逻辑算子树的下面  </p>
<p>[WindowsSubstitution.scala] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object WindowsSubstitution extends Rule[LogicalPlan] &#123;</span><br><span class="line">  def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformUp &#123;</span><br><span class="line">    &#x2F;&#x2F;使用多层 match case 来匹配拿到 window 函数,</span><br><span class="line">    case WithWindowDefinition(windowDefinitions, child) &#x3D;&gt;</span><br><span class="line">      child.transform &#123;</span><br><span class="line">        case p &#x3D;&gt; p.transformExpressions &#123;</span><br><span class="line">          case UnresolvedWindowExpression(c, WindowSpecReference(windowName)) &#x3D;&gt;</span><br><span class="line">            val errorMessage &#x3D;</span><br><span class="line">              s&quot;Window specification $windowName is not defined in the WINDOW clause.&quot;</span><br><span class="line">            val windowSpecDefinition &#x3D;</span><br><span class="line">              windowDefinitions.getOrElse(windowName, failAnalysis(errorMessage))</span><br><span class="line">            WindowExpression(c, windowSpecDefinition)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="relation"><a href="#relation" class="headerlink" title="relation"></a>relation</h3><p>绑定关系<br>[ResolveRelations.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> object ResolveRelations extends Rule[LogicalPlan] &#123;</span><br><span class="line">  &#x2F;&#x2F; 后序遍历尝试绑定每个匹配的节点到 ResolvedLogicPlan</span><br><span class="line">   def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformUp &#123;</span><br><span class="line">     case i @ InsertIntoTable(u: UnresolvedRelation, parts, child, _, _) if child.resolved &#x3D;&gt;</span><br><span class="line">      &#x2F;&#x2F; lookupTableFromCatalog(u) 从全局视图&gt;外接元数据库&gt;临时视图中绑定实体  </span><br><span class="line">      &#x2F;&#x2F; EliminateSubqueryAliases 去掉别名将子查询查询计划剥离出来</span><br><span class="line">       EliminateSubqueryAliases(lookupTableFromCatalog(u)) match &#123;</span><br><span class="line">         case v: View &#x3D;&gt;</span><br><span class="line">           u.failAnalysis(s&quot;Inserting into a view is not allowed. View: $&#123;v.desc.identifier&#125;.&quot;)</span><br><span class="line">         case other &#x3D;&gt; i.copy(table &#x3D; other)</span><br><span class="line">       &#125;</span><br><span class="line">     case u: UnresolvedRelation &#x3D;&gt; resolveRelation(u)	</span><br><span class="line">   &#125;</span><br><span class="line">   先看第一个 case,如果是 insert into 句法的话,借助 catalog的&lt;tableName,LogicPlan&gt;缓存绑定表为已解析过的逻辑计划</span><br><span class="line">   private def lookupTableFromCatalog(</span><br><span class="line">       u: UnresolvedRelation,</span><br><span class="line">       defaultDatabase: Option[String] &#x3D; None): LogicalPlan &#x3D; &#123;</span><br><span class="line">     val tableIdentWithDb &#x3D; u.tableIdentifier.copy(</span><br><span class="line">       database &#x3D; u.tableIdentifier.database.orElse(defaultDatabase))</span><br><span class="line">     try &#123;</span><br><span class="line">       catalog.lookupRelation(tableIdentWithDb)</span><br><span class="line">     &#125; catch &#123;</span><br><span class="line">	....        </span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">[SessionCatalog.scala] </span><br><span class="line"> def lookupRelation(name: TableIdentifier): LogicalPlan &#x3D; &#123;</span><br><span class="line">   synchronized &#123;</span><br><span class="line">     val db &#x3D; formatDatabaseName(name.database.getOrElse(currentDb))</span><br><span class="line">     val table &#x3D; formatTableName(name.table)</span><br><span class="line">     &#x2F;&#x2F;从全局临时视图,外接元数据库,临时视图中查找该表的逻辑计划</span><br><span class="line">     if (db &#x3D;&#x3D; globalTempViewManager.database) &#123;</span><br><span class="line">       globalTempViewManager.get(table).map &#123; viewDef &#x3D;&gt;</span><br><span class="line">         SubqueryAlias(table, viewDef)</span><br><span class="line">       &#125;.getOrElse(throw new NoSuchTableException(db, table))</span><br><span class="line">     &#125; else if (name.database.isDefined || !tempViews.contains(table)) &#123;</span><br><span class="line">       val metadata &#x3D; externalCatalog.getTable(db, table)</span><br><span class="line">       if (metadata.tableType &#x3D;&#x3D; CatalogTableType.VIEW) &#123;</span><br><span class="line">         val viewText &#x3D; metadata.viewText.getOrElse(sys.error(&quot;Invalid view without text.&quot;))</span><br><span class="line">         val child &#x3D; View(</span><br><span class="line">           desc &#x3D; metadata,</span><br><span class="line">           output &#x3D; metadata.schema.toAttributes,</span><br><span class="line">           child &#x3D; parser.parsePlan(viewText))</span><br><span class="line">         SubqueryAlias(table, child)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         SubqueryAlias(table, UnresolvedCatalogRelation(metadata))</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       SubqueryAlias(table, tempViews(table))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 再看ResolveRelations.apply方法的第二个 case u:UnresolvedRelation &#x3D;&gt; resolveRelation(u),所以首先会进入下面方法的第一个 case, 即如果不是直接在文件上运行(from json.$path)的话,先从 Catalog 中绑定逻辑计划</span><br><span class="line"> [ResolveRelation.scala]</span><br><span class="line">   def resolveRelation(plan: LogicalPlan): LogicalPlan &#x3D; plan match &#123;</span><br><span class="line">     case u: UnresolvedRelation if !isRunningDirectlyOnFiles(u.tableIdentifier) &#x3D;&gt;</span><br><span class="line">       val defaultDatabase &#x3D; AnalysisContext.get.defaultDatabase</span><br><span class="line">       val foundRelation &#x3D; lookupTableFromCatalog(u, defaultDatabase)</span><br><span class="line">       resolveRelation(foundRelation)</span><br><span class="line">     case view @ View(desc, _, child) if !child.resolved &#x3D;&gt;</span><br><span class="line">       &#x2F;&#x2F; Resolve all the UnresolvedRelations and Views in the child.</span><br><span class="line">       val newChild &#x3D; AnalysisContext.withAnalysisContext(desc.viewDefaultDatabase) &#123;</span><br><span class="line">         if (AnalysisContext.get.nestedViewDepth &gt; conf.maxNestedViewDepth) &#123;</span><br><span class="line">           view.failAnalysis(s&quot;The depth of view $&#123;view.desc.identifier&#125; exceeds the maximum &quot; +</span><br><span class="line">             s&quot;view resolution depth ($&#123;conf.maxNestedViewDepth&#125;). Analysis is aborted to &quot; +</span><br><span class="line">             s&quot;avoid errors. Increase the value of $&#123;SQLConf.MAX_NESTED_VIEW_DEPTH.key&#125; to work &quot; +</span><br><span class="line">             &quot;around this.&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">         executeSameContext(child)</span><br><span class="line">       &#125;</span><br><span class="line">       view.copy(child &#x3D; newChild)</span><br><span class="line">     case p @ SubqueryAlias(_, view: View) &#x3D;&gt;</span><br><span class="line">       val newChild &#x3D; resolveRelation(view)</span><br><span class="line">       p.copy(child &#x3D; newChild)</span><br><span class="line">     case _ &#x3D;&gt; plan</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LookupFunctions"><a href="#LookupFunctions" class="headerlink" title="LookupFunctions"></a>LookupFunctions</h3><p>函数存在性校验<br>[LookupFuncations.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object LookupFunctions extends Rule[LogicalPlan] &#123;</span><br><span class="line">    override def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformAllExpressions &#123;</span><br><span class="line">     &#x2F;&#x2F; 递归检测使用的函数在 catalog 中是否存在</span><br><span class="line">      case f: UnresolvedFunction if !catalog.functionExists(f.name) &#x3D;&gt;</span><br><span class="line">        withPosition(f) &#123;</span><br><span class="line">          throw new NoSuchFunctionException(f.name.database.getOrElse(&quot;default&quot;), f.name.funcName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>[SessionCatalog.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def functionExists(name: FunctionIdentifier): Boolean &#x3D; &#123;</span><br><span class="line">    val db &#x3D; formatDatabaseName(name.database.getOrElse(getCurrentDatabase))</span><br><span class="line">    requireDbExists(db)</span><br><span class="line">    &#x2F;&#x2F; 使用 FuncationRegistry 和外接元数据库检测函数是否存在</span><br><span class="line">    functionRegistry.functionExists(name) ||</span><br><span class="line">      externalCatalog.functionExists(db, name.funcName)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ResolveFunction"><a href="#ResolveFunction" class="headerlink" title="ResolveFunction"></a>ResolveFunction</h3><p>将函数替换为具体的表达式<br>[ResolveFunction.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object ResolveFunctions extends Rule[LogicalPlan] &#123;</span><br><span class="line">    def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformUp &#123;</span><br><span class="line">      case q: LogicalPlan &#x3D;&gt;</span><br><span class="line">        q transformExpressions &#123;</span><br><span class="line">          case u if !u.childrenResolved &#x3D;&gt; u &#x2F;&#x2F; Skip until children are resolved.</span><br><span class="line">          case u: UnresolvedAttribute if resolver(u.name, VirtualColumn.hiveGroupingIdName) &#x3D;&gt;</span><br><span class="line">            withPosition(u) &#123;</span><br><span class="line">              Alias(GroupingID(Nil), VirtualColumn.hiveGroupingIdName)()</span><br><span class="line">            &#125;</span><br><span class="line">          case u @ UnresolvedGenerator(name, children) &#x3D;&gt;</span><br><span class="line">            withPosition(u) &#123;</span><br><span class="line">              catalog.lookupFunction(name, children) match &#123;</span><br><span class="line">                case generator: Generator &#x3D;&gt; generator</span><br><span class="line">                case other &#x3D;&gt;</span><br><span class="line">                  failAnalysis(s&quot;$name is expected to be a generator. However, &quot; +</span><br><span class="line">                    s&quot;its class is $&#123;other.getClass.getCanonicalName&#125;, which is not a generator.&quot;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          case u @ UnresolvedFunction(funcId, children, isDistinct) &#x3D;&gt;</span><br><span class="line">            withPosition(u) &#123;</span><br><span class="line">              &#x2F;&#x2F; 使用 catalog 寻找函数</span><br><span class="line">              catalog.lookupFunction(funcId, children) match &#123;</span><br><span class="line">                case wf: AggregateWindowFunction &#x3D;&gt;</span><br><span class="line">                  if (isDistinct) &#123;</span><br><span class="line">                    failAnalysis(s&quot;$&#123;wf.prettyName&#125; does not support the modifier DISTINCT&quot;)</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    wf</span><br><span class="line">                  &#125;</span><br><span class="line">                case agg: AggregateFunction &#x3D;&gt; AggregateExpression(agg, Complete, isDistinct)</span><br><span class="line">                case other &#x3D;&gt;</span><br><span class="line">                  if (isDistinct) &#123;</span><br><span class="line">                    failAnalysis(s&quot;$&#123;other.prettyName&#125; does not support the modifier DISTINCT&quot;)</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    other</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用 SessionCatalog 优先从 FunctionRegistry 中寻找，然后从外接元数据库寻找并加载资源注册到 FunctionRegistry，有些像双亲委派模型，保证 builtin 的函数不被 UDF覆盖。<br>[SessionCatalog.scala]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def lookupFunction(</span><br><span class="line">      name: FunctionIdentifier,</span><br><span class="line">      children: Seq[Expression]): Expression &#x3D; synchronized &#123;</span><br><span class="line">    if (name.database.isEmpty &amp;&amp; functionRegistry.functionExists(name)) &#123;</span><br><span class="line">      &#x2F;&#x2F; This function has been already loaded into the function registry.</span><br><span class="line">      return functionRegistry.lookupFunction(name, children)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If the name itself is not qualified, add the current database to it.</span><br><span class="line">    val database &#x3D; formatDatabaseName(name.database.getOrElse(getCurrentDatabase))</span><br><span class="line">    val qualifiedName &#x3D; name.copy(database &#x3D; Some(database))</span><br><span class="line"></span><br><span class="line">    if (functionRegistry.functionExists(qualifiedName)) &#123;</span><br><span class="line">      return functionRegistry.lookupFunction(qualifiedName, children)</span><br><span class="line">    &#125;</span><br><span class="line">    val catalogFunction &#x3D; try &#123;</span><br><span class="line">      externalCatalog.getFunction(database, name.funcName)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case _: AnalysisException &#x3D;&gt; failFunctionLookup(name)</span><br><span class="line">      case _: NoSuchPermanentFunctionException &#x3D;&gt; failFunctionLookup(name)</span><br><span class="line">    &#125;</span><br><span class="line">    loadFunctionResources(catalogFunction.resources)</span><br><span class="line">    registerFunction(catalogFunction.copy(identifier &#x3D; qualifiedName), overrideIfExists &#x3D; false)</span><br><span class="line">    &#x2F;&#x2F; Now, we need to create the Expression.</span><br><span class="line">    functionRegistry.lookupFunction(qualifiedName, children)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
        <tag>源码解析</tag>
        <tag>Spark SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkSQL源码解析(1):从 SQL 到 UnResolvedLogicPlan</title>
    <url>/2019-11-28-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(1):%E4%BB%8E%20SQL%20%E5%88%B0%20UnResolvedLogicPlan/</url>
    <content><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Parser模块 SparkSqlParser 持有的 SparkSqlAstBuilder 遍历 ANTLR 生成的词法/句法解析器解析成的语法树节点转换成相应的 LogicPlan节点，此时的 LogicPlan 节点仅仅从原始 SQL 文本中解析出来，不包含[表|列|函数]信息，因而称之为未解析的逻辑算子树 UnresolvedLogicPlan。</p>
<a id="more"></a>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>SparkSession#sql(sqlText) 首先使用 sessionState 持有的 SparkSqlParser#parsePlan(sqlText) 将 sqlText 解析为逻辑计划，然后由 SparkSession 和逻辑计划来构建 DataFrame<br>[SparkSession.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sql(sqlText: String): DataFrame &#x3D; &#123;</span><br><span class="line">   Dataset.ofRows(self, sessionState.sqlParser.parsePlan(sqlText))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>SparkSqlParser#parsePlan 继承自 AbstractSqlParser，SparkSqlParser 主要有两个作用: </p>
<ol>
<li>自定义 SparkSqlAstBuilder 遍历 原始 sql 解析来的语法树每个节点 解析映射为UnResolvedLogicPlan。这是核心功能    </li>
<li>变量替换，替换<code>${var}</code>, <code>${system:var}</code> and <code>${env:var}</code>     </li>
</ol>
<p>[SparkSqlParser.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SparkSqlParser(conf: SQLConf) extends AbstractSqlParser &#123;</span><br><span class="line">  val astBuilder &#x3D; new SparkSqlAstBuilder(conf)</span><br><span class="line">  private val substitutor &#x3D; new VariableSubstitution(conf)</span><br><span class="line">  protected override def parse[T](command: String)(toResult: SqlBaseParser &#x3D;&gt; T): T &#x3D; &#123;</span><br><span class="line">    super.parse(substitutor.substitute(command))(toResult)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用词法/语法规则解析原始 sql 为语法树的逻辑在 AbstractSqlParser#parse中，
[AbstractSqlParser.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override def parsePlan(sqlText: String): LogicalPlan &#x3D; parse(sqlText) &#123; parser &#x3D;&gt;</span><br><span class="line"> &#x2F;&#x2F; 第一步 : 使用子类的 parse方法来解析原始 sql 为语法树</span><br><span class="line"> &#x2F;&#x2F; 第二步: 使用子类定义的AstBuilder通过观察者模式访问语法树,转成 LogicPlan.</span><br><span class="line">  astBuilder.visitSingleStatement(parser.singleStatement()) match &#123;</span><br><span class="line">    case plan: LogicalPlan &#x3D;&gt; plan</span><br><span class="line">    case _ &#x3D;&gt;</span><br><span class="line">      val position &#x3D; Origin(None, None)</span><br><span class="line">      throw new ParseException(Option(sqlText), &quot;Unsupported SQL statement&quot;, position, position)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第一步: 使用 ANTLR 编译 SqlBase.g4 文件定义的词法/句法来解析原始 sql 为语法树<br>[AbstractSqlParser.scala]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  protected def parse[T](command: String)(toResult: SqlBaseParser &#x3D;&gt; T): T &#x3D; &#123;</span><br><span class="line">   &#x2F;&#x2F; 词法分析器</span><br><span class="line">    val lexer &#x3D; new SqlBaseLexer(new UpperCaseCharStream(CharStreams.fromString(command)))</span><br><span class="line">    &#x2F;&#x2F; 使用 SparkSQL 的词法错误流来替换 antlr 的</span><br><span class="line">    lexer.removeErrorListeners()</span><br><span class="line">    lexer.addErrorListener(ParseErrorListener)</span><br><span class="line">    val tokenStream &#x3D; new CommonTokenStream(lexer)</span><br><span class="line">    &#x2F;&#x2F; 语法分析器</span><br><span class="line">    val parser &#x3D; new SqlBaseParser(tokenStream)</span><br><span class="line">    parser.addParseListener(PostProcessor)</span><br><span class="line">    &#x2F;&#x2F; 使用 SparkSQL 的语法错误流来替换 antlr 的</span><br><span class="line">    parser.removeErrorListeners()</span><br><span class="line">    parser.addErrorListener(ParseErrorListener)</span><br><span class="line">    try &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">       &#x2F;&#x2F;SLL 和 LL 是 ANTLR对冲突和歧义的两种处理模式。SLL 速度快而功能弱,LL 相反</span><br><span class="line">        parser.getInterpreter.setPredictionMode(PredictionMode.SLL)</span><br><span class="line">        toResult(parser)</span><br><span class="line">      &#125;</span><br><span class="line">      catch &#123;</span><br><span class="line">        case e: ParseCancellationException &#x3D;&gt;</span><br><span class="line">          tokenStream.seek(0) </span><br><span class="line">          parser.reset()</span><br><span class="line">          parser.getInterpreter.setPredictionMode(PredictionMode.LL)</span><br><span class="line">          toResult(parser)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步: 使用 SparkSqlAstBuilder 来遍历语法树，生成为逻辑算子树<br>调用栈<br>-&gt; SparkSqlAstBuilder.visitSingleStatement<br>　-&gt;AstBuilder.visitSingleStatement<br>　　-&gt;AbstractParseTreeVisitor.visit<br>　　　-&gt;SingleStatementContext.accept<br>　　　　-&gt;SparkSqlAstBuilder.visitChildren 
  　　　　<br>引用SqlBase.g4 文件的查询规范<br>[SqlBase.g4]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">querySpecification</span><br><span class="line">    : (((SELECT kind&#x3D;TRANSFORM &#39;(&#39; namedExpressionSeq &#39;)&#39;</span><br><span class="line">        | kind&#x3D;MAP namedExpressionSeq</span><br><span class="line">        | kind&#x3D;REDUCE namedExpressionSeq))</span><br><span class="line">       inRowFormat&#x3D;rowFormat?</span><br><span class="line">       (RECORDWRITER recordWriter&#x3D;STRING)?</span><br><span class="line">       USING script&#x3D;STRING</span><br><span class="line">       (AS (identifierSeq | colTypeList | (&#39;(&#39; (identifierSeq | colTypeList) &#39;)&#39;)))?</span><br><span class="line">       outRowFormat&#x3D;rowFormat?</span><br><span class="line">       (RECORDREADER recordReader&#x3D;STRING)?</span><br><span class="line">       fromClause?</span><br><span class="line">       (WHERE where&#x3D;booleanExpression)?)</span><br><span class="line">    | ((kind&#x3D;SELECT (hints+&#x3D;hint)* setQuantifier? namedExpressionSeq fromClause?</span><br><span class="line">       | fromClause (kind&#x3D;SELECT setQuantifier? namedExpressionSeq)?)</span><br><span class="line">       lateralView*</span><br><span class="line">       (WHERE where&#x3D;booleanExpression)?</span><br><span class="line">       aggregation?</span><br><span class="line">       (HAVING having&#x3D;booleanExpression)?</span><br><span class="line">       windows?)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>引用一个最常用的查询语句的语法算子-&gt;逻辑计划算子的转换过程，最终得到的是一个逻辑计划对象       </p>
<p>[SparkSqlAstBuilder.scala]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> override def visitQuerySpecification(</span><br><span class="line">     ctx: QuerySpecificationContext): LogicalPlan &#x3D; withOrigin(ctx) &#123;</span><br><span class="line">     &#x2F;&#x2F; 第一步: 解析 from 语句，如果有多个表则转为内关联关系  </span><br><span class="line">   val from &#x3D; OneRowRelation.optional(ctx.fromClause) &#123;</span><br><span class="line">     visitFromClause(ctx.fromClause)</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 第二步: 基于 from 的语境来解析 select 语句关键词</span><br><span class="line">   withQuerySpecification(ctx, from)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> override def visitFromClause(ctx: FromClauseContext): LogicalPlan &#x3D; withOrigin(ctx) &#123;</span><br><span class="line">   val from &#x3D; ctx.relation.asScala.foldLeft(null: LogicalPlan) &#123; (left, relation) &#x3D;&gt;</span><br><span class="line">     val right &#x3D; plan(relation.relationPrimary)</span><br><span class="line">     val join &#x3D; right.optionalMap(left)(Join(_, _, Inner, None))</span><br><span class="line">     &#x2F;&#x2F; 做关联</span><br><span class="line">     withJoinRelations(join, relation)</span><br><span class="line">   &#125;</span><br><span class="line">   ctx.lateralView.asScala.foldLeft(from)(withGenerate)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;**</span><br><span class="line">  * Add a query specification to a logical plan. The query specification is the core of the logical</span><br><span class="line">  * plan, this is where sourcing (FROM clause), transforming (SELECT TRANSFORM&#x2F;MAP&#x2F;REDUCE),</span><br><span class="line">  * projection (SELECT), aggregation (GROUP BY ... HAVING ...) and filtering (WHERE) takes place.</span><br><span class="line">  *</span><br><span class="line">  * Note that query hints are ignored (both by the parser and the builder).</span><br><span class="line">  *&#x2F;</span><br><span class="line"> private def withQuerySpecification(</span><br><span class="line">     ctx: QuerySpecificationContext,</span><br><span class="line">     relation: LogicalPlan): LogicalPlan &#x3D; withOrigin(ctx) &#123;</span><br><span class="line">   import ctx._</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; WHERE</span><br><span class="line">   def filter(ctx: BooleanExpressionContext, plan: LogicalPlan): LogicalPlan &#x3D; &#123;</span><br><span class="line">     Filter(expression(ctx), plan)</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; Expressions.</span><br><span class="line">   val expressions &#x3D; Option(namedExpressionSeq).toSeq</span><br><span class="line">     .flatMap(_.namedExpression.asScala)</span><br><span class="line">     .map(typedVisit[Expression])</span><br><span class="line">   &#x2F;&#x2F; Create either a transform or a regular query.</span><br><span class="line">   val specType &#x3D; Option(kind).map(_.getType).getOrElse(SqlBaseParser.SELECT)</span><br><span class="line">   specType match &#123;</span><br><span class="line">     case SqlBaseParser.MAP | SqlBaseParser.REDUCE | SqlBaseParser.TRANSFORM &#x3D;&gt;</span><br><span class="line">       &#x2F;&#x2F; Transform</span><br><span class="line">       &#x2F;&#x2F; Add where.</span><br><span class="line">       val withFilter &#x3D; relation.optionalMap(where)(filter)</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Create the attributes.</span><br><span class="line">       val (attributes, schemaLess) &#x3D; if (colTypeList !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; Typed return columns.</span><br><span class="line">         (createSchema(colTypeList).toAttributes, false)</span><br><span class="line">       &#125; else if (identifierSeq !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; Untyped return columns.</span><br><span class="line">         val attrs &#x3D; visitIdentifierSeq(identifierSeq).map &#123; name &#x3D;&gt;</span><br><span class="line">           AttributeReference(name, StringType, nullable &#x3D; true)()</span><br><span class="line">         &#125;</span><br><span class="line">         (attrs, false)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         (Seq(AttributeReference(&quot;key&quot;, StringType)(),</span><br><span class="line">           AttributeReference(&quot;value&quot;, StringType)()), true)</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 一元关系节点  </span><br><span class="line">       ScriptTransformation(</span><br><span class="line">         expressions,</span><br><span class="line">         string(script),</span><br><span class="line">         attributes,</span><br><span class="line">         withFilter,</span><br><span class="line">         withScriptIOSchema(</span><br><span class="line">           ctx, inRowFormat, recordWriter, outRowFormat, recordReader, schemaLess))</span><br><span class="line"></span><br><span class="line">     case SqlBaseParser.SELECT &#x3D;&gt;</span><br><span class="line">       &#x2F;&#x2F; Regular select</span><br><span class="line">&#x2F;&#x2F; 解析 lateral 视图(lateral view UDTF as...),where 语句,groupBy,having,distinct 等</span><br><span class="line">       &#x2F;&#x2F; Add lateral views.</span><br><span class="line">       val withLateralView &#x3D; ctx.lateralView.asScala.foldLeft(relation)(withGenerate)</span><br><span class="line">       &#x2F;&#x2F; Add where.</span><br><span class="line">       val withFilter &#x3D; withLateralView.optionalMap(where)(filter)</span><br><span class="line">       &#x2F;&#x2F; Add aggregation or a project.</span><br><span class="line">       val namedExpressions &#x3D; expressions.map &#123;</span><br><span class="line">         case e: NamedExpression &#x3D;&gt; e</span><br><span class="line">         case e: Expression &#x3D;&gt; UnresolvedAlias(e)</span><br><span class="line">       &#125;</span><br><span class="line">       val withProject &#x3D; if (aggregation !&#x3D; null) &#123;</span><br><span class="line">         withAggregation(aggregation, namedExpressions, withFilter)</span><br><span class="line">       &#125; else if (namedExpressions.nonEmpty) &#123;</span><br><span class="line">         Project(namedExpressions, withFilter)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         withFilter</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Having</span><br><span class="line">       val withHaving &#x3D; withProject.optional(having) &#123;</span><br><span class="line">         &#x2F;&#x2F; Note that we add a cast to non-predicate expressions. If the expression itself is</span><br><span class="line">         &#x2F;&#x2F; already boolean, the optimizer will get rid of the unnecessary cast.</span><br><span class="line">         val predicate &#x3D; expression(having) match &#123;</span><br><span class="line">           case p: Predicate &#x3D;&gt; p</span><br><span class="line">           case e &#x3D;&gt; Cast(e, BooleanType)</span><br><span class="line">         &#125;</span><br><span class="line">         Filter(predicate, withProject)</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Distinct</span><br><span class="line">       val withDistinct &#x3D; if (setQuantifier() !&#x3D; null &amp;&amp; setQuantifier().DISTINCT() !&#x3D; null) &#123;</span><br><span class="line">         Distinct(withHaving)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         withHaving</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Window</span><br><span class="line">       val withWindow &#x3D; withDistinct.optionalMap(windows)(withWindows)</span><br><span class="line">       &#x2F;&#x2F; Hint</span><br><span class="line">       hints.asScala.foldRight(withWindow)(withHints)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>由 SparkSqlAstBuilder.scala 部分方法的返回值可知：Parser 模块的 SparkSqlParser 和 SparkSqlAstBuilder 将原始的 SQL 文本转换成了 UnResolved(Relation|Attribute|Funcation)等，但是从原始 SQL 文本解析来的Relation|Attribute|Funcation 是否存在如何解析调用均需要绑定和验证，e.g. SQL 文本中的表是 Hive Orc 表还是 JSON 文件，Funcation 代表了哪个函数 builtin 函数还是 UDF，Attribute 来自哪个基础表….  这些工作就是 Analyzer 模块的工作内容   </p>
<blockquote>
</blockquote>
<p>visitTable 方法的返回值是 UnresovedRelation<br>visitStar 方法的返回值是 UnresolvedStar<br>visitColumnReference 方法的返回值是 UnresolvedRegex 或 UnresolvedAttribute<br>visitFunctionCall 方法的返回值是 UnresolvedWindowExpression 或 WindowExpression<br>….</p>
]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
        <tag>源码解析</tag>
        <tag>Spark SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>基于队列优先级的小集群大容器资源抢占模式</title>
    <url>/2019-11-25-%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%B0%8F%E9%9B%86%E7%BE%A4%E5%A4%A7%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E6%8A%A2%E5%8D%A0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="抢占概述"><a href="#抢占概述" class="headerlink" title="抢占概述"></a>抢占概述</h2><p>　　Yarn 使用树状层级队列组织方式来管理资源，所有 NodeManager 持有的资源聚集作为资源根队列 root 来代表集群中所有可用资源<br>　　层级队列中除 root 外每个队列可以设置其拥有父队列的最低配额和最高配额。最高配额是队列无论在任何情况下都不会超出的资源量，最低配额一般理解为在队列保底资源量以快速响应请求，实际上是用来决定集群资源配比权重。为了提高集群整体的资源利用率，Yarn 引入了抢占机制:  </p>
<ol>
<li>在队列中无任务运行时，队列没有必要硬遵守保留最低配额，可以将资源借给负载较高的其他队列  </li>
<li>当借出资源的队列接收到了新提交的应用时，将出借的资源收回以满足本队列的资源需求  </li>
</ol>
<a id="more"></a>

<p>　　其中第一点由常规调度器来实现: 队列的实际配额基于自身和其他队列的需求动态变化 介于 0与最高配额之间，当队列无任何 APP 时资源出借给繁忙的队列 实际资源量为 0，当队列负载较大时可能借用其他空闲队列的资源但不会超过其最高配额。第二点由抢占调度来实现: 出借资源的队列接收了新的 APP 之后，需要从其他超出最低配额的队列(超分配队列)中抢占(回)资源，用以启动APP。从超分配队列中抢占资源时，基于“最小化对已启动应用程序的影响”原则，选择杀死 Container 释放资源时 优先杀死最新启动 App 的最新分配的 Container，优先杀死保留的 Container，优先杀死非 AM 角色的 Container  </p>
<h2 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h2><p>场景: 假设集群内有两个队列:A 和 B<br>　　状态 1: A完全空闲，B 负载很高，借用了 A 的全部资源<br>　　状态 2: A新提交了 AppX，且 AppX 申请的每个 Container 都很大，e.g. 60G<br>　　状态 3: 抢占调度从B 队列杀死了一些 Container，释放了一些资源(默认单次抢占资源总量不超过集群总资源的10%)，但这些资源分布在n个节点上<br>　　状态 4: 当这 n 个节点向 RM 汇报心跳时，常规调度尝试对每个队列(有序，负载低的优先，A先于 B)的每个应用程序(有序，早提交的优先)进行分配资源，如果这n 个节点都不能启动“大 Container”，那么当 A 没有得到资源时对 B 尝试分配， B 内的 App是可以得到资源的(杀死的就是 B 内 App 的 Container)<br>　　状态 5: A没有得到资源，依旧处于欠分配状态;B 得到了资源，处于超分配状态。抢占调度会再次从 B 抢占资源，杀死一些 Container。即”状态 3”  </p>
<p>造成的影响有四：    </p>
<ol>
<li>在抢占调度层面，一直在状态 3-&gt;4-&gt;5-&gt;3…循环执行，处于“A 欠分配，B 超分配“-&gt;”抢占调度释放 B 的资源”-&gt;”A 不能使用资源，B 能使用则分配给 B”-&gt;”A 欠分配，B 超分配”循环  </li>
<li>在资源队列层面，A 队列一直没有得到资源，且一直触发抢占; B 队列在抢占调度释放资源，在常规调度得到 A 队列无法利用的资源  </li>
<li>在应用程序层面，对于 A中的大 Container App，一直没有得到资源，处于等待状态;对于 B 中的 App，其部分 Container 一直处于”被抢占”-&gt;”可启动”-&gt;”启动(成为最新容器)”-&gt;”被抢占”-&gt;”可启动”…的循环状态  </li>
<li>从 SLA 和资源利用率角度来说，A 中的 App 没有迅速响应，B 中的 App 被拖慢了速度。有一部分资源被反复无效调度  </li>
</ol>
<blockquote>
</blockquote>
<p>Tips:  </p>
<ol>
<li>抢占调度是周期性执行的，默认 3 秒。  </li>
<li>抢占调度和常规调度是解耦的，常规调度负责为每个队列的每个 APP的每个 ResourceRequest 调度，抢占调度负责所有队列资源的平衡，不为某个具体的 App、具体的 Container 做调度    </li>
<li>抢占调度是”资源再平衡”的过程，空闲队列有了资源需求后，所有队列计算自身的理想容量，超分配的队列释放资源，欠分配的队列在常规调度模块优先分配资源  </li>
<li>集群内队列是平等的， A 队列可以抢 B， B 队列也可以抢 A。这对保证核心业务来说是不友好的，非核心业务可能会抢占核心业务的资源，拖慢核心业务  </li>
<li>“最小化对已启动应用程序的影响”是抢占调度的核心原则，具体表现在:<br>　　a. 每轮总抢占:默认 10%，单次抢占总资源量最多不能超过集群总资源量的 10%<br>　　b. 忽略抢占阈值(deadzone,死区): 默认 0.2，超分配队列只有在 used&gt;(1+0.2) * capacity 时，才会还回资源。e.g. capacity=100G， used=110G时则不在该队列抢占<br>　　c. 自然终止因子: 默认 20%，即使容器不被杀死，也有 95%概率在5 * 15s 内终止。所以每个超分配队列最多还回超分配部分的 20%。e.g. used=100G，ideal=40G，本轮抢占该队列最终归还量为(100-40) * 20%=12G
　　d. 确定了最终归还量之后，则从队列所有 APP 中选择一些容器杀死，杀死容器的总容量大于等于最终归还量。选择容器时的规则是:优先选择最新启动的 APP最近启动的容器，优先选择保留的容器(未启动)，优先选择非 AM 角色的容器<br>　　故自然终止因子决定了该轮抢占立即能得到的资源量，每轮总抢占决定了该轮抢占最多能得到的资源量  </li>
<li>保留:常规调度为什么不在 n 个节点上做保留?<br>在节点上为容器做分配/保留的限制条件有:<br>　　a. 队列具有该节点的 access 权限，节点不在 APP 设置的黑名单内<br>　　b. 节点上无保留且节点剩余空间大于最小容器大小(yarn.scheduler.minimum-allocation-mb)<br>　　c. 最高配额限制: 如果分配该容器，叶子队列及其所有父队列均不能超过各自的最高配额<br>　　d. 用户配额限制: 用户配额上限(headroom) 取值为 min{当前容量 * user_limit_factor，max{当前容量/活跃用户数，当前容量/最高用户数}}，当前容量取决于最低配额、当前尝试的ResourceRequest 、 Used 关系。一个用户在任何情况下，使用的配额不能高于队列最低配额*user_limit_factor<br>　　e. AM 限制:不超过队列 AM 限制(AM资源和AM数量限制)<br>主要限制在 c)和 d)。d)中 user_limit_factor 一般设置为 1，活跃用户数低于最高用户限制，则取值一般为当前容量/活跃用户数，当队列活跃用户越多，用户配额上限会越低  </li>
</ol>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><ol>
<li>建立业务优先级体系，为每个队列赋予业务优先级属性，优先级高的队列可以抢占低的队列，反之则不可。用以保证核心业务不被非核心业务抢占资源    </li>
<li>在计算每个队列应得的资源时，若队列预计得到的资源不足以满足队列中最小的 ResourceRequest，则抢占是无意义的，不为该队列做抢占，其预计得到的资源将被设置为 0，这些无法利用的资源将转给其他队列<br>按照对”大容器”的定义(e.g. 40G)，优先为”大容器”队列做抢占，然后为“普通容器“队列做抢占  </li>
<li>为”大容器”抢占时，在每个节点上选取待抢占队列的最新启动的 Application 的最新分配的部分容器释放且计算释放代价，最终选取释放代价最低的节点上的容器释放。若队列分配完”大容器” 或者待抢占量不高于”大容器” 定义，则后续将其作为”普通容器” 队列来处理  </li>
<li>为”普通容器”抢占时，选取待抢占队列中最新启动的 App 的最新 Container 开始释放    </li>
</ol>
<h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p><img src="/img/pictures/yarn_preempt/preemption_scheduler.png" alt=""></p>
<ol>
<li><p>获取各队列使用状态<br>　　包括: 队列的业务优先级，最低配额(capacity)，最高配额，当前使用量(used)，当前堆积需求量(pending)，最低需求量，最高需求量，初始理想容量(min{used,capacity})  </p>
</li>
<li><p>按优先级计算每个队列的理想容量<br>　　首先将所有队列划分为空闲队列(used&lt;=capacity)、超分配队列(used&gt;capacity)两类，并统计出欠分配队列(used+pending&gt;当前理想容量)。在保证弹性最低配额的条件下，将空闲队列的(capacity-used) 和超分配队列(used-capacity) 作为全局空闲量，按规则分配给欠分配队列:<br>　　a. 优先全局分配空闲资源给优先级高的欠分配队列，按优先级由高至低依次分配<br>　　b. 分配的资源量取决于 min{全局空闲量，需求量，(最高配额-当前理想容量)}，记为 increment<br>　　　即保证在不超过队列最高配额的情况下，从全局空闲量中优先满足高优先级队列的需求<br>　　c. 然后分配全局空闲资源给无优先级但配置有最低配额的欠分配队列，按照欠分配程度(当前理想配额/最低配额 值)由低到高依次分配<br>　　d. 分配的资源量取决于 min{全局空闲量 * 队列最低配额权重，需求量，(最高配额-当前理想容量)}，记为 increment<br>　　e. 最后分配全局空闲资源给无优先级无最配配额的欠分配队列，按照欠分配程度由低到高依次分配<br>　　f. 分配的资源量取决于 min{全局空闲量 * 队列平均权重，需求量，(最高配额-当前理想容量)}，记为 increment<br>　　g. 在全局空闲量为 0 或者没有欠分配队列时终止此环节<br>即: 抢占是一个再平衡的过程，资源从低优先级队列流向高优先级欠分配队列，从未配置最低配额的队列流向配置最低配额的队列，但是会保证有任务但被抢占资源队列的弹性最低配额(min{used+pending, capacity})  </p>
</li>
<li><p>判断各队列是否是有效抢占<br>　　判断各队列的 increment 值，若 increment &lt; minResourceRequest，即新得到的资源不足以启动任何一个容器，在将其从欠分配队列中删除  </p>
</li>
<li><p>设置其 pending 为 0<br>　　依据 used + pending = 当前容量， pending 设为 0 之后，不再是欠分配队列。  </p>
</li>
<li><p>再计算<br>　　重新计算抢占依据 (e.g. 高优先级队列抢占的资源无法启动队列中最小的一个容器时，将此资源按优先级再分给其他队列)     </p>
<p> 此处的表述有歧义，但是画图过于冗余，故而放到了一个循环中，其实是三个循环。第一个循环: 优先分配有优先级配置的队列，并判断其是否是有效抢占，若是无效抢占，则把其 increment 还回到全局空闲配额中，供次级流程(后续的低优先级队列，无优先级队列)使用。第二个循环是: 分配无优先级但有最低配额的队列，判断其是否是有效抢占，若是无效抢占，则把 increment 还回到全局空闲配额中，供后续流程使用(后续无优先级有最低配额的欠分配队列，无优先级无最低配额的欠分配队列)。第三个循环是: 无优先级无最低配额的欠分配队列。第一个循环在队列分配完成后立即判断是否是有效抢占，第二三个循环需要在所属循环分配完成后按累计 increment 由高至低分别判断，若有无效抢占立即重算除其之外的所有的队列的理想配额。      </p>
</li>
<li><p>计算出所有队列的待抢占量，并依据最小需求将所有欠分配队列划分为”大容器”和”普通容器”，分别进行抢占调度  </p>
</li>
<li><p>对于每个”大容器”队列，循环(8-&gt;11)抢占，每次抢占量为 maxResourceRequest(足以启动队列中任何一个容器)。直到没有 NM 满足，或者待抢占量低于”大容器”定义    </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">伪代码</span><br><span class="line">Map&lt;NodeId，QueueContainerDetail&gt; info;</span><br><span class="line">For(App: toPreemptedQueue)</span><br><span class="line">	addContainer&#123;runningContainer，reservedContainer&#125; -&gt; info(amContainers,nonAMContainers);</span><br><span class="line">Map&lt;TempQueue,Resource&gt; limit &#x3D; listQueuePreemptionLimit(); </span><br><span class="line">For( curQueue: allUnderReservedQueue) </span><br><span class="line">	maxRR&#x3D;curQueue.getMaxResourceRequest </span><br><span class="line">	totalPreeption&#x3D;curQueue.getTotalPreemption</span><br><span class="line">	while(totalPreeption&gt;maxRR )</span><br><span class="line">		minCostTime&#x3D;Long.MaxValue	</span><br><span class="line">		Map&lt;Queue，Container&gt; containers，NodeId &#x2F;&#x2F;在该节点上杀死这些容器为最小代价</span><br><span class="line">		for(nodeId: NodeId)</span><br><span class="line">			costTime &#x3D; tryPreemptFromNode(node,limit,maxRR)</span><br><span class="line">			if(costTime&lt;minCostTime)</span><br><span class="line">				minCostTime&#x3D;costTime; containers,nodeId REFRESH-&gt;POINTER</span><br><span class="line">		if(costTime &#x3D;&#x3D;Long.MaxValue)</span><br><span class="line">			LOG.warn(&quot;no node meet the request in this queue, do left totalPreemption as common preemption&quot;)</span><br><span class="line">	        else</span><br><span class="line">			totalPreemption -&#x3D; maxRR</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计每个待抢占队列的(App，Container)-&gt;(nm) 信息  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addContainer(TempQueue queue, RMContainer container)&#123;</span><br><span class="line">      ensureQueue(queue);</span><br><span class="line">      if(container.isAMContainer())&#123;</span><br><span class="line">        amContainers.get(queue).add(container);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        nonAMContainers.get(queue).add(container);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试在每个 NM 上抢占，并计算抢占代价<br>　　尝试使用nonAMContainers 来满足 maxResourceRequest；并维护相关信息，计算抢占代价 costTime=∑（curTime-contianer.getStartTime）<br>限制条件是:<br>　　a. 每个队列不超出自身待释放的资源<br>　　b. 在该节点上所有超分配队列释放的资源和节点空闲资源 可以满足 maxRR<br>QueueAppInfo 的核心数据结构和逻辑:<br>[QueueContainerDetail.java]  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NodeId nodeId;Clock clock;Long curTime;Long costTime;</span><br><span class="line">Map&lt;TempQueue, List&lt;RMContainer&gt;&gt; nonAMContainers;</span><br><span class="line">Map&lt;TempQueue, List&lt;RMContainer&gt;&gt; amContainers;</span><br><span class="line">&#x2F;&#x2F; 各队列 最终被抢占的 container 列表</span><br><span class="line">Map&lt;TempQueue, List&lt;RMContainer&gt;&gt; toBePreemptedContainers;</span><br><span class="line">&#x2F;&#x2F; 各队列 最终被抢占的资源量</span><br><span class="line">Map&lt;TempQueue, Resource&gt; toBePreemptedResource;</span><br><span class="line">&#x2F;**</span><br><span class="line">     * note: since to &quot;try preempt&quot;,</span><br><span class="line">     * the maxResourceRequest and preemptedLimitOfQueue are copied.</span><br><span class="line">     * @param maxResourceRequest  待抢占量 e.g. 40G</span><br><span class="line">     * @param preemptedLimit queueLimit A-&gt;30G, B-&gt;20G 抢占总量限制</span><br><span class="line">     *&#x2F;</span><br><span class="line">public long tryPreemptFromNode(Resource maxResourceRequest,</span><br><span class="line">                                   Map&lt;TempQueue, Resource&gt; preemptedLimit)&#123;</span><br><span class="line">      clearCache();</span><br><span class="line">      curTime&#x3D;clock.getTime();</span><br><span class="line">      Resource toPreempt&#x3D;Resources.clone(maxResourceRequest);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;TempQueue, List&lt;RMContainer&gt;&gt;&gt; it &#x3D;</span><br><span class="line">          nonAMContainers.entrySet().iterator();</span><br><span class="line">      while(Resources.greaterThan(rc, clusterResource,</span><br><span class="line">          toPreempt, Resources.none())&amp;&amp; it.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;TempQueue, List&lt;RMContainer&gt;&gt; entry &#x3D; it.next();</span><br><span class="line">        TempQueue currentQueue &#x3D; entry.getKey();</span><br><span class="line">        Resource limit &#x3D; Resources.clone(preemptedLimit.get(currentQueue));</span><br><span class="line">        if(Resources.greaterThan(rc, clusterResource,</span><br><span class="line">            limit, Resources.none()) &#x3D;&#x3D; false || currentQueue.preemptionDisabled)&#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;RMContainer&gt; containerList &#x3D; entry.getValue();</span><br><span class="line">        long sortStart &#x3D; clock.getTime();</span><br><span class="line">        Collections.sort(containerList, COMPARATOR_CONTAINER);</span><br><span class="line">        long sortEnd &#x3D; clock.getTime();</span><br><span class="line">        if(sortEnd - sortStart &gt;&#x3D; 100)&#123;</span><br><span class="line">          LOG.warn(&quot; Slow Sort nonAM Containers when trying preempt maxResourceRequest &#123;&#125; &quot; +</span><br><span class="line">                  &quot;at queue &#123;&#125; with queueLimit &#123;&#125; total &#123;&#125; container, token &#123;&#125;ms&quot;,</span><br><span class="line">              toPreempt,</span><br><span class="line">              currentQueue.getQueueName(),</span><br><span class="line">              limit,</span><br><span class="line">              containerList.size(),</span><br><span class="line">              sortEnd-sortStart);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;RMContainer&gt; iit&#x3D;containerList.iterator();</span><br><span class="line">        while(Resources.greaterThan(rc, clusterResource, limit, Resources.none()) &amp;&amp;</span><br><span class="line">            Resources.greaterThan(rc, clusterResource, toPreempt, Resources.none()) &amp;&amp;</span><br><span class="line">            iit.hasNext())&#123;</span><br><span class="line">          RMContainer i&#x3D;iit.next();</span><br><span class="line">          if(isLabelContainer(i))&#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">          toBePreemptedContainers.get(currentQueue).add(i);</span><br><span class="line">          Resources.addTo(toBePreemptedResource.get(currentQueue),</span><br><span class="line">              i.getContainer().getResource());</span><br><span class="line">          Resources.subtractFrom(limit, i.getContainer().getResource());</span><br><span class="line">          Resources.subtractFrom(toPreempt, i.getContainer().getResource());</span><br><span class="line">          costTime +&#x3D; (curTime - i.getCreationTime());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 暂不抢占 AM,代价不可控 难维护</span><br><span class="line">      if(Resources.greaterThan(rc, clusterResource,</span><br><span class="line">          toPreempt, Resources.none()))&#123;</span><br><span class="line">        costTime &#x3D; Long.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      return costTime;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preemptFromNode()&#123;</span><br><span class="line">      for(Map.Entry&lt;TempQueue, List&lt;RMContainer&gt;&gt; entry :</span><br><span class="line">          toBePreemptedContainers.entrySet())&#123;</span><br><span class="line">        nonAMContainers.get(entry.getKey()).removeAll(entry.getValue());</span><br><span class="line">        amContainers.get(entry.getKey()).removeAll(entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>选取抢占代价最低的节点，记录相应 container 集合<br>　　获取在所有 NM 中，costTime 最低的 Container 集合作为待抢占容器      </p>
</li>
<li><p>若当前队列的待抢占量小于”大容器”定义，则剩余资源作为”普通容器抢占”   </p>
</li>
<li><p>在抢占代价最低的节点上，释放了总资源量不低于 maxResourceRequest 的 Container 集合  </p>
</li>
<li><p>为所有”普通容器”做抢占:在待抢占的队列中杀死最新启动的容器(不存在于 步骤10 中) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Resource toPreempted;</span><br><span class="line">For(Queue : overReservedQueue)</span><br><span class="line">		For(App: Queue.getApps)</span><br><span class="line">			if(toPreempted &lt;&#x3D; none) break;</span><br><span class="line">			killReservedContainer(App， toPreempted); </span><br><span class="line">			killAllocatedContainerByOrder(App， toPreempted);</span><br><span class="line">			rememberAM();</span><br><span class="line">if(toPreempted &gt; none)</span><br><span class="line">		killAMByOrder();</span><br><span class="line">	&#96;&#96;&#96;		</span><br><span class="line"></span><br><span class="line">## 优点缺点</span><br><span class="line"></span><br><span class="line">### 优点</span><br><span class="line"></span><br><span class="line">1. 在集群负载高的时候，可以保证优先级高的业务有资源执行;低优先级队列不能抢占高优先级队列的任务.(开源实现 不能保证)  </span><br><span class="line">2. 可以在节点上启动大容器 (开源实现 不能保证)  </span><br><span class="line">3. 可以避免无效抢占 (开源实现 不能保证)  </span><br><span class="line"></span><br><span class="line">### 缺点</span><br><span class="line">1. 集群负载高时，低优先级长时任务可能被无限拉长  </span><br><span class="line">2. 在节点上选取最新启动的容器抢占，而不是在全局选择最新启动的容器抢占，导致任务恢复无效工作量增加  </span><br><span class="line">3. 大容器调度时，增加了节点的资源利用率波动  </span><br><span class="line"></span><br><span class="line">## 抢占调度(开源抢占详解)</span><br><span class="line">抢占调度是周期性的，每周期抢占调度执行的策略分三步:  </span><br><span class="line"></span><br><span class="line">1.	获取所有队列的快照  </span><br><span class="line">2.	计算所有队列的理想容量，作为抢占依据  </span><br><span class="line">3.	从超分配队列中，计算最终抢占量，并选取部分容器释放容量  </span><br><span class="line">其中最重要的是第2步，这一步决定着:队列是否释放资源及释放多少资源  </span><br><span class="line"></span><br><span class="line">### 获取所有队列的快照</span><br><span class="line"></span><br><span class="line">获取信息:  </span><br><span class="line">　　队列用量 used; 队列堆积需求 pending; 队列最低配额 capacity ;队列最高配额额 maxCapacity; 队列是否允许抢占 preemptionDisabled; 子队列 children   </span><br><span class="line">初始化信息:  </span><br><span class="line">　　理想容量 idealAssigned; 超出配额容量 toBePreempted; 最终被抢占容量 actuallyPreempted; 权重normalizedGrarantee</span><br><span class="line"></span><br><span class="line">### 计算所有队列的理想容量，作为抢占依据</span><br><span class="line">　　设置 root 队列的理想容量为 100%，递归向下按层计算 每个子队列的理想容量，子队列的子队列理想容量，直至叶子队列。每轮递归通用逻辑是:依据当前队列的理想容量和所有子队列快照信息，计算每个子队列的理想容量。  </span><br><span class="line">a.  划分子队列类型  </span><br><span class="line">　　对于递归过程中，当前队列的所有子队列按照”是否配置了最低配额”划分为两类:第一类，配置最低配额的子队列集合;第二类，未配置最低配额的子队列集合。区别在于:第一类要优先于第二类得到资源，满足了第一类子队列需求之后如果还有空闲资源才会分配给第二类子队列；第一类子队列在分享当前队列的配额时，之间是以最低配额为权重的，第二类由于没有配置最低配额，之间是平均分配的  </span><br><span class="line">b. 优先分配 配置了最低配额的子队列  </span><br><span class="line">　　b1. 设定初始理想配额  </span><br><span class="line">　　　　这一过程的主要逻辑是: 为所有子队列设定动态初始理想配额，并计算出当前队列的空闲配额，记录欠分配子队列。  </span><br><span class="line">　　　　初始配额设定:   </span><br><span class="line">　　　　　　若 used&lt;&#x3D;capacity，则idealAssigned&#x3D;used。将(capacity-used) 作为空闲资源     </span><br><span class="line">　　　　　　若 used&gt;capacity，则ideaAssigned&#x3D;capacity。将(used-capacity) 作为空闲资源拿出来再分配     </span><br><span class="line">　　　　计算当前队列的空闲配额:  </span><br><span class="line">　　　　　　将 上述两种空闲资源之和作为队列全局空闲资源，交由欠分配子队列 再分配  </span><br><span class="line">　　　　记录欠分配子队列:  </span><br><span class="line">　　　　　　若子队列 used+pending &gt; idealAssigned，即需求量大于容量 为欠分配子队列。  </span><br><span class="line">　　b2. 再分配过程  </span><br><span class="line">　　　　目的: 按照 b1 记录的信息，将全局空闲资源，按照分配给所有的欠分配子队列。    </span><br><span class="line">　　　　方式: 以循环的方式，每轮循环为最欠分配的队列(most under served queue)分配资源。最欠分配的队列在得到资源后，欠分配程度排名可能会变化。因此这种分配方式会使各子队列资源量比值最终趋近于”最低配额”比值。”资源再平衡”的说法来源于此。  </span><br><span class="line">　　　　权重: 每个子队列在欠分配子队列集合中获取资源的权重是 capacity&#x2F;∑capacity，存储在队列快照中的 normalizedGrarantee字段  </span><br><span class="line">　　　　变量: 全局空闲资源，欠分配子队列，子队列减少导致的分配权重增大  </span><br><span class="line">　　　　增量: 循环为最欠分配的队列分配资源，每次分配的增量为min&#123;全局空闲资源 * 权重，需求量，最高配额-当前理想配额&#125;  </span><br><span class="line">　　　　　　全局空闲资源 * 权重: 表示在该轮循环 能得到的资源  </span><br><span class="line">　　　　　　需求量:used+pending-idealAssigned，表示这些资源可以满足队列的需求  </span><br><span class="line">　　　　　　最高配额-当前理想配额: 表示在任何情况下，队列配额都不能超过最高配额  </span><br><span class="line">　　　　增量最终会增加到理想配额idealAssigned。在全局空闲资源为 0 或者无任何欠分配队列时，idealAssigned 会作为队列最终的理想配额  </span><br><span class="line"></span><br><span class="line">核心源码如下:</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>orderedByNeed : 所有欠分配队列</li>
<li>unassigned: 全局空闲资源</li>
<li>/
while (!orderedByNeed.isEmpty()
&amp;&amp; Resources.greaterThan(rc，tot_guarant， unassigned，Resources.none())) {
Resource wQassigned = Resource.newInstance(0， 0);
/ *</li>
<li>设置orderedByNeed中所有队列的权重</li>
<li>配置最低配额: capacity/sum(capacity)</li>
<li>未配置最低配额: 1/orderedByNeed.size()</li>
<li>/
resetCapacity(rc， unassigned， orderedByNeed， ignoreGuarantee);
/ **</li>
<li>最欠分配的队列( most under served queue )</li>
<li>比较 idealAssigned/capacity 值</li>
<li>/
Collection<TempQueue> underserved =
 getMostUnderservedQueues(orderedByNeed， tqComparator);
for (Iterator<TempQueue> i = underserved.iterator(); i.hasNext();) {
TempQueue sub = i.next();
//全局空闲资源<em>权重
Resource wQavail = Resources.multiplyAndNormalizeUp(rc，
   unassigned， sub.normalizedGuarantee， Resource.newInstance(1， 1));
//三元组{全局空闲资源</em>权重，used+pending-idealAssigned，maxCapacity-idealAssigned}
Resource wQidle = sub.offer(wQavail， rc， tot_guarant);
//增量
Resource wQdone = Resources.subtract(wQavail， wQidle);
if (Resources.greaterThan(rc， tot_guarant，<pre><code>wQdone， Resources.none())) {</code></pre> //如果这个队列在这轮得到了资源，那么下一轮也可能得到资源，所以加入到原集合中;直到没有得到资源
 orderedByNeed.add(sub);
}
Resources.addTo(wQassigned， wQdone);
}
//修改全局空闲资源
Resources.subtractFrom(unassigned， wQassigned);
}<pre><code>c. 最后分配 未配置最低配额的子队列  
　　如果在满足了”配置最低配额的子队列“的所有需求之后，还有剩余配额，则平均分配到所有”未配置最低配额的子队列”中。    
　　除权重外，和 b 完全一致。  
　　　　权重:子队列集合中每个子队列都会平均分配全局空闲资源(区别于 按最低配额做权重)  
d. 规整队列待抢占量
　　汇总所有叶子队列的超出配额(used-idealAssigned)之和，如果此值超出“每轮总抢占“(默认集群总资源的 10%)，则按比例减少每个叶子队列的待抢占量 以保证每轮抢占的总资源量不超过”每轮总抢占”。
</code></pre></li>
</ul>
</li>
</ol>
<h3 id="从超分配队列中，计算最终待抢占量，并选取部分容器释放容量"><a href="#从超分配队列中，计算最终待抢占量，并选取部分容器释放容量" class="headerlink" title="从超分配队列中，计算最终待抢占量，并选取部分容器释放容量"></a>从超分配队列中，计算最终待抢占量，并选取部分容器释放容量</h3><ol>
<li>判断超分配队列<br>　　若 used&gt;capacity*(1+maxIgnoredOverCapacity)，则判断为超分配队列，该队列需要释放资源。<br>　　其中 maxIgnoredOverCapacity 表示 忽略抢占阈值，默认 0.2。 参考“Tips-5”  </li>
<li>计算最终抢占量<br>　　最终抢占量 actuallyPreempted=toBePreempted * naturalTerminationFactor。<br>　　其中naturalTerminationFactor表示 自然终止因子，默认 0.2。toBePreempt=used-idealAssigned。参考”Tips-5”  </li>
<li>选取容器<br>　　选取总大小不小于actuallyPreempted的一些容器，释放掉<br>　　选取规则如下:<br>　　　　优先选择队列中后启动的 APP<br>　　　　优先选择 APP 的保留容器<br>　　　　优先选择 APP 后启动的容器<br>　　如果以上普通容器全部选取完之后无法还回等量actuallyPreempted的资源，则开始选取AM 角色的容器，优先选取后启动的 AM容器  </li>
</ol>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>　　对于选取的、将要被抢占的所有容器，将&lt;容器，时间&gt;加入到一个全局的集合中追踪，考虑到自然终止的情况，如果集合中的容器存活时间超过 5 * 15s，则直接杀死。  </p>
]]></content>
      <tags>
        <tag>Yarn 2.7.3</tag>
        <tag>Yarn PreemptionSystem</tag>
        <tag>Yarn large container</tag>
      </tags>
  </entry>
  <entry>
    <title>Improved MapPartitions In Spark</title>
    <url>/2019-11-22-Improved%20MapPartitions%20In%20Spark/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>map 和 mapPartitions 是 Spark 中最常用的 ETL 算子，用于将数据映射为另一批数据。区别在于,  </p>
<ol>
<li>数据粒度: map 输入和输出数据都是单条记录，严格的一对一关系。mapPartitions 输入和输出数据都是一个分区的数据迭代器, n 对 m 关系。  </li>
<li>功能: mapPartitions 功能远强于 map,其一 mapPartitions 可以在映射过程中做诸如过滤的额外操作，其二在需要创建重量级对象(e.g. 数据库连接)的场景下 mapPartitions 比 map 操作更合适。 </li>
<li>性能: 性能上无明显差异。一般将分区输出数据先存储在内存数据结构中,结束后转成迭代器形式。在内存中存储数据这种方式可能会导致 OOM，但是有方法避免，这是本文的价值点。     </li>
</ol>
<a id="more"></a>

<p>foreach 和 foreachPartition 的关系/用法类似 map 和mapPartitions,区别在 foreach(Partition)是 action 算子而 map(Partitions)是 transformer 算子。  </p>
<h2 id="mapPartitions-一般用法"><a href="#mapPartitions-一般用法" class="headerlink" title="mapPartitions 一般用法"></a>mapPartitions 一般用法</h2><p>mapPartitions[V] 的输入参数是 f:(Iterator[U]=&gt;Iterator[V]) 使RDD[U]映射为 RDD[V]<br>一般用法是在每个分区内维护一个内存数据结构 暂存输出数据，使用输入数据迭代器遍历输入数据处理得到输出数据加入到内存数据结构中，处理完毕后将内存数据结构转换为输出数据迭代器。   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val rdd:RDD[Int] &#x3D; ?</span><br><span class="line">rdd.mapPartitions(it&#x3D;&gt;&#123;</span><br><span class="line">      val buffer &#x3D; new ArrayBuffer[Int](64)</span><br><span class="line">      while(it.hasNext)&#123;</span><br><span class="line">        val next &#x3D; it.next()</span><br><span class="line">        if(???)&#123;</span><br><span class="line">          buffer.+&#x3D;(doSomething(next))</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          &#x2F;&#x2F; abort</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      buffer.iterator</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>优点在于使用简便，缺点在于内存数据结构在数据量大时容易 OOM。  </p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用 Spark 向数据库(mongodb)中写入数据时有量级不小的错误，需要将存储失败的数据另存。  </p>
<p>难点:   </p>
<ol>
<li>数据库的并发度支持不高,且其他业务也需要占用部分连接。所以最终 RDD 的分区数不能太大，进而导致单分区内数据很大。     </li>
<li>单分区内数据很大，插入数据库的失败数据也很多，需要将失败数据转存到其他存储。大量失败数据维护在内存中容易导致 OOM。  </li>
</ol>
<h2 id="improved-mapPartitions-1"><a href="#improved-mapPartitions-1" class="headerlink" title="improved mapPartitions 1"></a>improved mapPartitions 1</h2><p>切入点在于 mapPartitions 参数是一个 迭代器向迭代器的映射函数<br>以下代码为伪代码，仅作为模板使用   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * record by record 式的处理输入数据。</span><br><span class="line">  * @param srcDataIterator 输入数据迭代器</span><br><span class="line">  * @tparam T</span><br><span class="line">  *&#x2F;</span><br><span class="line">class TransformSaveDataIterator[T](srcDataIterator:Iterator[T]) extends Iterator[(T,Boolean)]&#123;</span><br><span class="line"> &#x2F;&#x2F; 重量级对象最好在类内部维护，避免 driver-&gt;executor 序列化问题</span><br><span class="line">  lazy val connection &#x3D; createOrGetFromPoll()</span><br><span class="line">  override def hasNext: Boolean &#x3D; &#123;</span><br><span class="line">    if(srcDataIterator.hasNext)&#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      closeResource()</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override def next(): (T, Boolean) &#x3D; &#123;</span><br><span class="line">    val next:T &#x3D; srcDataIterator.next()</span><br><span class="line">    val result:Boolean &#x3D; connectResource.doSave()  &#x2F;&#x2F; try &#123;doSomething;return true&#125; catch &#123;return false&#125;</span><br><span class="line">    (next, result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private def closeResource(): Unit &#x3D;&#123;</span><br><span class="line">    if(connectResource !&#x3D; null &amp;&amp; connectResource.isActive())&#123;</span><br><span class="line">      connectResource.commit()</span><br><span class="line">      connectResource.close()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点在于解决了 OOM 问题，缺点在于需要 record by record 式处理数据，效率低下对于支持 batch 的数据库而言未能充分利用   </p>
<h2 id="improved-mapPartitions-2"><a href="#improved-mapPartitions-2" class="headerlink" title="improved mapPartitions 2"></a>improved mapPartitions 2</h2><p>切入点借鉴 Spark Streaming 的 mini-batch，将输入数据的迭代器 slice 为多个，每个 slice 整批插入数据库中以利用 batch 功能并同时保存 slice 迭代器和事务执行结果。记录下所有输入数据的数量，当返回数据数量不大于该值时 可返回数据。每个 slice 内迭代器数据迭代完之后，切换为下一个迭代器直到返回数据量等于输入数据总量。<br>以下代码为伪代码，仅作为模板使用 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * buffer 式处理输入数据</span><br><span class="line">  * @param srcDataIterator 输入数据迭代器</span><br><span class="line">  * @tparam T</span><br><span class="line">  *&#x2F;</span><br><span class="line">class TransformBufferedSaveIterator[T](srcDataIterator:Iterator[T]) extends Iterator[(T,Boolean)]&#123;</span><br><span class="line">  lazy val connection &#x3D; createOrGetFromPoll()</span><br><span class="line">  val BUFFER_SIZE &#x3D; 2048</span><br><span class="line">  lazy val buffer:ArrayBuffer[(Iterator[T],Boolean)] &#x3D; new ArrayBuffer[(Iterator[T],Boolean)](128)</span><br><span class="line">  var dataCnt:Int &#x3D; 0  &#x2F;&#x2F; total input data count</span><br><span class="line">  var returnedCnt:Int &#x3D; 0  &#x2F;&#x2F; already returned data count</span><br><span class="line">  val trigger &#x3D; new AtomicBoolean(true)</span><br><span class="line">  var bufferIterator:Iterator[(Iterator[T],Boolean)] &#x3D; null</span><br><span class="line">  var curIterator:(Iterator[T],Boolean) &#x3D; null</span><br><span class="line"></span><br><span class="line">  override def hasNext: Boolean &#x3D; &#123;</span><br><span class="line">    if(trigger.get())&#123;</span><br><span class="line">      while(dataCnt &lt; srcDataIterator.length)&#123;</span><br><span class="line">        val slice:Iterator[T] &#x3D; srcDataIterator.slice(dataCnt, dataCnt+BUFFER_SIZE)</span><br><span class="line">        dataCnt +&#x3D;slice.length</span><br><span class="line">        val result:Boolean &#x3D; doSave(slice)</span><br><span class="line">        &#x2F;&#x2F; new iterator or reverse iterator</span><br><span class="line">        val traversableSlice &#x3D; slice.slice(0, BUFFER_SIZE)</span><br><span class="line">        buffer.+&#x3D;:((traversableSlice,result))</span><br><span class="line">      &#125;</span><br><span class="line">      closeResource()</span><br><span class="line">      bufferIterator &#x3D; buffer.iterator</span><br><span class="line">      trigger.set(false)</span><br><span class="line">    &#125;</span><br><span class="line">    returnedCnt &lt; dataCnt</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override def next(): (T, Boolean) &#x3D; &#123;</span><br><span class="line">    if(curIterator!&#x3D;null &amp;&amp; curIterator._1.hasNext)&#123;</span><br><span class="line">      dataCnt +&#x3D; 1</span><br><span class="line">      return (curIterator._1.next(),curIterator._2)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">     &#x2F;&#x2F; bufferIterator 最后一个 iterator 不会调用 next(此时hasNext()&#x3D;false)</span><br><span class="line">      curIterator &#x3D; bufferIterator.next()</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def doSave(it:Iterator[T]): Boolean &#x3D;&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      doSomething()</span><br><span class="line">      connectResource.commit()</span><br><span class="line">      buffer.clear()</span><br><span class="line">      return true</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">      case e:Exception &#x3D;&gt;&#123;</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private def closeResource(): Unit &#x3D;&#123;</span><br><span class="line">    if(connectResource !&#x3D; null &amp;&amp; connectResource.isActive())&#123;</span><br><span class="line">      connectResource.commit()</span><br><span class="line">      connectResource.close()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleTestCase"><a href="#SimpleTestCase" class="headerlink" title="SimpleTestCase"></a>SimpleTestCase</h2><p>分别使用 improved mapPartitions 1 和 improved mapPartitions 2 做测试样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object ImprovedMapPartition &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit &#x3D; &#123;</span><br><span class="line">    val spark &#x3D; SparkSession.builder().appName(&quot;&quot;).master(&quot;&quot;).config(&quot;&quot;,&quot;&quot;).getOrCreate();</span><br><span class="line">    val sparkContext &#x3D; spark.sparkContext</span><br><span class="line">    val rdd:RDD[Int] &#x3D; sparkContext.parallelize(1 to 20,3)</span><br><span class="line">    &#x2F;&#x2F; save record by record</span><br><span class="line">    val resultRDD &#x3D; rdd.mapPartitions(it&#x3D;&gt;&#123;</span><br><span class="line">      new TransformSaveDataIterator[Int](it)</span><br><span class="line">    &#125;)</span><br><span class="line">      resultRDD.cache()</span><br><span class="line">    resultRDD.filter(_._2 &#x3D;&#x3D; false) &#x2F;&#x2F; exception data</span><br><span class="line">      .saveAsTextFile(&quot;....&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; save buffered records</span><br><span class="line">    print(&quot;finally save records: &quot;+ resultRDD.filter(_._2).count())</span><br><span class="line">    val resultRDD2 &#x3D; rdd.mapPartitions(it&#x3D;&gt;&#123;</span><br><span class="line">      new TransformBufferedSaveIterator[Int](it)</span><br><span class="line">    &#125;)</span><br><span class="line">      resultRDD2.cache()</span><br><span class="line">    resultRDD2.filter(_._2 &#x3D;&#x3D; false)</span><br><span class="line">        .saveAsTextFile(&quot;....&quot;)</span><br><span class="line">    print(&quot;finally save records: &quot;+ resultRDD.filter(_._2).count())</span><br><span class="line"></span><br><span class="line">    resultRDD.unpersist()</span><br><span class="line">    resultRDD2.unpersist()</span><br><span class="line">    spark.stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark On Yarn 任务退出码</title>
    <url>/2019-11-18-SparkOnYarn%20%E4%BB%BB%E5%8A%A1%E9%80%80%E5%87%BA%E7%A0%81/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SparkOnYarn 程序的退出码种类比较繁多逻辑杂乱，主要包括：   </p>
<ol>
<li>Yarn 退出码      </li>
<li>Spark 退出码    </li>
<li>JVM 退出码   </li>
</ol>
<p>其中一些退出码可能是多个环节共同作用最终展现到日志上，e.g. SparkOnYarn 程序封装 driver/executor 的 ContainerLauchContext 时启动命令时加入”-XX:OnOutOfMemoryError=kill %p”，所以当程序 OOM 使用默认 signal(15) 终止 Container 脚本启动的 JVM，上报到 SparkOnYarn 日志的退出码是 143(128+15)。 </p>
<a id="more"></a>

<p>以下均基于 Hadoop2.7.3，Spark 2.3-SNAPSHOT，jdk1.8 </p>
<h2 id="Yarn-退出码"><a href="#Yarn-退出码" class="headerlink" title="Yarn 退出码"></a>Yarn 退出码</h2><p>Yarn container 的退出码分为两类: container-executor 和 container。container 是 Yarn 资源调度的基础，也是资源隔离的基础，在同一台服务器上运行的多个container 之间内存、CPU和权限等方面不应该相互影响(实际上内存和 CPU 没有做到绝对的资源隔离,仅仅监控内存/不管 CPU,在此不细说)。container-executor 负责使用 Yarn 参考 ContainerLaunchContext 上下文环境组装的脚本 初始化、启动和终止 Container，因此其错误码体系更像是操作系统的进程退出码。container-executor 共分两类: 通用的 DefaultContainerExecutor，所有的 Container 的用户均为启动 NodeManager 的用户；LinuxContainerExecutor，每个 Container 进程可以由不同用户启动，并支持 CGROUP 和 ACL。container 错误码体系适用于所有容器，是 Yarn 框架的一部分，应用程序错误码体系的补充。即 container-executor 错误码体系更靠近操作系统，container 错误码体系更靠近应用程序。  </p>
<h3 id="container-executor"><a href="#container-executor" class="headerlink" title="container-executor"></a>container-executor</h3><p>仅列出 LinuxContainerExecutor 错误码体系  </p>
<table>
<thead>
<tr>
<th align="left">错误码</th>
<th align="left">错误信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">INVALID_ARGUMENT_NUMBER</td>
<td align="left">1.启动脚本给定输入参数数量不符 2.未能成功初始化</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">INVALID_USER_NAME</td>
<td align="left">启动脚本所属用户不存在</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">INVALID_COMMAND_PROVIDED</td>
<td align="left">无法识别被提供的启动命令</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SUPER_USER_NOT_ALLOWED_TO_RUN_TASKS</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">INVALID_NM_ROOT_DIRS</td>
<td align="left">启动脚本参数定义的 NM root 目录不存在</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">SETUID_OPER_FAILED</td>
<td align="left">无法设置 UID 或 GID</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">UNABLE_TO_EXECUTE_CONTAINER_SCRIPT</td>
<td align="left">无法运行启动脚本</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">UNABLE_TO_SIGNAL_CONTAINER</td>
<td align="left">无法向指定容器发送信号</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">INVALID_CONTAINER_PID</td>
<td align="left">设置的启动命令 PID 不大于 0或不合法</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">ERROR_RESOLVING_FILE_PATH</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">RELATIVE_PATH_COMPONENTS_IN_FILE_PATH</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">UNABLE_TO_STAT_FILE</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">FILE_NOT_OWNED_BY_ROOT</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">PREPARE_CONTAINER_DIRECTORIES_FAILED</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">INITIALIZE_CONTAINER_FAILED</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">PREPARE_CONTAINER_LOGS_FAILED</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">INVALID_LOG_DIR</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">OUT_OF_MEMORY</td>
<td align="left">启动命令未能获得足够的内存</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">INITIALIZE_DISTCACHEFILE_FAILED</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">INITIALIZE_USER_FAILED</td>
<td align="left">无法获取用户的 NM 目录</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">UNABLE_TO_BUILD_PATH</td>
<td align="left">启动脚本创建路径失败</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">INVALID_CONTAINER_EXEC_PERMISSIONS</td>
<td align="left">启动脚本没有设置正确的执行权限</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">PREPARE_JOB_LOGS_FAILED</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">INVALID_CONFIG_FILE</td>
<td align="left">container-executor.cfg文件不存在或者权限不正确</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">SETSID_OPER_FAILED</td>
<td align="left">设置容器的 SID(sessionId?)失败</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">WRITE_PIDFILE_FAILED</td>
<td align="left">无法将 PID 写入 PID 文件</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">WRITE_CGROUP_FAILED</td>
<td align="left">无法写入CGROUP 信息(/sys/fs/cgroup ?)</td>
</tr>
<tr>
<td align="left">其他</td>
<td align="left">UNKNOWN_ERROR</td>
<td align="left">需要依据错误信息具体分析</td>
</tr>
</tbody></table>
<p>以上主要参考 hadoop-project/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server-nodemanager/src/main/native/container-executor/impl/container-executor.h   </p>
<h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>LinuxContainerExecutor 和 DefaultContainerExecutor 通用的错误码体系，Yarn 框架的一部分，可作为应用程序错误码的补充。  </p>
<table>
<thead>
<tr>
<th align="left">错误码</th>
<th align="left">错误信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">SUCCESS</td>
<td align="left">容器成功退出</td>
</tr>
<tr>
<td align="left">-1000</td>
<td align="left">INVALID</td>
<td align="left">容器退出码的初始值</td>
</tr>
<tr>
<td align="left">-100</td>
<td align="left">ABORTED</td>
<td align="left">容器被框架杀死,可能是 app 释放容器或 nm 失败丢失容器导致</td>
</tr>
<tr>
<td align="left">-101</td>
<td align="left">DISKS_FAILED</td>
<td align="left">NM 本地目录数量超过阈值</td>
</tr>
<tr>
<td align="left">-102</td>
<td align="left">PREEMPTED</td>
<td align="left">容器被抢占</td>
</tr>
<tr>
<td align="left">-103</td>
<td align="left">KILLED_EXCEEDED_VMEM</td>
<td align="left">虚拟内存超限被杀</td>
</tr>
<tr>
<td align="left">-104</td>
<td align="left">KILLED_EXCEEDED_PMEM</td>
<td align="left">物理内存超限被杀</td>
</tr>
<tr>
<td align="left">-105</td>
<td align="left">KILLED_BY_APPMASTER</td>
<td align="left">被 am 请求终止</td>
</tr>
<tr>
<td align="left">-106</td>
<td align="left">KILLED_BY_RESOURCEMANAGER</td>
<td align="left">被 rm 请求终止</td>
</tr>
<tr>
<td align="left">-107</td>
<td align="left">KILLED_AFTER_APP_COMPLETION</td>
<td align="left">app 完成后被杀死</td>
</tr>
</tbody></table>
<p>以上主要参考 org.apache.hadoop.yarn.api.records.ContainerExitStatus.java  </p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>通用的 Yarn Application 状态码定义  </p>
<table>
<thead>
<tr>
<th align="left">错误码</th>
<th align="left">错误信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">UNDEFINED</td>
<td align="left">APP 未完成时的状态码(初始值)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SUCCEEDED</td>
<td align="left">APP 成功完成</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">FAILED</td>
<td align="left">APP 失败</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">KILLED</td>
<td align="left">APP 被提交用户或者管理员用户终止</td>
</tr>
</tbody></table>
<p>以上参考 org.apache.hadoop.yarn.api.records.FinalApplicationStatus.java  </p>
<h2 id="Spark-退出码"><a href="#Spark-退出码" class="headerlink" title="Spark 退出码"></a>Spark 退出码</h2><h3 id="Executor-退出码"><a href="#Executor-退出码" class="headerlink" title="Executor 退出码"></a>Executor 退出码</h3><table>
<thead>
<tr>
<th align="left">错误码</th>
<th align="left">错误信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">50</td>
<td align="left">UNCAUGHT_EXCEPTION</td>
<td align="left">触发了默认的异常处理器(?)</td>
</tr>
<tr>
<td align="left">51</td>
<td align="left">UNCAUGHT_EXCEPTION_TWICE</td>
<td align="left">触发了默认的异常处理器,并在记录异常时触发了新的异常(?)</td>
</tr>
<tr>
<td align="left">52</td>
<td align="left">OOM</td>
<td align="left">触发了默认的异常处理器,且异常是 OutOfMemoryError</td>
</tr>
<tr>
<td align="left">53</td>
<td align="left">DISK_STORE_FAILED_TO_CREATE_DIR</td>
<td align="left">DiskStore 未能创建本地临时目录</td>
</tr>
<tr>
<td align="left">54</td>
<td align="left">EXTERNAL_BLOCK_STORE_FAILED_TO_INITIALIZE</td>
<td align="left">ExternalBlockStore 未能初始化</td>
</tr>
<tr>
<td align="left">55</td>
<td align="left">EXTERNAL_BLOCK_STORE_FAILED_TO_CREATE_DIR</td>
<td align="left">ExternalBlockStore 未能创建本地临时目录</td>
</tr>
<tr>
<td align="left">56</td>
<td align="left">HEARTBEAT_FAILURE</td>
<td align="left">executor 向 driver 发送心跳信号失败次数超过了 spark.executor.heartbeat.maxFailures</td>
</tr>
</tbody></table>
<p>以上主要参考 org.apache.spark.executor.ExecutorExitCode.scala  </p>
<h3 id="ApplicationMaster-退出码"><a href="#ApplicationMaster-退出码" class="headerlink" title="ApplicationMaster 退出码"></a>ApplicationMaster 退出码</h3><table>
<thead>
<tr>
<th align="left">错误码</th>
<th align="left">错误信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">EXIT_SUCCESS</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">EXIT_UNCAUGHT_EXCEPTION</td>
<td align="left">未捕获的异常(此列表之外的异常)退出</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">EXIT_MAX_EXECUTOR_FAILURES</td>
<td align="left">失败的 executor 数量超过目标值。目标值优先取 spark.yarn.max.executor.failures(默认无),未配置 且 开启动态资源管理时取spark.dynamicAllocation.maxExecutors 的 2 倍,其他情况则取 spark.executor.instances 的 2 倍</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">EXIT_REPORTER_FAILURE</td>
<td align="left">应用进度汇报线程(progress reporter)的失败次数超过spark.yarn.scheduler.reporterThread.maxFailures(默认 5)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">EXIT_SC_NOT_INITED</td>
<td align="left">SparkContext 初始化时间超过 spark.yarn.am.waitTime(默认 100s)</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">EXIT_SECURITY</td>
<td align="left">未启用</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">EXIT_EXCEPTION_USER_CLASS</td>
<td align="left">用户MainClass 抛出异常</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">EXIT_EARLY</td>
<td align="left">在 APP 结束前调用了 ShutdownHook</td>
</tr>
</tbody></table>
<p>以上参考 org.apache.spark.deploy.yarn.ApplicationMaster.scala  </p>
<h2 id="JVM-退出码"><a href="#JVM-退出码" class="headerlink" title="JVM 退出码"></a>JVM 退出码</h2><p>数值上超过 128 的退出码很有可能是由 Unix Signal 触发的程序关闭导致的，可以通过用退出码减去 128来计算 Unix Signal。例如最常见的 137 退出码是由 kill -9 强制杀死抛出的，143 退出码一般是由 kill 或 kill -15 杀死抛出的。 </p>
<table>
<thead>
<tr>
<th align="left">错误码</th>
<th align="left">错误信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">137</td>
<td align="left">FORCE_KILLED</td>
<td align="left">128+9,即是由 kill -9 命令强制终止,一般是虚拟或物理内存超限导致、也有可能是操作系统整体内存紧张杀死进程</td>
</tr>
<tr>
<td align="left">143</td>
<td align="left">TERMINATED</td>
<td align="left">128+15,即是由 kill 命令终止的,一般是 OOM/FGC 导致</td>
</tr>
<tr>
<td align="left">154</td>
<td align="left">LOST</td>
<td align="left">128+27,虚拟计时器过期(?)</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Then I ran the program in one terminal window (java Death; echo $?) while iterating through all kill signals (0-31) in another:</span><br><span class="line">kill -$SIGNAL $(jps | grep Death | cut -d\  -f1)</span><br><span class="line"></span><br><span class="line">signal	    shutdown runs hook exit code    comment</span><br><span class="line">default (15)	yes	yes	143	SIGTERM is the default unix kill signal</span><br><span class="line">0	no	-	-	</span><br><span class="line">1 (SIGHUP)	yes	yes	129	</span><br><span class="line">2 (SIGINT)	yes	yes	130	SIGINT is the signal sent on ^C</span><br><span class="line">3 (SIGQUIT)	no	-	-	Makes the JVM dump threads &#x2F; stack-traces</span><br><span class="line">4 (SIGILL)	yes	no	134	Makes the JVM write a core dump and abort on trap 6</span><br><span class="line">5	yes	no	133	Makes the JVM exit with &quot;Trace&#x2F;BPT trap: 5&quot;</span><br><span class="line">6 (SIGABRT)	yes	no	134	Makes the JVM exit with &quot;Abort trap: 6&quot;</span><br><span class="line">7	yes	no	135	Makes the JVM exit with &quot;EMT trap: 7&quot;</span><br><span class="line">8 (SIGFPE)	yes	no	134	Makes the JVM write a core dump and abort on trap 6</span><br><span class="line">9 (SIGKILL)	yes	no	137	The JVM is forcibly killed (exits with &quot;Killed: 9&quot;)</span><br><span class="line">10 (SIGBUS)	yes	no	134	Emulates a &quot;Bus Error&quot;</span><br><span class="line">11 (SIGSEGV)	yes	no	134	Emulates a &quot;Segmentation fault&quot;</span><br><span class="line">12	yes	no	140	Makes the JVM exit with &quot;Bad system call: 12&quot;</span><br><span class="line">13	no	-	-	</span><br><span class="line">14	yes	no	142	Makes the JVM exit with &quot;Alarm clock: 14&quot;</span><br><span class="line">15 (SIGTERM)	yes	yes	143	This is the default unix kill signal</span><br><span class="line">16	no	-	-	</span><br><span class="line">17	no	-	145	Stops the application (sends it to the background), same as ^Z</span><br><span class="line">18	no	-	146	Stops the application (sends it to the background), same as ^Z</span><br><span class="line">19	no	-	-	</span><br><span class="line">20	no	-	-	</span><br><span class="line">21	no	-	149	Stops the application (sends it to the background), same as ^Z</span><br><span class="line">22	no	-	150	Stops the application (sends it to the background), same as ^Z</span><br><span class="line">23	no	-	-	</span><br><span class="line">24	yes	no	152	Makes the JVM exit with &quot;Cputime limit exceeded: 24&quot;</span><br><span class="line">25	no	-	-	</span><br><span class="line">26	yes	no	154	Makes the JVM exit with &quot;Virtual timer expired: 26&quot;</span><br><span class="line">27	yes	no	155	Makes the JVM exit with &quot;Profiling timer expired: 27&quot;</span><br><span class="line">28	no	-	-	</span><br><span class="line">29	no	-	-	</span><br><span class="line">30	yes	no	158	Makes the JVM exit with &quot;User defined signal 1: 30&quot;</span><br><span class="line">31	yes	no	134	Makes the JVM exit on Segmentation fault</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This list was compiled using (a quite old) Oracle Hotspot Java 8 EA on Mac OS X:</span><br><span class="line">java version &quot;1.8.0-ea&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0-ea-b65)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.0-b09, mixed mode)</span><br></pre></td></tr></table></figure>

<p>以上主要参考 <a href="http://journal.thobe.org/2013/02/jvms-and-kill-signals.html" target="_blank" rel="noopener">http://journal.thobe.org/2013/02/jvms-and-kill-signals.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>hadoop-project/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server-nodemanager/src/main/native/container-executor/impl/container-executor.h   </li>
<li>org.apache.hadoop.yarn.api.records.ContainerExitStatus.java    </li>
<li>org.apache.spark.executor.ExecutorExitCode.scala  </li>
<li><a href="http://journal.thobe.org/2013/02/jvms-and-kill-signals.html" target="_blank" rel="noopener">http://journal.thobe.org/2013/02/jvms-and-kill-signals.html</a>  </li>
<li>org.apache.hadoop.yarn.server.nodemanager.ExitCode.java</li>
<li>org.apache.spark.deploy.yarn.ApplicationMaster.scala  </li>
<li>org.apache.hadoop.yarn.api.records.FinalApplicationStatus.java  </li>
</ol>
]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
        <tag>Yarn 2.7.3</tag>
        <tag>Spark On Yarn ExitCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn User Headroom</title>
    <url>/2019-11-12-Yarn%20User%20Headroom/</url>
    <content><![CDATA[<p>ResourceManager 尝试在 NM 上分配容器的过程中，主要考虑的限制条件如下:<br>a)    队列具有该节点的 access 权限,节点不在 APP 设置的黑名单内<br>b)    节点上无保留且节点剩余空间大于最小容器大小(1G)<br>c)    最高配额限制:如果分配该容器,叶子队列及其所有父队列均不能超过各自的最高配额。<br>d)    用户配额限制(headroom):瞬时量,该容器大小不能超过 headroom 当前值。<br>e)    AM 限制:不超过队列 AM 限制(AM资源和AM数量限制)<br>主要限制在 c)和 d)。c)是在在队列层面对队列可使用资源量做的限制; d) user headroom 是在用户层面对用户可使用资源量做的限制。只有在不违背上述条件时，容器才会在当前 NM 上分配或保留。</p>
<a id="more"></a>

<blockquote>
</blockquote>
<p>user headroom 的计算过程主要有三步,<br>第一步: 计算队列的配置容量 queueCapacity，即 max{capacity, required}<br>第二步: 计算队列的当前容量 currentCapacity，即分段函数 capacity 和 used + required<br>第三步: 计算用户限制 limit，即 min{queueCapacity * userLimitFactor, max{currentCapacty/activeUser, currentCapacity * userLimit/100}}  </p>
<p>主要和两个配置有关:  </p>
<ol>
<li>yarn.scheduler.capacity.<queue-path>.minimum-user-limit-percent(程序内对应 userLimit)<br>　表示队列内多用户均分资源的方式，默认为 100。此值可以在一个极小值与极大值之间动态变化,该配置决定极小值,极大值由队列内活跃用户数决定。e.g. 将此值配置为 30 时, 当队列内仅有1个用户时,该用户最多使用队列100%资源;2个用户,每个用户最多使用50%资源;3个用户,每个用户最多可以使用 33.3%资源;4 个及更多时 每个用户最多可以使用 30%资源。即 [0,max{0.3,1/activeUser}]，体现在源码中   
　</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　Resources.max(</span><br><span class="line">resourceCalculator, clusterResource,</span><br><span class="line">&#x2F;&#x2F;当前容量&#x2F;活跃用户数</span><br><span class="line">Resources.divideAndCeil(</span><br><span class="line">    resourceCalculator, currentCapacity, activeUsers),</span><br><span class="line">&#x2F;&#x2F;当前容量 * 用户限制&#x2F;100</span><br><span class="line">Resources.divideAndCeil(</span><br><span class="line">    resourceCalculator,</span><br><span class="line">    Resources.multiplyAndRoundDown(</span><br><span class="line">        currentCapacity, userLimit),</span><br><span class="line">    100)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>yarn.scheduler.capacity.<queue-path>.user-limit-factor(程序内对应 userLimitFactor)<br>　表示一个用户可以最大获取资源的能力,可以获取当前队列容量乘以该值的最大资源，默认为 1 以确保无论集群负载如何 单用户都不能使用超过队列容量的资源。体现在源码中  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)</span><br></pre></td></tr></table></figure>

<p>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Resource computeUserLimit(FiCaSchedulerApp application,</span><br><span class="line">      Resource clusterResource, Resource required, User user,</span><br><span class="line">      Set&lt;String&gt; requestedLabels) &#123;</span><br><span class="line">    Resource queueCapacity &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">    &#x2F;&#x2F; What is our current capacity?</span><br><span class="line">    &#x2F;&#x2F; * It is equal to the max(required, queue-capacity) if</span><br><span class="line">    &#x2F;&#x2F;   we&#39;re running below capacity. The &#39;max&#39; ensures that jobs in queues</span><br><span class="line">    &#x2F;&#x2F;   with miniscule capacity (&lt; 1 slot) make progress</span><br><span class="line">    &#x2F;&#x2F; * If we&#39;re running over capacity, then its</span><br><span class="line">    &#x2F;&#x2F;   (usedResources + required) (which extra resources we are allocating)</span><br><span class="line">    &#x2F;&#x2F; 第一步: 依据标签计算队列的 capacity</span><br><span class="line">    if (requestedLabels !&#x3D; null &amp;&amp; !requestedLabels.isEmpty()) &#123;</span><br><span class="line">     String firstLabel &#x3D; requestedLabels.iterator().next();</span><br><span class="line">      queueCapacity &#x3D;</span><br><span class="line">          Resources</span><br><span class="line">              .max(resourceCalculator, clusterResource, queueCapacity,</span><br><span class="line">                  Resources.multiplyAndNormalizeUp(resourceCalculator,</span><br><span class="line">                      labelManager.getResourceByLabel(firstLabel,</span><br><span class="line">                          clusterResource),</span><br><span class="line">                      queueCapacities.getAbsoluteCapacity(firstLabel),</span><br><span class="line">                      minimumAllocation));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueCapacity &#x3D;</span><br><span class="line">          Resources.multiplyAndNormalizeUp(resourceCalculator, labelManager</span><br><span class="line">                .getResourceByLabel(CommonNodeLabelsManager.NO_LABEL, clusterResource),</span><br><span class="line">              queueCapacities.getAbsoluteCapacity(), minimumAllocation);</span><br><span class="line">    &#125;</span><br><span class="line">    queueCapacity &#x3D;</span><br><span class="line">        Resources.max(</span><br><span class="line">            resourceCalculator, clusterResource,</span><br><span class="line">            queueCapacity,</span><br><span class="line">            required);</span><br><span class="line">    &#x2F;&#x2F; 第二步: 计算 currentCapacity</span><br><span class="line">    Resource currentCapacity &#x3D;</span><br><span class="line">        Resources.lessThan(resourceCalculator, clusterResource,</span><br><span class="line">            queueUsage.getUsed(), queueCapacity) ?</span><br><span class="line">            queueCapacity : Resources.add(queueUsage.getUsed(), required);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Never allow a single user to take more than the</span><br><span class="line">    &#x2F;&#x2F; queue&#39;s configured capacity * user-limit-factor.</span><br><span class="line">    &#x2F;&#x2F; Also, the queue&#39;s configured capacity should be higher than</span><br><span class="line">    &#x2F;&#x2F; queue-hard-limit * ulMin</span><br><span class="line"></span><br><span class="line">    final int activeUsers &#x3D; activeUsersManager.getNumActiveUsers();</span><br><span class="line">    &#x2F;&#x2F; 第三步: 计算用户可使用的最高容量</span><br><span class="line">    Resource limit &#x3D;</span><br><span class="line">        Resources.roundUp(</span><br><span class="line">            resourceCalculator,</span><br><span class="line">            Resources.min(</span><br><span class="line">                resourceCalculator, clusterResource,</span><br><span class="line">                Resources.max(</span><br><span class="line">                    resourceCalculator, clusterResource,</span><br><span class="line">                    &#x2F;&#x2F;当前容量&#x2F;活跃用户数</span><br><span class="line">                    Resources.divideAndCeil(</span><br><span class="line">                        resourceCalculator, currentCapacity, activeUsers),</span><br><span class="line">                    &#x2F;&#x2F;当前容量 * 最高用户数&#x2F;100</span><br><span class="line">                    Resources.divideAndCeil(</span><br><span class="line">                        resourceCalculator,</span><br><span class="line">                        Resources.multiplyAndRoundDown(</span><br><span class="line">                            currentCapacity, userLimit),</span><br><span class="line">                        100)</span><br><span class="line">                    ),</span><br><span class="line">                &#x2F;&#x2F;当前容量 * 用户限制因子(倍数)</span><br><span class="line">                Resources.multiplyAndRoundDown(queueCapacity, userLimitFactor)</span><br><span class="line">                ),</span><br><span class="line">            minimumAllocation);</span><br><span class="line">    .....</span><br><span class="line">    user.setUserResourceLimit(limit);</span><br><span class="line">    return limit;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h2><p>测试项: 用户提交应用时 user headroom 计算方式及能否平分集群资源。<br>用户限制因子 userLimitFactor = 100，queueCapacity * userLimitFactor &gt;&gt; clusterResource，即单用户资源上限很高<br>用户限制 userLimit = 30，即用户可以使用队列[0,max{0.3,1/activeUser}]资源  </p>
<h3 id="scene-1-单用户单队列单应用可以独占集群资源"><a href="#scene-1-单用户单队列单应用可以独占集群资源" class="headerlink" title="scene 1 单用户单队列单应用可以独占集群资源"></a>scene 1 单用户单队列单应用可以独占集群资源</h3><p>单用户时 user headroom 的变化 随着常规调度模块为应用不断分配资源(可用集群全部资源) 分为(分段函数)两个阶段:    </p>
<ol>
<li>当 used &lt; queueCapacity 时，limit = queueCapacity  </li>
<li>当 used &gt;= queueCapacity 时，limit = used + required。上限是 min{queueCapacity * userLimitFactor, clusterResource}  </li>
</ol>
<p>单用户时 user headroom 变化曲线如下:  </p>
<p><img src="/img/pictures/yarn_headroom/headroom_1.jpeg" alt=""></p>
<h3 id="scene-2-单用户双队列双应用未必平分集群资源"><a href="#scene-2-单用户双队列双应用未必平分集群资源" class="headerlink" title="scene 2 单用户双队列双应用未必平分集群资源"></a>scene 2 单用户双队列双应用未必平分集群资源</h3><p>基于 scene 1,随后在另外一个队列(Queue_B)提交一个新的 APP(M 个 N 大小的容器)。该用户在 Queue_B 的 headroom 可分为两个阶段:  </p>
<ol>
<li>当 used &lt; queueCapacity 时,limit = queueCapacity。此时抢占调度模块 Queue_B 的 堆积(pending)ResourceRequest = min{limit-used, M * N}。抢占模块会负责将 overCapacity 队列的资源释放，Queue_B 队列可以有资源运行。即 Queue_B 可以运行容器,used 值逼近 queueCapacity，pendingResourceRequest 值逼近于 0(虽然此时 APP 还有很多容器没有分配)。  </li>
<li>这个阶段有两种可能，关键在于: 常规调度模块能否利用集群剩余资源为 Queue_B 再分配一个容器，使其 used &gt; queueCapacity。<br>　　2a.不能分配一个容器。limit = queueCapacity，pendingResourceRequest = min{limit - used,M * N} 趋近于 0。pendingResourceRequest 会触发抢占调度(不考虑 0.2 的deadzone,超过 capacity * (1+deadzone)的 overCapacity 队列才会真正还回资源)。Queue_B 欠分配，最终理想容量为 used + pendingResourceRequest(因为很小,且初始 idealAssigned/guarantee 小,会先被分配)，pendingResourceRequest(min{limit-used,M * N}) 的资源量不足以启动一个容器(原因很多,尤其是大容器,抢占的资源分布在繁忙集群的多个节点上,每个节点都不足以启动一个容器；pendingResourceRequest 被 limit 削弱过,不足以启动一个容器)。此时 user 在 Queue_B 的 headroom 恒等于 queueCapacity。抢占也不能抢回足够资源。<br>　　2b. 能分配一个容器，使队列 used &gt; queueCapacity。此时队列的 currentCapacity 值由 queueCapacity(常量)跃迁至 used+required，提高了 headroom 上限,进而提高了 pendingResourceRequest 上限，抢占调度依据 pendingResourceRequest 值计算集群各队列的理想容量，抢回了资源足以启动容器，又提升了 used。剩下限制 APP 资源量的条件只有 min{queueCapacity * userLimitFactor, maxCapacity,平分 clusterResource}了。</li>
</ol>
<p>单用户双队列双 APP 的 user headroom 变化曲线如下:  </p>
<p><img src="/img/pictures/yarn_headroom/headroom_2.jpeg" alt=""></p>
<h3 id="scene-3-多用户多队列应用更难平分集群资源"><a href="#scene-3-多用户多队列应用更难平分集群资源" class="headerlink" title="scene 3 多用户多队列应用更难平分集群资源"></a>scene 3 多用户多队列应用更难平分集群资源</h3><p> 由上述源码可知,limit 取值为 min{queueCapacity * userLimitFactor, max{currentCapacty/activeUser, currentCapacity * userLimit/100}}<br> 其中 activeUser 为整个系统的活跃用户数，即多用户下 limit 取值比单用户更低，但是分段函数的跃迁规则是不变的(used &gt; capacity?)，即系统既要为APP 分配容器，而且容器大小要使队列 used 资源量从 queueCapcity/activeUser 或者 queueCapacity * userLimit/100 跃迁至超过 queueCapacity。</p>
<h2 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h2><ol>
<li>设置 userLimitFactor 很大时(超过 clusterResource),实现多用户平分集群资源是不现实的。第一个提交的大应用将会先独占集群资源，后续提交的应用借助抢占调度获得部分资源，但资源上界一般不会超过队列的容量，越来越难平分资源。但是如果缩小 userLimitFactor,使其不超过 clusterResource的某阈值，其他队列跃迁的可能性增加，通过抢占调度是可实现多用户平分资源。     </li>
<li>user headroom 是为了解决在多用户环境下限制用户可使用资源量,为每个用户维护的瞬时状态量，通过 userLimit 和 userLimitFactor 保证了用户可使用资源的上界。  </li>
<li>user headroom 的计算方式: min{queueCapacity * userLimitFactor, max{currentCapacity/activeUser, currentCapacity * userLimit/100}}         </li>
<li>Yarn 的三大调度方式: 常规调度/抢占调度/预订调度 对于大容器都是不友好的。  </li>
</ol>
]]></content>
      <tags>
        <tag>源码解析</tag>
        <tag>Yarn 2.7.3</tag>
        <tag>Yarn User Headroom</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn ReservationSystem</title>
    <url>/2019-10-28-Yarn%20ReservationSystem/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ReservationSystem 是 YARN ResourceManager 的组件。YARN 的 ReservationSystem 为用户提供了提前保留资源的能力,以确保重要的生产作业可预测地运行。ReservationSystem 执行仔细的准入控制，并保证绝对资源量(而不是群集大小的百分比)。保留具有组和并发的语义，并且可以有随时间变化的资源需求。  </p>
<a id="more"></a>

<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/img/pictures/reservation/yarn_reservation_system.png" alt="">  </p>
<p>参考上图，预订资源的工作流程如下：  </p>
<ul>
<li>step 0: 用户提交预订创建请求，并收到包含 ReservationId 的响应。  </li>
<li>step 1: 用户提交由 RDL(Reservation Definition Language)和 ReservationId 组成的 ReservationRequest。这描述了用户对资源(e.g. numContainer)和时间(e.g. duration)的需求。这可以通过常规的Client-to-RM协议(ApplicationClientProtocol)以编程方式完成，也可以通过RM的REST API来完成。如果提交的预订具有相同的ReservationId 并且RDL相同，则请求将成功但不会创建新的预订。如果RDL不同，则保留将被拒绝且请求失败</li>
<li>step 2: ReservationSystem 委托 ReservationAgent(图中的GREE) 在计划(Plan)中为 ReservationRequest 找到一个合理的时间分配，计划(Plan)是一个跟踪当前所有已接受的预订请求以及系统中可用资源的内存数据结构。  </li>
<li>step 3: SharingPolicy 提供了一种在预订请求上强制保证统计量的方法，决定接受或者拒绝预订。例如，CapacityOvertimePolicy允许强制保证用户可以在其所有预订中请求的瞬时最大容量，以及一段时期内对资源整体的限制，例如，用户所有的预订最多可以达到瞬时50％集群最大容量，但是在一天内，其平均值不能超过10％。(The SharingPolicy provides a way to enforce invariants on the reservation being accepted, potentially rejecting reservations. For example, the CapacityOvertimePolicy allows enforcement of both instantaneous max-capacity a user can request across all of his/her reservations and a limit on the integral of resources over a period of time, e.g., the user can reserve up to 50% of the cluster capacity instantanesouly, but in any 24h period of time he/she cannot exceed 10% average)  </li>
<li>step 4: 成功验证后，ReservationSystem 会向用户返回一个ReservationId 作为票据    </li>
<li>step 5: PlanFollower(线程周期调度)通过动态创建/调整/销毁队列将计划的状态发布到调度程序 </li>
<li>step 6: 用户可以在(多个)应用程序的 ApplicationSubmissionContext 中指定 ReservationId 提交到可预订的队列(PlanQueue,具有 reservable 属性的 LeafQueue) </li>
<li>step 7: 常规调度器将从创建的特殊队列中提供容器,以确保遵守资源预定。在预订的时间和资源限制下，用户的(多个)应用程序可以以容量/公平的方式共享资源   </li>
<li>step 8: 预订系统可以兼容容量下降的情况。包括拒绝之前接受最晚的预订兼容 reservable queue 的容量骤减，移动预订到 reservable queue 下的 default队列来兼容超时(预订到期但app 没结束)应用以重建计划  </li>
</ul>
<p>注: step 8和官网解释不同。官网解释可能不实,参见源码解析-“step 8”</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="涉及的类"><a href="#涉及的类" class="headerlink" title="涉及的类"></a>涉及的类</h3><ul>
<li><p>org.apache.hadoop.yarn.server.resourcemanager.reservation.AbstractReservationSystem<br>该类继承了AbstractService,实现了ReservationSystem 并封装了Capacity/Fair 调度器下预订系统的核心实现<br>主要功能是:作为服务启动时加载配置文件中配置的 reservable LeafQueue 转换为 Plan;管理 PlanFollower,确保 Plan与常规调度器的同步  </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">setRMContext</td>
<td align="center">保存 rmContext 指针</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">reinitialize</td>
<td align="center">重新初始化 ReservationSystem</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">getPlan</td>
<td align="center">获取已被加载的 Plan</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">getAllPlans</td>
<td align="center">获取已被加载的所有 Plan</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">synchronizePlan</td>
<td align="center">使用 PlanFollower 同步 Plan 与常规调度器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">getPlanFollowerTimeStep</td>
<td align="center">PlanFollower 步长</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">getNewReservationId</td>
<td align="center">获取一个全局唯一的reservationId</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">getQueueForReservation</td>
<td align="center">获取reservationId关联的队列</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">setQueueForReservation</td>
<td align="center">为reservationId关联队列</td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
<li><p>org.apache.hadoop.yarn.server.resourcemanager.reservation.AbstractSchedulerPlanFollower<br>该类实现了 PlanFollower与 Runnable 接口<br>主要功能是:周期性同步常规调度器与 Plan。通过将计划中的每个预订的当前资源映射到常规调度器(e.g. 队列的调整能力,设置池权重,调整应用优先级)，来影响调度器的资源分配 进而达到 保证作业与Plan 中预订一致的方式来使用资源。一个关键概念是将预订的绝对值式资源转换为队列的优先级和容量。PlanFollower 也会向 Plan 来同步集群总资源的变化使其作出相应的调整。  </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">init</td>
<td align="left">通过 SystemClock,ResourceSchduler 和Plans 来初始化PlanFollower</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">synchronizePlan</td>
<td align="left">同步指定 Plan和常规调度器</td>
<td align="left">周期性调用;时间紧迫时同步阻塞调用</td>
</tr>
<tr>
<td align="left">setPlans</td>
<td align="left">重置 PlanFollower 同步的 Plan 集合</td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
<li><p>org.apache.hadoop.yarn.server.resourcemanager.reservation.InMemoryPlan<br>该接口实现了 Plan 接口,Plan 接口继承了PlanContext, PlanView, PlanEdit。实现只有 InMemoryPlan<br>Plan 代表着预订系统的核心数据结构,维护着集群资源的工作安排(分配或收回)计划。用户将 ReservationRequest 提交给 RM 之后,RM 委托给 ReservationAgent，ReservationAgent 通过PlanView 接口咨询该 Plan 是否能满足 RDL 时间且资源约束。如果可以分配,则通过 PlanEdit 接口将其存储在该 Plan 中。之后便向用户返回 ReservationId 票据,用户可通过该票据在预订的时间范围使用预订的资源。<br>PlanFollower将会周期性的从 Plan 中读取最新工作安排计划(队列瞬时容量),并同步给常规调度器,进而影响正在运行作业占用的资源。<br>接口中有三类方法:  PlanContext 负责配置信息;PlanView 负责对Plan 状态的只读访问;PlanEdit 负责对 Plan 状态写入访问。  </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getStep</td>
<td align="center">获取 Plan 的时间步长</td>
<td align="left">PlanContext,同 PlanFollower 的时间步长</td>
</tr>
<tr>
<td align="left">getReservationAgent</td>
<td align="center">获取 Plan关联的 ReservationAgent</td>
<td align="left">PlanContext</td>
</tr>
<tr>
<td align="left">getReplanner</td>
<td align="center">使用 Planner 对象来应对Plan 的资源意外减少</td>
<td align="left">PlanContext</td>
</tr>
<tr>
<td align="left">getSharingPolicy</td>
<td align="center">SharingPolicy 控制多用户共享计划资源</td>
<td align="left">PlanContext</td>
</tr>
<tr>
<td align="left">getReservationById</td>
<td align="center">通过 ReservationId 获取 Reservation 的详细信息</td>
<td align="left">PlanView</td>
</tr>
<tr>
<td align="left">getReservationsAtTime</td>
<td align="center">获取指定时间点所有活跃的 Reservation 的详细信息</td>
<td align="left">PlanView</td>
</tr>
<tr>
<td align="left">getAllReservations</td>
<td align="center">获取 Plan 中所有预订信息</td>
<td align="left">PlanView</td>
</tr>
<tr>
<td align="left">getTotalCommittedResources</td>
<td align="center">获取指定时间点所有预定的总资源量</td>
<td align="left">PlanView</td>
</tr>
<tr>
<td align="left">getConsumptionForUser</td>
<td align="center">获取指定时间点指定用户预定的总资源量</td>
<td align="left">PlanView</td>
</tr>
<tr>
<td align="left">getEarliestStartTime</td>
<td align="center">获取计划中最早的预订开始时间</td>
<td align="left">PlanView</td>
</tr>
<tr>
<td align="left">getLastEndTime</td>
<td align="center">获取计划中最晚的预订结束时间</td>
<td align="left">PlanView</td>
</tr>
<tr>
<td align="left">addReservation</td>
<td align="center">增加一个预订</td>
<td align="left">PlanEdit</td>
</tr>
<tr>
<td align="left">updateReservation</td>
<td align="center">更新一个预订</td>
<td align="left">PlanEdit</td>
</tr>
<tr>
<td align="left">deleteReservation</td>
<td align="center">删除一个预订</td>
<td align="left">PlanEdit</td>
</tr>
<tr>
<td align="left">archiveCompletedReservations</td>
<td align="center">清除所有的过期预订</td>
<td align="left">PlanEdit</td>
</tr>
</tbody></table>
</li>
</ul>
<p>　　仅列举出核心方法,实际不限于此  </p>
<ul>
<li><p>org.apache.hadoop.yarn.server.resourcemanager.reservation.GreedyReservationAgent<br>实现了ReservationAgent接口。 
一个简单的贪婪放置策略来满足用户预订的代理。具体方式是:按照 ReservationRequests中的各个 ReservationRequest作为单独的阶段,从deadline 开始向后移动至 arrival 来安排预订请求。该代理不考虑本地性,仅仅考虑容器粒度的验证(e.g. 不能超过最大容器大小)  </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">createReservation</td>
<td align="center">使用此代理尝试创建一个预订</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">updateReservation</td>
<td align="center">使用此代理更新一个已有预订</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">deleteReservation</td>
<td align="center">使用此代理删除一个已有预订</td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
<li><p>org.apache.hadoop.yarn.server.resourcemanager.reservation.CapacityOverTimePolicy<br>主要功能是校验 Plan 能否接受用户预订请求 。实现类 CapacityOverTimePolicy使用容量的按时间拓展概念：策略会保证该用户的当前预订申请和已生效的预订申请资源不超过瞬时资源限制(e.g. reservable queue capacity * 1),且在 24h 时间窗口内不能超过平均资源限制(e.g. reservable queue capacity * 0.5)。从某种意义来说,预订可以使用 reservable queue 的大部分容量 但只要保证快速归还以保证平均资源限制，这可以防止资源滥用且增加了灵活性。通过配置瞬时资源限制和平均资源限制以及时间窗口,策略可以使 reservable queue 达到即时执行(max=100%,avg=100%)和完全灵活(max=?,avg=?,保留给其他用户或系统)的效果。   </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">init</td>
<td align="center">初始化 Policy</td>
<td align="left">策略必要的配置读取</td>
</tr>
<tr>
<td align="left">validate</td>
<td align="center">校验 Plan 能否接受用户预订请求</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">getValidWindow</td>
<td align="center">预订资源的过期时间</td>
<td align="left">窗口为[-24h,当前)。预订的 deadline 在此之前的记录将被删除</td>
</tr>
</tbody></table>
</li>
<li><p>org.apache.hadoop.yarn.server.resourcemanager.reservation.Planner<br>实现类只有SimpleCapacityReplanner,且功能远不及 Planner 的设计(增删改 Plan)，只有删除预订资源的功能：从当前时刻开始直到 min{最后一个预约endtime，一个小时之后}，如果所有用户预订资源总量超过 reservable queue capacity，则删除接受时间较晚的一批预订。 </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">init</td>
<td align="left">初始化 Planner</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">plan</td>
<td align="left">更新现有的 Plan,或增删改已有预订或增加一个新的预订</td>
<td align="left">SCR 只支持删除晚的预订以保证预订资源总量不超过队列最低配额</td>
</tr>
</tbody></table>
</li>
<li><p>org.apache.hadoop.yarn.server.resourcemanager.reservation.RLESparseResourceAllocation<br>预订系统的核心数据结构，是一种运行长度编码(Run Length Encoded)的稀疏数据结构(TreeMap)，可随着时间的推移维护资源分配。维护者各事件点(预订分配 starttime，endtime)时(Plan/当前预订)全局应有的资源总量。  </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getEarliestStartTime</td>
<td align="left">最早的资源分配的时间戳</td>
<td align="left">treemap  firstKey</td>
</tr>
<tr>
<td align="left">getLatestEndTime</td>
<td align="left">最晚的资源分配的时间戳</td>
<td align="left">treemap lastKey</td>
</tr>
<tr>
<td align="left">getCapacityAtTime</td>
<td align="left">该时间点的 Plan 已预订资源量</td>
<td align="left">treemap floorKey</td>
</tr>
<tr>
<td align="left">addInterval</td>
<td align="left">在treemap 中新增一个时间范围的预约资源记录</td>
<td align="left">维护开始点和结束点的资源量</td>
</tr>
<tr>
<td align="left">removeInterval</td>
<td align="left">在 treemap 中删除一个时间范围的预约资源记录</td>
<td align="left">维护开始点和结束点的资源量</td>
</tr>
<tr>
<td align="left">addCompositeInterval</td>
<td align="left">在 treemap 中新增一个时间范围的多个预订资源记录</td>
<td align="left">never used</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
</blockquote>
<p> TreeMap 的floorEntry(targetKey) 和 lowerEntry(targetKey)  区别:<br> floorEntry 返回 key 小于等于 targetKey 的键值对,无则 null<br> lowerEntry 返回 key 严格小于 targetKey 的键值对,无则 null  </p>
<ul>
<li>org.apache.hadoop.yarn.server.resourcemanager.reservation.InMemoryReservationAllocation
实现自 ResourceAllocation。预订分配的结果，内存数据结构，包含预订的整体开始结束时间，ReservationSystem 校验(GA 校验资源/SharingPolicy 校验用户违规)通过 ReservationSubmissionRequest 的时间，&lt;时间段，资源量&gt;的分配细节和RLESparseResourceAllocation    </li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">功能</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">compareTo</td>
<td align="left">按 acceptTime比较,晚的在前</td>
<td align="left">比较器, Plan 队列资源骤减时,删除部分晚的的 ResourceAllocation</td>
</tr>
</tbody></table>
<ul>
<li><p>org.apache.hadoop.yarn.api.protocolrecords.ReservationSubmissionRequest<br>客户端封装ReservationSubmissionRequest 请求，通过 client-RM 接口提交给 RM，数据结构如下<br>　　queueName:String    //支持预订资源的队列<br>　　rd:ReservationDefinition //预订定义<br>　　　　arrival:long  //预订开始时间的 最早时间<br>　　　　deadline:long   //预订结束时间的 最晚时间<br>　　　　name:String  //名称<br>　　　　reservationRequests:ReservationRequests  //预订请求    　
　　　　　　reservationResources:List&lt;ReservationRequest&gt;<br>　　　　　　　　capability:Capacity  //每个预订请求的资源量<br>　　　　　　　　numContainers:int  //预订的 container 数量<br>　　　　　　　　concurrency:int //并发度。numContainers 可以分批分配<br>　　　　　　　　duration:long  //使用时间<br>　　　　type:ReservationRequestInterpreter  //多个预订请求之间的依赖关系  </p>
</li>
<li><p>org.apache.hadoop.yarn.api.records.ReservationRequestInterpreter<br>枚举类型，用以表示多个预订请求之间的依赖关系(或称: 组关系)      </p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含义</th>
<th align="left">场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R_ANY</td>
<td align="left">仅满足 RDL 中一个预订请求即可</td>
<td align="left">有多种等效的方式满足要求。e.g. 1个&lt;4G,2core&gt;或2个&lt;2G,1core&gt;。Agent 会决定使用最合适的ReservationRequest</td>
</tr>
<tr>
<td align="left">R_ALL</td>
<td align="left">需要满足 RDL中所有预订请求,请求的分配没有限制时间先后</td>
<td align="left">事务</td>
</tr>
<tr>
<td align="left">R_ORDER</td>
<td align="left">需要满足 RDL 中所有预订请求,且有严格的时间限制。k 位置的分配时间段必须在 k+1位置分配时间段之前(无交集)，且 k 位置分配的结束时间和 k+1位置分配的开始时间可以有任意长的时间间隔</td>
<td align="left">具有固定依赖的阶段性工作流。e.g. 第一个作业需要 1个&lt;4G,2core&gt; 5min，其输出作为第二个作业的输入，第二个作业需要 2 个&lt;2G,1core&gt; 10min，则两个作业预订的分配时间段必然不能重叠</td>
</tr>
<tr>
<td align="left">R_ORDER_NO_GAP</td>
<td align="left">R_ORDER 的严格版本，要求 k 位置分配的结束时间和 k+1 位置分配的开始时间相同、不能有任何间隙,即 “zero-size gap”,”no_gap”</td>
<td align="left">1.当前一个作业输出规模比较大时,避免保留太长时间 2.实时性要求很高的场景,作业间时间差则增大了工作流累计延时</td>
</tr>
</tbody></table>
</li>
<li><p>org.apache.hadoop.yarn.api.protocolrecords.ReservationSubmissionResponse<br>客户端提交 ReservationSubmissionRequest 请求后，若RM 校验通过可以分配预订，则返回 reservationId给客户端。数据结构如下<br>　　reservationId:ReservationId<br>　　　　clusterTimestamp:long<br>　　　　id:long   </p>
</li>
</ul>
<h3 id="step-0"><a href="#step-0" class="headerlink" title="step 0"></a>step 0</h3><p>用户提交预订创建请求，并收到包含 ReservationId 的响应  </p>
<p>[ApplicationClientProtocol.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ReservationSubmissionResponse submitReservation(</span><br><span class="line">      ReservationSubmissionRequest request) throws YarnException, IOException</span><br></pre></td></tr></table></figure>
<h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><p>用户提交由 RDL(Reservation Definition Language)和 ReservationId 组成的 ReservationRequest。描述了用户对资源(e.g. numContainer)和时间(e.g. duration)的需求,可以通过常规的Client-to-RM协议(ApplicationClientProtocol)以编程方式完成，也可以通过RM的REST API来完成。如果提交的预订具有相同的ReservationId 并且RDL相同，则请求将成功但不会创建新的预订。如果RDL不同，则保留将被拒绝且请求失败<br>以 TestCase 中的代码片段为例  </p>
<p>[TestClientRMService.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testReservationAPIs() &#123;</span><br><span class="line">	....</span><br><span class="line">    &#x2F;&#x2F;创建一个预订请求</span><br><span class="line">    Clock clock &#x3D; new UTCClock();</span><br><span class="line">    &#x2F;&#x2F;预订最早开始时间</span><br><span class="line">    long arrival &#x3D; clock.getTime();	   </span><br><span class="line">    &#x2F;&#x2F;使用时长 </span><br><span class="line">    long duration &#x3D; 60000;    </span><br><span class="line">    &#x2F;&#x2F;预订的最晚结束时间</span><br><span class="line">    long deadline &#x3D; (long) (arrival + 1.05 * duration);</span><br><span class="line">    &#x2F;&#x2F;RDL: Rervation Define Language </span><br><span class="line">    &#x2F;&#x2F;请求 4 个 &lt;1G,1core&gt; container,使用时长是 6000ms,使用开始的最早时间是 arrival,使用结束的最晚内时间是 deadline。</span><br><span class="line">    ReservationSubmissionRequest sRequest &#x3D;</span><br><span class="line">        createSimpleReservationRequest(4, arrival, deadline, duration);</span><br><span class="line">    ReservationSubmissionResponse sResponse &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      sResponse &#x3D; clientService.submitReservation(sRequest);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      Assert.fail(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ReservationSubmissionRequest createSimpleReservationRequest(</span><br><span class="line">      int numContainers, long arrival, long deadline, long duration) &#123;</span><br><span class="line">    ReservationRequest r &#x3D;</span><br><span class="line">        ReservationRequest.newInstance(Resource.newInstance(1024, 1),</span><br><span class="line">            numContainers, 1, duration);</span><br><span class="line">            &#x2F;&#x2F;R_ALL 满足所有请求</span><br><span class="line">    ReservationRequests reqs &#x3D;</span><br><span class="line">        ReservationRequests.newInstance(Collections.singletonList(r),</span><br><span class="line">            ReservationRequestInterpreter.R_ALL);</span><br><span class="line">    ReservationDefinition rDef &#x3D;</span><br><span class="line">        ReservationDefinition.newInstance(arrival, deadline, reqs,</span><br><span class="line">            &quot;testClientRMService#reservation&quot;);</span><br><span class="line">    ReservationSubmissionRequest request &#x3D;</span><br><span class="line">        ReservationSubmissionRequest.newInstance(rDef,</span><br><span class="line">            ReservationSystemTestUtil.reservationQ);</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h3><p>ReservationSystem 委托 ReservationAgent(图中的GREE) 在计划(Plan)中为 ReservationRequest 找到一个合理的时间分配，计划(Plan)是一个跟踪当前所有已接受的预订请求以及系统中可用资源的内存数据结构。   </p>
<p>[ClientRMService.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public ReservationSubmissionResponse submitReservation(</span><br><span class="line">      ReservationSubmissionRequest request) throws YarnException, IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查 ReservactionSystem 是否启用</span><br><span class="line">    checkReservationSytem(AuditConstants.SUBMIT_RESERVATION_REQUEST);</span><br><span class="line">    ReservationSubmissionResponse response &#x3D;</span><br><span class="line">        recordFactory.newRecordInstance(ReservationSubmissionResponse.class);</span><br><span class="line">    &#x2F;&#x2F; 通过 AtmicLong 创建全局唯一的ReservationId</span><br><span class="line">    ReservationId reservationId &#x3D; reservationSystem.getNewReservationId();</span><br><span class="line">    &#x2F;&#x2F; 第一步:  校验</span><br><span class="line">    &#x2F;&#x2F; 1.预订请求指定了 queue; 2.指定的 queue 是 reservable queue,即属于 ReservationSystem 管理  </span><br><span class="line">    &#x2F;&#x2F; 2.Reservation Define Language 校验</span><br><span class="line">    &#x2F;&#x2F;	2a. 空值检验  2b. deadline 不能早于当前时间 2c. ReservationRequests 空值及空集判断  </span><br><span class="line">    &#x2F;&#x2F;	2d. 分配所有请求的最短时间(R_ANY,R_ALL:取最大;R_ORDER..取和)不能超过 deadline-arrival </span><br><span class="line">    &#x2F;&#x2F;	2e. 分配所有请求的最大资源量(concurrency * request capacity)不能超过 reservable queue capacity</span><br><span class="line">    Plan plan &#x3D;</span><br><span class="line">        rValidator.validateReservationSubmissionRequest(reservationSystem,</span><br><span class="line">            request, reservationId);</span><br><span class="line">    &#x2F;&#x2F; 校验 ACL	</span><br><span class="line">    String queueName &#x3D; request.getQueue();</span><br><span class="line">    String user &#x3D;</span><br><span class="line">        checkReservationACLs(queueName,</span><br><span class="line">            AuditConstants.SUBMIT_RESERVATION_REQUEST);</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 第二步:  使用 ReservationAgent 来尝试放置预订请求</span><br><span class="line">      boolean result &#x3D;</span><br><span class="line">          plan.getReservationAgent().createReservation(reservationId, user,</span><br><span class="line">              plan, request.getReservationDefinition());</span><br><span class="line">      if (result) &#123;</span><br><span class="line">        &#x2F;&#x2F; 同步 reservationSystem &lt;reservationId,queueName&gt;关系</span><br><span class="line">        reservationSystem.setQueueForReservation(reservationId, queueName);</span><br><span class="line">        &#x2F;&#x2F; create the reservation synchronously if required</span><br><span class="line">        &#x2F;&#x2F; 第三步:  如下,若预留的 arrival 时间早于当前(错过) PlanFollower 一个步长,则同步创建</span><br><span class="line">        refreshScheduler(queueName, request.getReservationDefinition(),</span><br><span class="line">            reservationId.toString());</span><br><span class="line">  	&#x2F;&#x2F; response 中返回放置预订请求的 reservationId</span><br><span class="line">        response.setReservationId(reservationId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (PlanningException e) &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">   private void refreshScheduler(String planName,</span><br><span class="line">      ReservationDefinition contract, String reservationId) &#123;</span><br><span class="line">    if ((contract.getArrival() - clock.getTime()) &lt; reservationSystem</span><br><span class="line">        .getPlanFollowerTimeStep()) &#123;</span><br><span class="line">      ....</span><br><span class="line">      &#x2F;&#x2F;后续再说源码</span><br><span class="line">      reservationSystem.synchronizePlan(planName);</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在第二步中,RMClientService 委托 Plan(reservable queue 的映射) 绑定的 ReservationAgent 来决定是否放置该预订请求<br>ReservationAgent(RA)将预订请求中的每个 ResourceRequest(RR)作为一个单独的 stage 尝试放置,并在放置时考虑 ReservationRequestInterpreter(RRI)组关系的处理。从最后一个 stage 开始向前依次放置，使用 Plan 已有的预订计划累计的数据和当次预订请求的累计中间数据判断能否放置当前 RR来影响当前 RR放置时间策略并存储最终放置策略结果。   </p>
<p>[GreedyReservationAgent.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean computeAllocation(ReservationId reservationId, String user,</span><br><span class="line">      Plan plan, ReservationDefinition contract,</span><br><span class="line">      ReservationAllocation oldReservation) throws PlanningException,</span><br><span class="line">      ContractValidationException &#123;</span><br><span class="line">    LOG.info(&quot;placing the following ReservationRequest: &quot; + contract);</span><br><span class="line">    &#x2F;&#x2F; reservable queue capacity </span><br><span class="line">    Resource totalCapacity &#x3D; plan.getTotalCapacity();</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; 译文:考虑在此增加逻辑来调整&quot;ResourceDefinition&quot; 来解决系统的缺陷(e.g. 大型容器的调度延迟) </span><br><span class="line">   &#x2F;&#x2F;  TODO: 想不出会在这个位置使用什么样的策略来解决大容器调度延迟问题? 逻辑能转移到常规调度吗</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 使用保守策略规整缩短 [arrival,deadline]区间</span><br><span class="line">    long earliestStart &#x3D; contract.getArrival();</span><br><span class="line">    long step &#x3D; plan.getStep();</span><br><span class="line">    if (earliestStart % step !&#x3D; 0) &#123;</span><br><span class="line">      earliestStart &#x3D; earliestStart + (step - (earliestStart % step));</span><br><span class="line">    &#125;</span><br><span class="line">    long deadline &#x3D;</span><br><span class="line">        contract.getDeadline() - contract.getDeadline() % plan.getStep();</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; 将每个 ReservationRequest(RR) 作为一个单独的 stage,设置一些阶段间的临时变量</span><br><span class="line">    long curDeadline &#x3D; deadline;</span><br><span class="line">    long oldDeadline &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F; 当次预订请求，全部 RR 放置时间策略结果的(中间)数据结构 </span><br><span class="line">    Map&lt;ReservationInterval, ReservationRequest&gt; allocations &#x3D;</span><br><span class="line">        new HashMap&lt;ReservationInterval, ReservationRequest&gt;();</span><br><span class="line">     &#x2F;&#x2F; 当次预订请求，全部 RR 放置造成&lt;时间-资源&gt;变动结果的(中间)数据结构  </span><br><span class="line">    RLESparseResourceAllocation tempAssigned &#x3D;</span><br><span class="line">        new RLESparseResourceAllocation(plan.getResourceCalculator(),</span><br><span class="line">            plan.getMinimumAllocation());</span><br><span class="line"></span><br><span class="line">    List&lt;ReservationRequest&gt; stages &#x3D; contract.getReservationRequests()</span><br><span class="line">        .getReservationResources();</span><br><span class="line">    ReservationRequestInterpreter type &#x3D; contract.getReservationRequests()</span><br><span class="line">        .getInterpreter();</span><br><span class="line">    &#x2F;&#x2F; 使用迭代器 从最后一个元素之后的 null 向前迭代</span><br><span class="line">    for (ListIterator&lt;ReservationRequest&gt; li &#x3D; </span><br><span class="line">        stages.listIterator(stages.size()); li.hasPrevious();) &#123;</span><br><span class="line">      ReservationRequest currentReservationStage &#x3D; li.previous();</span><br><span class="line">       &#x2F;&#x2F;第一步:  校验 RR</span><br><span class="line">      &#x2F;&#x2F; 1.concurrency &gt; 0; 2.numContainer&gt;0; 3. numContainer 必须是 concurrency 的倍数; 4.单容器大小不得超过maximumAllocation</span><br><span class="line">      validateInput(plan, currentReservationStage, totalCapacity);</span><br><span class="line">      &#x2F;&#x2F;第二步:  尝试分配单个 RR</span><br><span class="line">      Map&lt;ReservationInterval, ReservationRequest&gt; curAlloc &#x3D;</span><br><span class="line">          placeSingleStage(plan, tempAssigned, currentReservationStage,</span><br><span class="line">              earliestStart, curDeadline, oldReservation, totalCapacity);</span><br><span class="line"></span><br><span class="line">      if (curAlloc &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 组关系是 R_ALL,R_ORDER,R_NO_GAP 时，一个 RR 分配失败 导致整个事务失败</span><br><span class="line">        &#x2F;&#x2F; 组关系是 R_ANY,一个 RR 分配失败可以尝试其他 RR </span><br><span class="line">        if (type !&#x3D; ReservationRequestInterpreter.R_ANY) &#123;</span><br><span class="line">          throw new PlanningException(&quot;The GreedyAgent&quot;</span><br><span class="line">              + &quot; couldn&#39;t find a valid allocation for your request&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; 可以放置当前 RR(stage)</span><br><span class="line">       </span><br><span class="line">        allocations.putAll(curAlloc);</span><br><span class="line">       &#x2F;&#x2F; 组关系是 R_ANY 的话,可以终止后续 stage 的尝试了</span><br><span class="line">        if (type &#x3D;&#x3D; ReservationRequestInterpreter.R_ANY) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果组关系是 R_ODER,R_ODER_NO_GAP，则通过设置 curDeadline 来确保 RR 之间的先后关系 </span><br><span class="line">        &#x2F;&#x2F; 将下一个 RR 的 deadline 设置为当前 RR 分配中最早的开始时间</span><br><span class="line">        if (type &#x3D;&#x3D; ReservationRequestInterpreter.R_ORDER</span><br><span class="line">            || type &#x3D;&#x3D; ReservationRequestInterpreter.R_ORDER_NO_GAP) &#123;</span><br><span class="line">          curDeadline &#x3D; findEarliestTime(curAlloc.keySet());</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 对于 R_ORDER_NO_GAP,确认当前分配和前一个(后向)分配之间没有空隙</span><br><span class="line">          &#x2F;&#x2F; 空隙并非之前理解的完全相等,[t0,t1) 与 [t1,t2)之间的关系,而是不超过 Plan 的时间步长即可 </span><br><span class="line">          if (type &#x3D;&#x3D; ReservationRequestInterpreter.R_ORDER_NO_GAP</span><br><span class="line">              &amp;&amp; oldDeadline &gt; 0) &#123;</span><br><span class="line">            if (oldDeadline - findLatestTime(curAlloc.keySet()) &gt; plan</span><br><span class="line">                .getStep()) &#123;</span><br><span class="line">              throw new PlanningException(&quot;The GreedyAgent&quot;</span><br><span class="line">                  + &quot; couldn&#39;t find a valid allocation for your request&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; keep the variable oldDeadline pointing to the last deadline we</span><br><span class="line">          &#x2F;&#x2F; found</span><br><span class="line">          oldDeadline &#x3D; curDeadline;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有为预订请求分配到&lt;时间,资源&gt;,通过 throws exception 的方式来快速失败</span><br><span class="line">    if (allocations.isEmpty()) &#123;</span><br><span class="line">      throw new PlanningException(&quot;The GreedyAgent&quot;</span><br><span class="line">          + &quot; couldn&#39;t find a valid allocation for your request&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 第三步:  创建预订</span><br><span class="line">  &#x2F;&#x2F; 在[arrival,earliestTime)之间加入了 &quot;零填充&quot;,以表明其是从arrival time 开始的预订</span><br><span class="line">  &#x2F;&#x2F; TODO:在开头和末尾添加&quot;零填充&quot;的意义是什么?没有的话 会有什么问题  </span><br><span class="line">    ReservationRequest ZERO_RES &#x3D;</span><br><span class="line">        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);</span><br><span class="line">    long firstStartTime &#x3D; findEarliestTime(allocations.keySet());</span><br><span class="line">    if (firstStartTime &gt; earliestStart) &#123;</span><br><span class="line">      allocations.put(new ReservationInterval(earliestStart,</span><br><span class="line">          firstStartTime), ZERO_RES);</span><br><span class="line">      firstStartTime &#x3D; earliestStart;</span><br><span class="line">      &#x2F;&#x2F; 译: 考虑在[lastEndTime,deadline)添加&quot;零填充&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 译:这有待验证,其他代理可能也在放置(同步问题);有代理不知道的 SharingPolicy</span><br><span class="line">    ReservationAllocation capReservation &#x3D;</span><br><span class="line">        new InMemoryReservationAllocation(reservationId, contract, user,</span><br><span class="line">            plan.getQueueName(), firstStartTime,</span><br><span class="line">            findLatestTime(allocations.keySet()), allocations,</span><br><span class="line">            plan.getResourceCalculator(), plan.getMinimumAllocation());</span><br><span class="line">    &#x2F;&#x2F; 第四步: 新增或更新已有预订分配 。在 step 3 中解释</span><br><span class="line">    if (oldReservation !&#x3D; null) &#123;</span><br><span class="line">      return plan.updateReservation(capReservation);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return plan.addReservation(capReservation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看上述 第二步:  尝试分配单个 RR<br>这是整个流程中最重要的部分: 决定了用户的每个 RR 能不能放置,放置在哪个时间段,放置几个 container<br>核心思想是: 从 deadline(动态 deadline)开始向后尝试，每次尝试都遍历 duration 时间，判断 duration 时间每个时间步长是否超过了 capacity(即判断 指定大小的资源能不能占用当前时间段，故称”放置”)。然后向后移动一个时间步长，直至剩余时间不足以满足 duration 或者放置了 RR 中所有 container 结束       </p>
<p>[GreedyReservationAgent.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Map&lt;ReservationInterval, ReservationRequest&gt; placeSingleStage(</span><br><span class="line">      Plan plan, RLESparseResourceAllocation tempAssigned,</span><br><span class="line">      ReservationRequest rr, long earliestStart, long curDeadline,</span><br><span class="line">      ReservationAllocation oldResAllocation, final Resource totalCapacity) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;ReservationInterval, ReservationRequest&gt; allocationRequests &#x3D;</span><br><span class="line">        new HashMap&lt;ReservationInterval, ReservationRequest&gt;();</span><br><span class="line"></span><br><span class="line">    Resource gang &#x3D; Resources.multiply(rr.getCapability(), rr.getConcurrency());</span><br><span class="line">    long dur &#x3D; rr.getDuration();</span><br><span class="line">    long step &#x3D; plan.getStep();</span><br><span class="line">    if (dur % step !&#x3D; 0) &#123;</span><br><span class="line">      dur +&#x3D; (step - (dur % step));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将一个并发作为一个原子性的组分配 </span><br><span class="line">    &#x2F;&#x2F; 每次分配资源量: gang&#x3D;capacity * concurrency </span><br><span class="line">    &#x2F;&#x2F;     共计分配次数: gangsToPlace&#x3D; numContainers&#x2F;concurrency  </span><br><span class="line">    int gangsToPlace &#x3D; rr.getNumContainers() &#x2F; rr.getConcurrency();</span><br><span class="line">    int maxGang &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; loop trying to place until we are done, or we are considering</span><br><span class="line">    &#x2F;&#x2F; an invalid range of times</span><br><span class="line">    &#x2F;&#x2F; 循环尝试分配 直至所有的 gang 原子组都分配完或者剩余时间不足以容纳一个 duration</span><br><span class="line">    while (gangsToPlace &gt; 0 &amp;&amp; curDeadline - dur &gt;&#x3D; earliestStart) &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; as we run along we remember how many gangs we can fit, and what</span><br><span class="line">      &#x2F;&#x2F; was the most constraining moment in time (we will restart just</span><br><span class="line">      &#x2F;&#x2F; after that to place the next batch)</span><br><span class="line">      maxGang &#x3D; gangsToPlace;</span><br><span class="line">      long minPoint &#x3D; curDeadline;</span><br><span class="line">      int curMaxGang &#x3D; maxGang;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 尝试在[curDeadline-duration,curDeadline) 长为 duration 的区间内放置未知个 Resource&#x3D;gang 的原子组</span><br><span class="line">      for (long t &#x3D; curDeadline - plan.getStep(); t &gt;&#x3D; curDeadline - dur</span><br><span class="line">          &amp;&amp; maxGang &gt; 0; t &#x3D; t - plan.getStep()) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果之前的预订存在的话,则删除此预订之前的分配(e.g. 更新预订时)</span><br><span class="line">        Resource oldResCap &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">        if (oldResAllocation !&#x3D; null) &#123;</span><br><span class="line">          oldResCap &#x3D; oldResAllocation.getResourcesAtTime(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 计算当前时间点的净可用资源</span><br><span class="line">        Resource netAvailableRes &#x3D; Resources.clone(totalCapacity);</span><br><span class="line">        Resources.addTo(netAvailableRes, oldResCap);</span><br><span class="line">        &#x2F;&#x2F; Plan(reservable queue), 最靠近 t 时刻的累计容量</span><br><span class="line">        Resources.subtractFrom(netAvailableRes,</span><br><span class="line">            plan.getTotalCommittedResources(t)); </span><br><span class="line">        &#x2F;&#x2F;当前预订, 最靠近 t 时刻的累计容量</span><br><span class="line">        Resources.subtractFrom(netAvailableRes,</span><br><span class="line">            tempAssigned.getCapacityAtTime(t));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;计算当前时刻能满足的最大数量的 gang</span><br><span class="line">        curMaxGang &#x3D;</span><br><span class="line">            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),</span><br><span class="line">                totalCapacity, netAvailableRes, gang));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; min&#123;需求的 gang 数量,剩余资源能支撑的 gang 数量&#125;</span><br><span class="line">        curMaxGang &#x3D; Math.min(gangsToPlace, curMaxGang);</span><br><span class="line">	&#x2F;&#x2F; 记住当前尝试的 duration 内,最小数量的 gang 点(即 队列+reservation 占用资源量最多的点)，作为下次尝试的右边界</span><br><span class="line">        if (curMaxGang &lt;&#x3D; maxGang) &#123;</span><br><span class="line">          maxGang &#x3D; curMaxGang;</span><br><span class="line">          &#x2F;&#x2F;资源最紧俏的时间点。当资源充裕时,放置尽可能多的 gang,也会成为当前最紧俏的时间点，作为下次放置的右边界    </span><br><span class="line">          minPoint &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; if we were able to place any gang, record this, and decrement</span><br><span class="line">      &#x2F;&#x2F; gangsToPlace maxGang&#x3D;0:没资源了 时间:范围不够了</span><br><span class="line">      &#x2F;&#x2F; 退出上一个循环过程有两种情况: </span><br><span class="line">      &#x2F;&#x2F; 1.  maxGang&#x3D;0,这个 duration 内有一个时间点 净剩余资源不足以放下一个 gang,那么整个 duration 都不能用了</span><br><span class="line">      &#x2F;&#x2F; 2. t&lt;&#x3D;curDeadline - dur 整个 duration 已经遍历完了。此时 maxGang &gt; 0</span><br><span class="line">      &#x2F;&#x2F; 以上退出都有可能,所以需要中间变量 maxGang来做判断。</span><br><span class="line">      if (maxGang &gt; 0) &#123;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 能在[curDeadline-duration,curDeadline) 内放置下 maxGang 个gang，即 concurrency * maxGang 个 container</span><br><span class="line">        gangsToPlace -&#x3D; maxGang;</span><br><span class="line">        ReservationInterval reservationInt &#x3D;</span><br><span class="line">            new ReservationInterval(curDeadline - dur, curDeadline);</span><br><span class="line">        ReservationRequest reservationRes &#x3D;</span><br><span class="line">            ReservationRequest.newInstance(rr.getCapability(),</span><br><span class="line">                rr.getConcurrency() * maxGang, rr.getConcurrency(),</span><br><span class="line">                rr.getDuration());</span><br><span class="line">        &#x2F;&#x2F; 记住已占用的空间。后续贴出源码</span><br><span class="line">        &#x2F;&#x2F; reservable queue 对应的 Plan 暂时是只读的，除非能将整个 ReservationRequests 放入到计划中。</span><br><span class="line">        tempAssigned.addInterval(reservationInt, reservationRes);</span><br><span class="line">        allocationRequests.put(reservationInt, reservationRes);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 设置下次放置 gang 的右边界。右边界向右无法再安置一个 gang(如上逻辑所述),尝试在右边界向左放置新的 gang</span><br><span class="line">      curDeadline &#x3D; minPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (gangsToPlace &#x3D;&#x3D; 0) &#123;</span><br><span class="line">     &#x2F;&#x2F; 放置了所有的 gang </span><br><span class="line">      return allocationRequests;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 不能为当前 ReservationRequest(RR) 在时间&#x2F;容量&#x2F;并发 限制上放置所有的 gang。</span><br><span class="line">      &#x2F;&#x2F; 此次 RR放置失败,如果不是 R_ANY 的话，可以终止整个 预订请求了。</span><br><span class="line">      for (Map.Entry&lt;ReservationInterval, ReservationRequest&gt; tempAllocation :</span><br><span class="line">        allocationRequests.entrySet()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 清理之前的中间数据。后续贴出源码</span><br><span class="line">        tempAssigned.removeInterval(tempAllocation.getKey(),</span><br><span class="line">            tempAllocation.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Plan 中使用 RLESparseResourceAllocation(以 TreeMap 为核心的稀疏数据结构)保存了当前已生效所有Reservation的累积&lt;时间-资源&gt;状态变化图，通过汇总所有 Reservation 的 RR 中每个分配的时间段(startTime,endTime)和资源量 最终得到了 Plan 随时间变化的已分配资源量。对每个 ReservationSubmissionRequest 请求来说 ，在尝试分配所有 RR 的时候，也使用RLESparseResourceAllocation 来保存临时分配好 RR 累积&lt;时间-资源&gt;状态变化图。  </p>
<p>[RLESparseResourceAllocation.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private TreeMap&lt;Long, Resource&gt; cumulativeCapacity &#x3D; new TreeMap&lt;Long, Resource&gt;();</span><br><span class="line">&#x2F;&#x2F;向 RLESparseResourcAllocation 中增加一个 &lt;时间范围-容量&gt; 的预订</span><br><span class="line">public boolean addInterval(ReservationInterval reservationInterval,</span><br><span class="line">      ReservationRequest capacity) &#123;</span><br><span class="line">    Resource totCap &#x3D;</span><br><span class="line">        Resources.multiply(capacity.getCapability(),</span><br><span class="line">            (float) capacity.getNumContainers());</span><br><span class="line">    if (totCap.equals(ZERO_RESOURCE)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      long startKey &#x3D; reservationInterval.getStartTime();</span><br><span class="line">      long endKey &#x3D; reservationInterval.getEndTime();</span><br><span class="line">      &#x2F;&#x2F;截取 (?,endKey)之间 一段 TreeMap</span><br><span class="line">      NavigableMap&lt;Long, Resource&gt; ticks &#x3D;</span><br><span class="line">          cumulativeCapacity.headMap(endKey, false);</span><br><span class="line">      if (ticks !&#x3D; null &amp;&amp; !ticks.isEmpty()) &#123;</span><br><span class="line">        Resource updatedCapacity &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">        &#x2F;&#x2F; 找到时间上小于等于 startKey 的最大 key 的键值对</span><br><span class="line">        Entry&lt;Long, Resource&gt; lowEntry &#x3D; ticks.floorEntry(startKey);</span><br><span class="line">        if (lowEntry &#x3D;&#x3D; null) &#123;</span><br><span class="line">	   &#x2F;&#x2F; 表明 startKey 即为 RLE 全局最小键(最早)</span><br><span class="line">          cumulativeCapacity.put(startKey, totCap);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          updatedCapacity &#x3D; Resources.add(lowEntry.getValue(), totCap);</span><br><span class="line">          if ((startKey &#x3D;&#x3D; lowEntry.getKey())</span><br><span class="line">              &amp;&amp; (isSameAsPrevious(lowEntry.getKey(), updatedCapacity))) &#123;</span><br><span class="line">             &#x2F;&#x2F; 通过 remove 达到合并区间的。</span><br><span class="line">             &#x2F;&#x2F; e.g. [t0,t1)为 2G, [t1,t2)为 1G;现在在 [t1,t3) 上分配了 1G,那么可以删除 t1 这个点 </span><br><span class="line">            cumulativeCapacity.remove(lowEntry.getKey());</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;新增 一个时间点的容量 记录</span><br><span class="line">            cumulativeCapacity.put(startKey, updatedCapacity);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; [startKey,endKey)时间段内的所有已有记录都要增加 totCap 作为最终状态 </span><br><span class="line">        &#x2F;&#x2F; cumulativeCapacity 维护的是全局状态量,而不是增量或者单个 reservation 的数据</span><br><span class="line">        Set&lt;Entry&lt;Long, Resource&gt;&gt; overlapSet &#x3D;</span><br><span class="line">            ticks.tailMap(startKey, false).entrySet(); &#x2F;&#x2F;startKey 已经增加过了 </span><br><span class="line">        for (Entry&lt;Long, Resource&gt; entry : overlapSet) &#123;</span><br><span class="line">          updatedCapacity &#x3D; Resources.add(entry.getValue(), totCap);</span><br><span class="line">          entry.setValue(updatedCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        cumulativeCapacity.put(startKey, totCap);</span><br><span class="line">      &#125;</span><br><span class="line">      Resource nextTick &#x3D; cumulativeCapacity.get(endKey);</span><br><span class="line">      if (nextTick !&#x3D; null) &#123;</span><br><span class="line">        if (isSameAsPrevious(endKey, nextTick)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 合并 endKey</span><br><span class="line">          cumulativeCapacity.remove(endKey);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">	&#x2F;&#x2F; endKey 时还回资源,所以在 endKey 前面记录都加了 totCap,此处会减去  </span><br><span class="line">        cumulativeCapacity.put(endKey, Resources.subtract(cumulativeCapacity</span><br><span class="line">            .floorEntry(endKey).getValue(), totCap));</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 在 RLESparseResourcAllocation 中删除一个 &lt;时间范围-容量&gt; 的预订</span><br><span class="line">  public boolean removeInterval(ReservationInterval reservationInterval,</span><br><span class="line">      ReservationRequest capacity) &#123;</span><br><span class="line">    Resource totCap &#x3D;</span><br><span class="line">        Resources.multiply(capacity.getCapability(),</span><br><span class="line">            (float) capacity.getNumContainers());</span><br><span class="line">    if (totCap.equals(ZERO_RESOURCE)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      long startKey &#x3D; reservationInterval.getStartTime();</span><br><span class="line">      long endKey &#x3D; reservationInterval.getEndTime();</span><br><span class="line">      NavigableMap&lt;Long, Resource&gt; ticks &#x3D;</span><br><span class="line">          cumulativeCapacity.headMap(endKey, false);</span><br><span class="line">      &#x2F;&#x2F;取出[startKey,endKey)区间内的所有记录</span><br><span class="line">      SortedMap&lt;Long, Resource&gt; overlapSet &#x3D; ticks.tailMap(startKey);</span><br><span class="line">      if (overlapSet !&#x3D; null &amp;&amp; !overlapSet.isEmpty()) &#123;</span><br><span class="line">        Resource updatedCapacity &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">        long currentKey &#x3D; -1;</span><br><span class="line">        for (Iterator&lt;Entry&lt;Long, Resource&gt;&gt; overlapEntries &#x3D;</span><br><span class="line">            overlapSet.entrySet().iterator(); overlapEntries.hasNext();) &#123;</span><br><span class="line">          Entry&lt;Long, Resource&gt; entry &#x3D; overlapEntries.next();</span><br><span class="line">          currentKey &#x3D; entry.getKey();</span><br><span class="line">          &#x2F;&#x2F; 在每个时间点的减去该预订已分配的资源量  </span><br><span class="line">          updatedCapacity &#x3D; Resources.subtract(entry.getValue(), totCap);</span><br><span class="line">          cumulativeCapacity.put(currentKey, updatedCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 左右边界点存在性判断</span><br><span class="line">        Long firstKey &#x3D; overlapSet.firstKey();</span><br><span class="line">        if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) &#123;</span><br><span class="line">          cumulativeCapacity.remove(firstKey);</span><br><span class="line">        &#125;</span><br><span class="line">        if ((currentKey !&#x3D; -1) &amp;&amp; (isSameAsNext(currentKey, updatedCapacity))) &#123;</span><br><span class="line">          cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>举个简单例子，为便于讨论:<br>1.容量方面:  reservable queue 有 &lt;2G,2core&gt;的 capacity，所有预订请求中 container 容量都是&lt;1G,1core&gt;，即 queue 最多有 2 个container<br>2.时间方面: 从 t0至 t5，时间单位是 PlanFollower 的时间步长 step(默认是 1s)。t0 为当前时刻<br>3.请求方面: 已有的 reservation 不讨论 arrival,deadline，只给出 ReservationSystem 给出的分配&lt;时间范围-容量&gt;<br>4.ReservationSystem 已有的预订如下  </p>
<table>
<thead>
<tr>
<th align="left">预订 Id</th>
<th align="left">开始时间</th>
<th align="left">结束时间</th>
<th align="left">占用时间</th>
<th align="left">总资源量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r0</td>
<td align="left">t3</td>
<td align="left">t4</td>
<td align="left">1 个单位</td>
<td align="left">1个 container</td>
</tr>
<tr>
<td align="left">r1</td>
<td align="left">t2</td>
<td align="left">t3</td>
<td align="left">1个单位</td>
<td align="left">2个 container</td>
</tr>
<tr>
<td align="left">r2</td>
<td align="left">t1</td>
<td align="left">t2</td>
<td align="left">1个单位</td>
<td align="left">1个 container</td>
</tr>
</tbody></table>
<p>由此可以绘出 Plan 对应的 RLESparseResourceAllocation 中维护的累计&lt;时间-资源&gt;状态变化图  </p>
<p><img src="/img/pictures/reservation/reservationSystem.png" alt="">  </p>
<p>即: r2 在 t1 时刻拿到1 个 container,因此图中 t1 时刻已分配资源状态是 1 个 container。<br>      r2 在 t2 时刻释放 1 个 container,r1 拿到两个 2 个 container,因此 t2 时刻已分配资源状态是 2 个 container </p>
<p> 假设 ReservationSystem接收到一个请求，ReservationDefinition定义的预订请求内容为：
arrival=t0,deadline=t5<br>ReservationRequests(RRS) 中有一个 ReservationRequest(RR)<br>　　capacity&lt;1G,1core&gt;,numContainer=2,concurrency=1,duration=2<br>ReservationRequestInterpreter=R_ALL</p>
<p>来模拟一下GreedyRerservationAgent#placeSingleStage是如何尝试放置这一个 RR 的<br>初始值:gang=concurrency * capacity=&lt;1G,1core&gt;  gangsToPlace=numContainers/concurrency=2  maxGang=2  </p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">循环开始前 maxGang</th>
<th align="left">开始前 minPoint</th>
<th align="left">开始前 curMaxGang</th>
<th align="left">循环变量 t</th>
<th align="left">净可用资源(队列容量-Plan 累计-当前预订累计)</th>
<th align="left">最终curMaxGang</th>
<th align="left">最终 maxGang</th>
<th align="left">最终 minPoint</th>
<th align="left">是否进行下次循环</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一次循环</td>
<td align="left">2</td>
<td align="left">t5</td>
<td align="left">2</td>
<td align="left">t4</td>
<td align="left">2-0-0=2 contianer</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">t4</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">第二次次循环</td>
<td align="left">2</td>
<td align="left">t4</td>
<td align="left">2</td>
<td align="left">t3</td>
<td align="left">2-1-0=1 contianer</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">t3</td>
<td align="left">否,duration 超限退出</td>
</tr>
</tbody></table>
<p>内层循环结束时，maxGang=1，即可以在[t3,t5)这个时间段放下 1 个 gang，在此为 1 个 container，外层循环将此分配封装成&lt;ReservationInterval,ReservationRequest&gt;加入到 当前预订累计分配的中间数据结构中(tmpAssigned:RLESparseResourceAllocation)。  </p>
<p>此时: gangsToPlace=1,curDeadline=t3,进行下一次外层循环  </p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">循环开始前 maxGang</th>
<th align="left">开始前 minPoint</th>
<th align="left">开始前 curMaxGang</th>
<th align="left">循环变量 t</th>
<th align="left">净可用资源(队列容量-Plan 累计-当前预订累计)</th>
<th align="left">最终curMaxGang</th>
<th align="left">最终 maxGang</th>
<th align="left">最终 minPoint</th>
<th align="left">是否进行下次循环</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一次循环</td>
<td align="left">1</td>
<td align="left">t3</td>
<td align="left">1</td>
<td align="left">t2</td>
<td align="left">2-2-0=0 contianer</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">t2</td>
<td align="left">否,maxGang=0退出</td>
</tr>
</tbody></table>
<p>内层循环结束后，maxGang=0，不能在[t1,t3)时间段放置任何一个 gang。  </p>
<p>此时: gangsToPlace=1,curDeadline=t2，进行下一次外层循环  </p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">循环开始前 maxGang</th>
<th align="left">开始前 minPoint</th>
<th align="left">开始前 curMaxGang</th>
<th align="left">循环变量 t</th>
<th align="left">净可用资源(队列容量-Plan 累计-当前预订累计)</th>
<th align="left">最终curMaxGang</th>
<th align="left">最终 maxGang</th>
<th align="left">最终 minPoint</th>
<th align="left">是否进行下次循环</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一次循环</td>
<td align="left">1</td>
<td align="left">t2</td>
<td align="left">1</td>
<td align="left">t1</td>
<td align="left">2-1-0=1 contianer</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">t1</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">第二次循环</td>
<td align="left">1</td>
<td align="left">t1</td>
<td align="left">1</td>
<td align="left">t0</td>
<td align="left">2-0-0=2 contianer</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">t0</td>
<td align="left">否,duration 超限退出</td>
</tr>
</tbody></table>
<p>内层循环结束后，maxGang=1，即可以在[t0,t2)时间段放下一个 gang，即 1 个 container，外层循环将此分配封装好之后再次加入到 tmpAssigned 中。   </p>
<p>此时: gangsToPlace=0终止了外层循环。
得到的最终结论是: 在[t3,t5)时间段放下一个 container&lt;1G,1core&gt;,在[t0,t2)时间段放下一个 container&lt;1G,1core&gt;。该 RR 整体可以分配，满足组关系 R_ALL，即不考虑用户的情况可以分配该 RR。</p>
<h3 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h3><p>SharingPolicy 提供了一种在预订请求上强制保证统计量的方法，决定接受或者拒绝预订。例如，CapacityOvertimePolicy允许强制保证用户可以在其所有预订中请求的瞬时最大容量，以及一段时期内对资源整体的限制，例如，用户所有的预订最多可以达到瞬时50％集群最大容量，但是在一天内，其平均值不能超过10％。(The SharingPolicy provides a way to enforce invariants on the reservation being accepted, potentially rejecting reservations. For example, the CapacityOvertimePolicy allows enforcement of both instantaneous max-capacity a user can request across all of his/her reservations and a limit on the integral of resources over a period of time, e.g., the user can reserve up to 50% of the cluster capacity instantanesouly, but in any 24h period of time he/she cannot exceed 10% average)  </p>
<p>在 step 2中，ReservationSystem 尝试对预订请求分配时间和资源。若分配成功，则尝试将其加入到 Plan 中或是更新 Plan。    </p>
<p>[GreedyReservationAgent.java] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean computeAllocation(ReservationId reservationId, String user,</span><br><span class="line">      Plan plan, ReservationDefinition contract,</span><br><span class="line">      ReservationAllocation oldReservation) throws PlanningException,</span><br><span class="line">      ContractValidationException &#123;</span><br><span class="line">    LOG.info(&quot;placing the following ReservationRequest: &quot; + contract);</span><br><span class="line">    ......</span><br><span class="line">    ReservationAllocation capReservation &#x3D;</span><br><span class="line">        new InMemoryReservationAllocation(reservationId, contract, user,</span><br><span class="line">            plan.getQueueName(), firstStartTime,</span><br><span class="line">            findLatestTime(allocations.keySet()), allocations,</span><br><span class="line">            plan.getResourceCalculator(), plan.getMinimumAllocation());</span><br><span class="line">    if (oldReservation !&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 更新</span><br><span class="line">      return plan.updateReservation(capReservation);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 新增</span><br><span class="line">      return plan.addReservation(capReservation);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>updateReservation 事务性更新 reservation:  先删除旧的reservation，再新增更新的 reservation(当次ReservationSubmissionRequest)。如果新增失败则再把旧的reservation 回滚。 
所以两处的逻辑的核心在于 addReservation 和 removeReservation。  </p>
<p>[InMemoryPlan.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;按时间段索引 ReservationAllocation 信息  </span><br><span class="line">private TreeMap&lt;ReservationInterval, Set&lt;InMemoryReservationAllocation&gt;&gt; currentReservations &#x3D;</span><br><span class="line">     new TreeMap&lt;ReservationInterval, Set&lt;InMemoryReservationAllocation&gt;&gt;();</span><br><span class="line">  &#x2F;&#x2F; Plan 整体的&lt;时间-资源&gt;状态变化图</span><br><span class="line"> private RLESparseResourceAllocation rleSparseVector;</span><br><span class="line"> &#x2F;&#x2F; 细分用户的&lt;时间-资源&gt;状态变化图</span><br><span class="line"> private Map&lt;String, RLESparseResourceAllocation&gt; userResourceAlloc &#x3D;</span><br><span class="line">     new HashMap&lt;String, RLESparseResourceAllocation&gt;();</span><br><span class="line"> &#x2F;&#x2F; 按 reservationId 索引ReservationAllocation 信息</span><br><span class="line"> private Map&lt;ReservationId, InMemoryReservationAllocation&gt; reservationTable &#x3D;</span><br><span class="line">     new HashMap&lt;ReservationId, InMemoryReservationAllocation&gt;();</span><br><span class="line">     </span><br><span class="line">public boolean addReservation(ReservationAllocation reservation)</span><br><span class="line">     throws PlanningException &#123;</span><br><span class="line">   InMemoryReservationAllocation inMemReservation &#x3D;</span><br><span class="line">       (InMemoryReservationAllocation) reservation;</span><br><span class="line">   if (inMemReservation.getUser() &#x3D;&#x3D; null) &#123;</span><br><span class="line">     String errMsg &#x3D;</span><br><span class="line">         &quot;The specified Reservation with ID &quot;</span><br><span class="line">             + inMemReservation.getReservationId()</span><br><span class="line">             + &quot; is not mapped to any user&quot;;</span><br><span class="line">     LOG.error(errMsg);</span><br><span class="line">     throw new IllegalArgumentException(errMsg);</span><br><span class="line">   &#125;</span><br><span class="line">   writeLock.lock();</span><br><span class="line">   try &#123;</span><br><span class="line">     if (reservationTable.containsKey(inMemReservation.getReservationId())) &#123;</span><br><span class="line">       String errMsg &#x3D;</span><br><span class="line">           &quot;The specified Reservation with ID &quot;</span><br><span class="line">               + inMemReservation.getReservationId() + &quot; already exists&quot;;</span><br><span class="line">       LOG.error(errMsg);</span><br><span class="line">       throw new IllegalArgumentException(errMsg);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F; 第一步: 使用 SharingPolicy 校验 Plan 能否接受该 reservation。后续解释</span><br><span class="line">     policy.validate(this, inMemReservation);</span><br><span class="line">     &#x2F;&#x2F; 第二步: 记录接受 reservation 的时间</span><br><span class="line">     reservation.setAcceptanceTimestamp(clock.getTime());</span><br><span class="line">     &#x2F;&#x2F; 第三步: 内存数据结构维护</span><br><span class="line">     ReservationInterval searchInterval &#x3D;</span><br><span class="line">         new ReservationInterval(inMemReservation.getStartTime(),</span><br><span class="line">             inMemReservation.getEndTime());</span><br><span class="line">     Set&lt;InMemoryReservationAllocation&gt; reservations &#x3D;</span><br><span class="line">         currentReservations.get(searchInterval);</span><br><span class="line">     if (reservations &#x3D;&#x3D; null) &#123;</span><br><span class="line">       reservations &#x3D; new HashSet&lt;InMemoryReservationAllocation&gt;();</span><br><span class="line">     &#125;</span><br><span class="line">     if (!reservations.add(inMemReservation)) &#123;</span><br><span class="line">       LOG.error(&quot;Unable to add reservation: &#123;&#125; to plan.&quot;,</span><br><span class="line">           inMemReservation.getReservationId());</span><br><span class="line">       return false;</span><br><span class="line">     &#125;</span><br><span class="line">     currentReservations.put(searchInterval, reservations);</span><br><span class="line">     reservationTable.put(inMemReservation.getReservationId(),</span><br><span class="line">         inMemReservation);</span><br><span class="line">     &#x2F;&#x2F; 第四步: 维护Plan 整体的&lt;时间-资源&gt;状态变化图;维护细分用户&lt;时间-资源&gt;状态变化图  </span><br><span class="line">     incrementAllocation(inMemReservation);</span><br><span class="line">     LOG.info(&quot;Sucessfully added reservation: &#123;&#125; to plan.&quot;,</span><br><span class="line">         inMemReservation.getReservationId());</span><br><span class="line">     return true;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     writeLock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> private boolean removeReservation(ReservationAllocation reservation) &#123;</span><br><span class="line">   assert (readWriteLock.isWriteLockedByCurrentThread());</span><br><span class="line">   ReservationInterval searchInterval &#x3D;</span><br><span class="line">       new ReservationInterval(reservation.getStartTime(),</span><br><span class="line">           reservation.getEndTime());</span><br><span class="line">   Set&lt;InMemoryReservationAllocation&gt; reservations &#x3D;</span><br><span class="line">       currentReservations.get(searchInterval);</span><br><span class="line">    &#x2F;&#x2F; Plan 成员变量维护的信息 维护</span><br><span class="line">   if (reservations !&#x3D; null) &#123;</span><br><span class="line">     if (!reservations.remove(reservation)) &#123;</span><br><span class="line">       LOG.error(&quot;Unable to remove reservation: &#123;&#125; from plan.&quot;,</span><br><span class="line">           reservation.getReservationId());</span><br><span class="line">       return false;</span><br><span class="line">     &#125;</span><br><span class="line">     if (reservations.isEmpty()) &#123;</span><br><span class="line">       currentReservations.remove(searchInterval);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     String errMsg &#x3D;</span><br><span class="line">         &quot;The specified Reservation with ID &quot; + reservation.getReservationId()</span><br><span class="line">             + &quot; does not exist in the plan&quot;;</span><br><span class="line">     LOG.error(errMsg);</span><br><span class="line">     throw new IllegalArgumentException(errMsg);</span><br><span class="line">   &#125;</span><br><span class="line">   reservationTable.remove(reservation.getReservationId());</span><br><span class="line">   &#x2F;&#x2F; 1.维护细分用户&lt;时间-资源&gt;状态变化图;维护Plan 整体&lt;时间-资源&gt;状态变化图  </span><br><span class="line">   decrementAllocation(reservation);</span><br><span class="line">   LOG.info(&quot;Sucessfully deleted reservation: &#123;&#125; in plan.&quot;,</span><br><span class="line">       reservation.getReservationId());</span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Plan 在 addReservation 和 updateReservation 时都使用了 SharingPolicy 来校验用户资源使用是否违规。CapacityOverTimePolicy 是默认 SharingPolicy，主要校验两个方面资源使用是否违规：瞬时用量不超过 reservable queue capaciy 的 1%(默认);24h(默认)平均用量不超过reservable queue capacity 的 1%(默认)。上述的 1%和 24h 是源码内常量,无法用配置修改      </p>
<p>[CapacityOverTimePolicy.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void validate(Plan plan, ReservationAllocation reservation)</span><br><span class="line">      throws PlanningException &#123;</span><br><span class="line">    ReservationAllocation oldReservation &#x3D;</span><br><span class="line">        plan.getReservationById(reservation.getReservationId());</span><br><span class="line">    if (oldReservation !&#x3D; null</span><br><span class="line">        &amp;&amp; !oldReservation.getUser().equals(reservation.getUser())) &#123;</span><br><span class="line">      throw new MismatchedUserException(</span><br><span class="line">          &quot;Updating an existing reservation with mismatched user:&quot;</span><br><span class="line">              + oldReservation.getUser() + &quot; !&#x3D; &quot; + reservation.getUser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long startTime &#x3D; reservation.getStartTime();</span><br><span class="line">    long endTime &#x3D; reservation.getEndTime();</span><br><span class="line">    long step &#x3D; plan.getStep();</span><br><span class="line">    &#x2F;&#x2F; reservable queue capacity </span><br><span class="line">    Resource planTotalCapacity &#x3D; plan.getTotalCapacity();</span><br><span class="line">    &#x2F;&#x2F; 最大瞬时容量和最大平均容量	</span><br><span class="line">    Resource maxAvgRes &#x3D; Resources.multiply(planTotalCapacity, maxAvg);</span><br><span class="line">    Resource maxInsRes &#x3D; Resources.multiply(planTotalCapacity, maxInst);</span><br><span class="line">    	</span><br><span class="line">    IntegralResource runningTot &#x3D; new IntegralResource(0L, 0L);</span><br><span class="line">    &#x2F;&#x2F; 平均(乘法,即积分面积)容量限制</span><br><span class="line">    IntegralResource maxAllowed &#x3D; new IntegralResource(maxAvgRes);</span><br><span class="line">    maxAllowed.multiplyBy(validWindow &#x2F; step);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查与该分配有重叠区域且长度为 validWindow(24h)的任何窗口,</span><br><span class="line">    &#x2F;&#x2F;提供给用户的资源是否超过瞬时容量和平均容量限制</span><br><span class="line">    for (long t &#x3D; startTime - validWindow; t &lt; endTime + validWindow; t +&#x3D; step) &#123;</span><br><span class="line"></span><br><span class="line">      Resource currExistingAllocTot &#x3D; plan.getTotalCommittedResources(t);</span><br><span class="line">      Resource currExistingAllocForUser &#x3D;</span><br><span class="line">          plan.getConsumptionForUser(reservation.getUser(), t);</span><br><span class="line">      Resource currNewAlloc &#x3D; reservation.getResourcesAtTime(t);</span><br><span class="line">      Resource currOldAlloc &#x3D; Resources.none();</span><br><span class="line">      if (oldReservation !&#x3D; null) &#123;</span><br><span class="line">        currOldAlloc &#x3D; oldReservation.getResourcesAtTime(t);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 所有用户累计 reservation 不能超过 reservable queue  capacity</span><br><span class="line">      Resource inst &#x3D;</span><br><span class="line">          Resources.subtract(Resources.add(currExistingAllocTot, currNewAlloc),</span><br><span class="line">              currOldAlloc);</span><br><span class="line">      if (Resources.greaterThan(plan.getResourceCalculator(),</span><br><span class="line">          planTotalCapacity, inst, planTotalCapacity)) &#123;</span><br><span class="line">        throw new ResourceOverCommitException(&quot; Resources at time &quot; + t</span><br><span class="line">            + &quot; would be overcommitted (&quot; + inst + &quot; over &quot;</span><br><span class="line">            + plan.getTotalCapacity() + &quot;) by accepting reservation: &quot;</span><br><span class="line">            + reservation.getReservationId());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 细分用户 容量不能超过 瞬时容量限制</span><br><span class="line">      if (Resources.greaterThan(plan.getResourceCalculator(),</span><br><span class="line">          planTotalCapacity, Resources.subtract(</span><br><span class="line">              Resources.add(currExistingAllocForUser, currNewAlloc),</span><br><span class="line">              currOldAlloc), maxInsRes)) &#123;</span><br><span class="line">        throw new PlanningQuotaException(&quot;Instantaneous quota capacity &quot;</span><br><span class="line">            + maxInst + &quot; would be passed at time &quot; + t</span><br><span class="line">            + &quot; by accepting reservation: &quot; + reservation.getReservationId());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 相当于增加了 (用户分配容量[已有的+当前reservation更新后的-当前reservation更新前的]) * (一个时间步长)的面积</span><br><span class="line">      &#x2F;&#x2F; 当前reservation更新前的 实际上在 已有的 之中,所以需要减去</span><br><span class="line">      runningTot.add(currExistingAllocForUser);</span><br><span class="line">      runningTot.add(currNewAlloc);</span><br><span class="line">      runningTot.subtract(currOldAlloc);</span><br><span class="line">	</span><br><span class="line">      &#x2F;&#x2F; 老化掉一个24h窗口之前的那个时间点的面积</span><br><span class="line">      if (t &gt; startTime) &#123;</span><br><span class="line">        Resource pastOldAlloc &#x3D;</span><br><span class="line">            plan.getConsumptionForUser(reservation.getUser(), t - validWindow);</span><br><span class="line">        Resource pastNewAlloc &#x3D; reservation.getResourcesAtTime(t - validWindow);</span><br><span class="line">        runningTot.subtract(pastOldAlloc);</span><br><span class="line">        runningTot.subtract(pastNewAlloc);</span><br><span class="line">      &#125;</span><br><span class="line">      if (maxAllowed.compareTo(runningTot) &lt; 0) &#123;</span><br><span class="line">        throw new PlanningQuotaException(</span><br><span class="line">            &quot;Integral (avg over time) quota capacity &quot; + maxAvg</span><br><span class="line">                + &quot; over a window of &quot; + validWindow &#x2F; 1000 + &quot; seconds, &quot;</span><br><span class="line">                + &quot; would be passed at time &quot; + t + &quot;(&quot; + new Date(t)</span><br><span class="line">                + &quot;) by accepting reservation: &quot;</span><br><span class="line">                + reservation.getReservationId());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上述 CapacityOverTimePolicy 用积分面积的方式判断 是否超过平均容量限制的方式，很容易和 RLESparseResourceAllocation 混淆。  RLESparseResourceAllocation 存储的是&lt;时间点-资源&gt;的状态量,是累积状态量不是增量。而积分面积用的是 RLESparseResourceAllocation 绘成的状态图算的积分面积，每向后移动一个时间步长则增加 (RLE 那个时间点资源量) * (一个时间步长) 的积分面积，并减去(RLE 24h前那个时间点资源量) * (一个时间步长)的积分面积。从而达到随着时间增加，积分面积始终是 RLESparseResourceAllocation 图中 [now-24h,now]这个区间的面积，然后和(平均资源限制容量) * (24h) 来比较。很巧妙，第一次见定积分可以在程序中这么用           </p>
<h3 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h3><p>成功验证后，ReservationSystem 会向用户返回一个ReservationId 作为票据
参考 “step 1” 的接口定义和 “step 2” ReservationAgent 分配成功后的处理  </p>
<h3 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h3><p>PlanFollower(线程周期调度)通过动态创建/调整/销毁队列将计划的状态发布到调度程序   </p>
<p>PlanFollower(Runnable) 随 ResourceManager 初始化时创建的 ReservationSystem(服务) 初始化而初始化 启动而启动，调用栈如下  </p>
<p>-&gt;ResourceManager$RMActiveServices#serviceInit<br>　　-&gt;ResourceManager#createReservationSystem<br>　　　　-&gt;AbstractReservationSystem#serviceInit<br>　　　　　　-&gt;AbstractReservationSystem#createPlanFollower  </p>
<p>[AbstractReservationSystem.java]　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void serviceInit(Configuration conf) throws Exception &#123;</span><br><span class="line">  Configuration configuration &#x3D; new Configuration(conf);</span><br><span class="line">  &#x2F;&#x2F; 第一步: 初始化所有的 reservable queue 。</span><br><span class="line">  &#x2F;&#x2F; 指定 SharingPolicy,Planner,capacity,planstep...</span><br><span class="line">  reinitialize(configuration, rmContext);</span><br><span class="line">  &#x2F;&#x2F; 第二步: 创建 PlanFollower。加载类:CS 调度器对应 CapacitySchedulerPlanFollower...</span><br><span class="line">  planFollower &#x3D; createPlanFollower();</span><br><span class="line">  if (planFollower !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 第三步:初始化 PlanFollower </span><br><span class="line">    planFollower.init(clock, scheduler, plans.values());</span><br><span class="line">  &#125;</span><br><span class="line">  super.serviceInit(conf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void serviceStart() throws Exception &#123;</span><br><span class="line">  if (planFollower !&#x3D; null) &#123;</span><br><span class="line">    scheduledExecutorService &#x3D; new ScheduledThreadPoolExecutor(1);</span><br><span class="line">    &#x2F;&#x2F;定时调度,调度周期是 planStepSize(默认1s)</span><br><span class="line">    scheduledExecutorService.scheduleWithFixedDelay(planFollower, 0L,</span><br><span class="line">        planStepSize, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">  super.serviceStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PlanFollower的核心逻辑在 AbstractSchedulerPlanFollower，用于 PlanFollower 与常规调度器同步预订分配的信息，下有 CapacitySchedulerPlanFollower 和 FairCapacityPlanFollower 两个子类。  </p>
<p>[AbstractSchedulerPlanFollower.java] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public synchronized void run() &#123;</span><br><span class="line">    for (Plan plan : plans) &#123;</span><br><span class="line">      synchronizePlan(plan);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">  public synchronized void synchronizePlan(Plan plan) &#123;</span><br><span class="line">     String planQueueName &#x3D; plan.getQueueName();</span><br><span class="line">    if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;Running plan follower edit policy for plan: &quot; + planQueueName);</span><br><span class="line">    &#125;</span><br><span class="line">    long step &#x3D; plan.getStep();</span><br><span class="line">    long now &#x3D; clock.getTime();</span><br><span class="line">    if (now % step !&#x3D; 0) &#123;</span><br><span class="line">      now +&#x3D; step - (now % step);</span><br><span class="line">    &#125;</span><br><span class="line">    Queue planQueue &#x3D; getPlanQueue(planQueueName);</span><br><span class="line">    if (planQueue &#x3D;&#x3D; null) return;</span><br><span class="line">    </span><br><span class="line">    Resource clusterResources &#x3D; scheduler.getClusterResource();</span><br><span class="line">    &#x2F;&#x2F; plan 对应的 reservable queue 的容量</span><br><span class="line">    Resource planResources &#x3D; getPlanResources(plan, planQueue,</span><br><span class="line">        clusterResources);</span><br><span class="line">    &#x2F;&#x2F; 当前正在生效的预订(当前时间介于 startTime 和 endTime 之间的所有 Reservation) </span><br><span class="line">    Set&lt;ReservationAllocation&gt; currentReservations &#x3D;</span><br><span class="line">        plan.getReservationsAtTime(now);</span><br><span class="line">    &#x2F;&#x2F; 当前正在生效的 reservationId 集合</span><br><span class="line">    Set&lt;String&gt; curReservationNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">    &#x2F;&#x2F; 当前正在生效预订的 resource</span><br><span class="line">    Resource reservedResources &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">    &#x2F;&#x2F; 当前正在生效的 reservation;</span><br><span class="line">    int numRes &#x3D; getReservedResources(now, currentReservations,</span><br><span class="line">        curReservationNames, reservedResources);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 reservable queue 的默认队列: xxx-default</span><br><span class="line">    String defReservationId &#x3D; getReservationIdFromQueueName(planQueueName) +</span><br><span class="line">        ReservationConstants.DEFAULT_QUEUE_SUFFIX;</span><br><span class="line">    String defReservationQueue &#x3D; getReservationQueueName(planQueueName,</span><br><span class="line">        defReservationId);</span><br><span class="line">    createDefaultReservationQueue(planQueueName, planQueue,</span><br><span class="line">        defReservationId);</span><br><span class="line">    curReservationNames.add(defReservationId);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第一步: 若正在生效的预约资源量大于队列容量，则删除晚接受的部分预约(accept_time)</span><br><span class="line">    &#x2F;&#x2F; 如果专用于预订资源的队列骤减(或配置或节点宕机),通过调用 Planner 来删除部分已有预约</span><br><span class="line">    if (arePlanResourcesLessThanReservations(clusterResources, planResources,</span><br><span class="line">        reservedResources)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        plan.getReplanner().plan(plan, null);</span><br><span class="line">      &#125; catch (PlanningException e) &#123;</span><br><span class="line">        LOG.warn(&quot;Exception while trying to replan: &#123;&#125;&quot;, planQueueName, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二步: 标记当前预约中，哪些旧的预约需要过期删除，哪些新的预约需要创建队列  </span><br><span class="line">    List&lt;? extends Queue&gt; resQueues &#x3D; getChildReservationQueues(planQueue);</span><br><span class="line">    Set&lt;String&gt; expired &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">    for (Queue resQueue : resQueues) &#123;</span><br><span class="line">      String resQueueName &#x3D; resQueue.getQueueName();</span><br><span class="line">      String reservationId &#x3D; getReservationIdFromQueueName(resQueueName);</span><br><span class="line">      if (curReservationNames.contains(reservationId)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前活跃的预订包含此此预约，因此不用为它创建对应的队列</span><br><span class="line">        curReservationNames.remove(reservationId);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">	&#x2F;&#x2F; 预约已经结束，准备清除</span><br><span class="line">        expired.add(reservationId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 第三步: 清除过期预约。 getMoveOnExpiry 默认为 true</span><br><span class="line">    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,</span><br><span class="line">        defReservationQueue);</span><br><span class="line"></span><br><span class="line">    float totalAssignedCapacity &#x3D; 0f;</span><br><span class="line">    if (currentReservations !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 释放默认队列中的所有多余容量  </span><br><span class="line">      try &#123;</span><br><span class="line">        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);</span><br><span class="line">      &#125; catch (YarnException e) &#123;</span><br><span class="line">        LOG.warn(</span><br><span class="line">            &quot;Exception while trying to release default queue capacity for plan: &#123;&#125;&quot;,</span><br><span class="line">            planQueueName, e);</span><br><span class="line">      &#125;</span><br><span class="line">       &#x2F;&#x2F; 第四步: 增加新的预约或更新已有的预约 对应的队列配额</span><br><span class="line">       &#x2F;&#x2F; 4.1 首先按照(当前时间待分配的容量 - 已有的容量)从小到大(从负到正)的方式排序一次调整 capacity。</span><br><span class="line">       &#x2F;&#x2F; 这种排序方式用以避免分配过程中瞬时容量超出 100%的 capacity(猜测可能是为了减少干扰并发预订和抢占介入)</span><br><span class="line">      List&lt;ReservationAllocation&gt; sortedAllocations &#x3D;</span><br><span class="line">          sortByDelta(</span><br><span class="line">              new ArrayList&lt;ReservationAllocation&gt;(currentReservations), now,</span><br><span class="line">              plan);</span><br><span class="line">      &#x2F;&#x2F; 4.2 为每个队列设置或更新 capacity</span><br><span class="line">      for (ReservationAllocation res : sortedAllocations) &#123;</span><br><span class="line">        String currResId &#x3D; res.getReservationId().toString();</span><br><span class="line">        if (curReservationNames.contains(currResId)) &#123;</span><br><span class="line">          &#x2F;&#x2F; 每个reservationId 对应着常规调度器中 PlanQueue 下的一个 ReservationQueue</span><br><span class="line">          addReservationQueue(planQueueName, planQueue, currResId);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前生效的 ResourceAllocation 需要(或RS已分配给Reservation)的 capacity</span><br><span class="line">        Resource capToAssign &#x3D; res.getResourcesAtTime(now);</span><br><span class="line">        float targetCapacity &#x3D; 0f;</span><br><span class="line">        if (planResources.getMemory() &gt; 0</span><br><span class="line">            &amp;&amp; planResources.getVirtualCores() &gt; 0) &#123;</span><br><span class="line">          &#x2F;&#x2F; 绝对值式的容量相对 PlanQueue capacity 计算相对容量，capToAssign&#x2F;planResources</span><br><span class="line">          targetCapacity &#x3D;</span><br><span class="line">              calculateReservationToPlanRatio(clusterResources,</span><br><span class="line">                  planResources,</span><br><span class="line">                  capToAssign);</span><br><span class="line">        &#125;</span><br><span class="line">        if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(</span><br><span class="line">              &quot;Assigning capacity of &#123;&#125; to queue &#123;&#125; with target capacity &#123;&#125;&quot;,</span><br><span class="line">              capToAssign, currResId, targetCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; set maxCapacity to 100% unless the job requires gang, in which</span><br><span class="line">        &#x2F;&#x2F; case we stick to capacity (as running early&#x2F;before is likely a</span><br><span class="line">        &#x2F;&#x2F; waste of resources)</span><br><span class="line">        &#x2F;&#x2F; 设置最大配额。感觉是无效代码，不明白为什么要设置最大配额 都为1不行吗，为什么按有无并发来设置最大配额  </span><br><span class="line">        float maxCapacity &#x3D; 1.0f;</span><br><span class="line">        if (res.containsGangs()) &#123;</span><br><span class="line">          maxCapacity &#x3D; targetCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">         &#x2F;&#x2F; 设置capacity 和 maxCapacity</span><br><span class="line">          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);</span><br><span class="line">        &#125; catch (YarnException e) &#123;</span><br><span class="line">          LOG.warn(&quot;Exception while trying to size reservation for plan: &#123;&#125;&quot;,</span><br><span class="line">              currResId, planQueueName, e);</span><br><span class="line">        &#125;</span><br><span class="line">        totalAssignedCapacity +&#x3D; targetCapacity;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 第五步: 设置 default queue 的配额(PlanQueue 的剩余配额)</span><br><span class="line">    float defQCap &#x3D; 1.0f - totalAssignedCapacity;</span><br><span class="line">    if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;PlanFollowerEditPolicyTask: total Plan Capacity: &#123;&#125; &quot;</span><br><span class="line">          + &quot;currReservation: &#123;&#125; default-queue capacity: &#123;&#125;&quot;, planResources,</span><br><span class="line">          numRes, defQCap);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);</span><br><span class="line">    &#125; catch (YarnException e) &#123;</span><br><span class="line">      LOG.warn(</span><br><span class="line">          &quot;Exception while trying to reclaim default queue capacity for plan: &#123;&#125;&quot;,</span><br><span class="line">          planQueueName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 第六步: 清理过期的预订记录(now-endTime&gt;24h)</span><br><span class="line">    &#x2F;&#x2F; garbage collect finished reservations from plan</span><br><span class="line">    try &#123;</span><br><span class="line">      plan.archiveCompletedReservations(now);</span><br><span class="line">    &#125; catch (PlanningException e) &#123;</span><br><span class="line">      LOG.error(&quot;Exception in archiving completed reservations: &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;Finished iteration of plan follower edit policy for plan: &quot;</span><br><span class="line">        + planQueueName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Extension: update plan with app states,</span><br><span class="line">    &#x2F;&#x2F; useful to support smart replanning</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先看 第一步: 若正在生效的预约资源量大于队列容量，则删除晚接受的部分预约(accept_time)<br>可用于兼容集群/队列资源骤减的情况，策略是删除最晚接受的部分预约。<br>[SimpleCapacityReplanner.java] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void plan(Plan plan, List&lt;ReservationDefinition&gt; contracts)</span><br><span class="line">      throws PlanningException &#123;</span><br><span class="line">    if (contracts !&#x3D; null) &#123;</span><br><span class="line">      throw new RuntimeException(</span><br><span class="line">          &quot;SimpleCapacityReplanner cannot handle new reservation contracts&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ResourceCalculator resCalc &#x3D; plan.getResourceCalculator();</span><br><span class="line">    Resource totCap &#x3D; plan.getTotalCapacity();</span><br><span class="line">    long now &#x3D; clock.getTime();</span><br><span class="line">    &#x2F;&#x2F; lengthOfCheckZone&#x3D;1h </span><br><span class="line">    for (long t &#x3D; now; (t &lt; plan.getLastEndTime() &amp;&amp; t &lt; (now + lengthOfCheckZone)); t +&#x3D;</span><br><span class="line">        plan.getStep()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用 Plan 所有预订的总资源量 - Plan 的 capacity 来检查是否超限</span><br><span class="line">      Resource excessCap &#x3D;</span><br><span class="line">          Resources.subtract(plan.getTotalCommittedResources(t), totCap);</span><br><span class="line">      if (Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE)) &#123;</span><br><span class="line">         &#x2F;&#x2F; 按照 ReservationAllocation.acceptedAt 做比较，最新接受的在前</span><br><span class="line">        Set&lt;ReservationAllocation&gt; curReservations &#x3D;</span><br><span class="line">            new TreeSet&lt;ReservationAllocation&gt;(plan.getReservationsAtTime(t));</span><br><span class="line">        for (Iterator&lt;ReservationAllocation&gt; resIter &#x3D;</span><br><span class="line">            curReservations.iterator(); resIter.hasNext()</span><br><span class="line">            &amp;&amp; Resources.greaterThan(resCalc, totCap, excessCap, ZERO_RESOURCE);) &#123;</span><br><span class="line">          ReservationAllocation reservation &#x3D; resIter.next();</span><br><span class="line">          &#x2F;&#x2F; 使用 deleteReservation 来调用 Plan.removeReservation 来删除预订。</span><br><span class="line">          &#x2F;&#x2F; removeReservation 的源码分析 见&quot;step 3&quot;</span><br><span class="line">          plan.deleteReservation(reservation.getReservationId());</span><br><span class="line">          excessCap &#x3D;</span><br><span class="line">              Resources.subtract(excessCap, reservation.getResourcesAtTime(t));</span><br><span class="line">          LOG.info(&quot;Removing reservation &quot; + reservation.getReservationId()</span><br><span class="line">              + &quot; to repair physical-resource constraints in the plan: &quot;</span><br><span class="line">              + plan.getQueueName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第二步略，第三步: 清除过期预约。<br>[AbstractSchedulerPlanFollower.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void cleanupExpiredQueues(String planQueueName,</span><br><span class="line">      boolean shouldMove, Set&lt;String&gt; toRemove, String defReservationQueue) &#123;</span><br><span class="line">    for (String expiredReservationId : toRemove) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        String expiredReservation &#x3D; getReservationQueueName(planQueueName,</span><br><span class="line">            expiredReservationId);</span><br><span class="line">         &#x2F;&#x2F; 将过期预约对应的 ReservationQueue 的 capacity 和 maxCapacity 设置为 0 </span><br><span class="line">        setQueueEntitlement(planQueueName, expiredReservation, 0.0f, 0.0f);</span><br><span class="line">        &#x2F;&#x2F; 默认配置为 true。将其中的 APP 移动到同级的 default 队列中(xxx-default)。</span><br><span class="line">        if (shouldMove) &#123;</span><br><span class="line">          moveAppsInQueueSync(expiredReservation, defReservationQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        if (scheduler.getAppsInQueue(expiredReservation).size() &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 移走所有已有 APP 的情况,还有新提交的。暂时保留</span><br><span class="line">          scheduler.killAllAppsInQueue(expiredReservation);</span><br><span class="line">          LOG.info(&quot;Killing applications in queue: &#123;&#125;&quot;, expiredReservation);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 删除队列  </span><br><span class="line">          scheduler.removeQueue(expiredReservation);</span><br><span class="line">          LOG.info(&quot;Queue: &quot; + expiredReservation + &quot; removed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (YarnException e) &#123;</span><br><span class="line">        LOG.warn(&quot;Exception while trying to expire reservation: &#123;&#125;&quot;,</span><br><span class="line">            expiredReservationId, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第四步 先调用 sortByDelta 方法使用 ReservationAllocationComparator 对所有正在生效的预订对应的 ReservationQueue 做排序，然后对所有预订通过 setQueueEntitlement 设置或修正 capacity 和 maxCapacity。<br>第五步 通过 setQueueEntitlement 设置 default queue 的 capacity 和 maxCapacity，占有所有剩余资源<br>[ReservationAllocationComparator.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public int compare(ReservationAllocation lhs, ReservationAllocation rhs) &#123;</span><br><span class="line">      Resource lhsRes &#x3D; getUnallocatedReservedResources(lhs);</span><br><span class="line">      Resource rhsRes &#x3D; getUnallocatedReservedResources(rhs);</span><br><span class="line">      &#x2F;&#x2F; 两个 Resource 先比内存再比虚拟核，小的在前。</span><br><span class="line">      return lhsRes.compareTo(rhsRes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private Resource getUnallocatedReservedResources(</span><br><span class="line">        ReservationAllocation reservation) &#123;</span><br><span class="line">      Resource resResource;</span><br><span class="line">      &#x2F;&#x2F; 查询常规调度器，获取现有 capacity</span><br><span class="line">      Resource reservationResource &#x3D; planFollower</span><br><span class="line">          .getReservationQueueResourceIfExists</span><br><span class="line">              (plan, reservation.getReservationId());</span><br><span class="line">      if (reservationResource !&#x3D; null) &#123;</span><br><span class="line">        resResource &#x3D;</span><br><span class="line">            Resources.subtract(</span><br><span class="line">            &#x2F;&#x2F; 当前时刻需要的 capacity。可能为负</span><br><span class="line">                reservation.getResourcesAtTime(now),</span><br><span class="line">                reservationResource);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resResource &#x3D; reservation.getResourcesAtTime(now);</span><br><span class="line">      &#125;</span><br><span class="line">      return resResource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>[AbstractSchedulerPlanFollower.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void setQueueEntitlement(String planQueueName, String currResId,</span><br><span class="line">      float targetCapacity,</span><br><span class="line">      float maxCapacity) throws YarnException &#123;</span><br><span class="line">    String reservationQueueName &#x3D; getReservationQueueName(planQueueName,</span><br><span class="line">        currResId);</span><br><span class="line">    scheduler.setEntitlement(reservationQueueName, new QueueEntitlement(</span><br><span class="line">        targetCapacity, maxCapacity));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void setEntitlement(String inQueue,</span><br><span class="line">      QueueEntitlement entitlement) throws SchedulerDynamicEditException,</span><br><span class="line">      YarnException &#123;</span><br><span class="line">    LeafQueue queue &#x3D; getAndCheckLeafQueue(inQueue);</span><br><span class="line">    ParentQueue parent &#x3D; (ParentQueue) queue.getParent();</span><br><span class="line">    if (!(queue instanceof ReservationQueue)) &#123;</span><br><span class="line">      throw new SchedulerDynamicEditException(&quot;Entitlement can not be&quot;</span><br><span class="line">          + &quot; modified dynamically since queue &quot; + inQueue</span><br><span class="line">          + &quot; is not a ReservationQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(parent instanceof PlanQueue)) &#123;</span><br><span class="line">      throw new SchedulerDynamicEditException(&quot;The parent of ReservationQueue &quot;</span><br><span class="line">          + inQueue + &quot; must be an PlanQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ReservationQueue newQueue &#x3D; (ReservationQueue) queue;</span><br><span class="line">    float sumChilds &#x3D; ((PlanQueue) parent).sumOfChildCapacities();</span><br><span class="line">    &#x2F;&#x2F; 计算修改后, 所有同级队列的容量之和</span><br><span class="line">    float newChildCap &#x3D; sumChilds - queue.getCapacity() + entitlement.getCapacity();</span><br><span class="line"></span><br><span class="line">    if (newChildCap &gt;&#x3D; 0 &amp;&amp; newChildCap &lt; 1.0f + CSQueueUtils.EPSILON) &#123;</span><br><span class="line">      &#x2F;&#x2F; 设置前后的 capacity 和 maxCapacity 都一样则 不设置</span><br><span class="line">      if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) &#x3D;&#x3D; 0</span><br><span class="line">          &amp;&amp; Math.abs(entitlement.getMaxCapacity() - queue.getMaximumCapacity()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;设置 ReservationQueue 的 capacity 和 maxCapacity </span><br><span class="line">      newQueue.setEntitlement(entitlement);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new SchedulerDynamicEditException(</span><br><span class="line">          &quot;Sum of child queues would exceed 100% for PlanQueue: &quot;</span><br><span class="line">              + parent.getQueueName());</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;Set entitlement for ReservationQueue &quot; + inQueue + &quot;  to &quot;</span><br><span class="line">        + queue.getCapacity() + &quot; request was (&quot; + entitlement.getCapacity() + &quot;)&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>[ReservationQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void setEntitlement(QueueEntitlement entitlement)</span><br><span class="line">      throws SchedulerDynamicEditException &#123;</span><br><span class="line">    float capacity &#x3D; entitlement.getCapacity();</span><br><span class="line">    if (capacity &lt; 0 || capacity &gt; 1.0f) &#123;</span><br><span class="line">      throw new SchedulerDynamicEditException(</span><br><span class="line">          &quot;Capacity demand is not in the [0,1] range: &quot; + capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    setCapacity(capacity);</span><br><span class="line">    setAbsoluteCapacity(getParent().getAbsoluteCapacity() * getCapacity());</span><br><span class="line">    setMaxCapacity(entitlement.getMaxCapacity());</span><br><span class="line">    if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(&quot;successfully changed to &quot; + capacity + &quot; for queue &quot;</span><br><span class="line">          + this.getQueueName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第六步: 清理过期的预订记录<br>[InMemoryPlan.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void archiveCompletedReservations(long tick) &#123;</span><br><span class="line">    LOG.debug(&quot;Running archival at time: &#123;&#125;&quot;, tick);</span><br><span class="line">    List&lt;InMemoryReservationAllocation&gt; expiredReservations &#x3D;</span><br><span class="line">        new ArrayList&lt;InMemoryReservationAllocation&gt;();</span><br><span class="line">    readLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F; 删除过期的保留记录  </span><br><span class="line">      long archivalTime &#x3D; tick - policy.getValidWindow();</span><br><span class="line">      ReservationInterval searchInterval &#x3D;</span><br><span class="line">          new ReservationInterval(archivalTime, archivalTime);</span><br><span class="line">      SortedMap&lt;ReservationInterval, Set&lt;InMemoryReservationAllocation&gt;&gt; reservations &#x3D;</span><br><span class="line">          currentReservations.headMap(searchInterval, true);</span><br><span class="line">      if (!reservations.isEmpty()) &#123;</span><br><span class="line">        for (Set&lt;InMemoryReservationAllocation&gt; reservationEntries : reservations</span><br><span class="line">            .values()) &#123;</span><br><span class="line">          for (InMemoryReservationAllocation reservation : reservationEntries) &#123;</span><br><span class="line">            &#x2F;&#x2F; 结束时间早于当前时间24h </span><br><span class="line">            if (reservation.getEndTime() &lt;&#x3D; archivalTime) &#123;</span><br><span class="line">              expiredReservations.add(reservation);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (expiredReservations.isEmpty()) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      for (InMemoryReservationAllocation expiredReservation : expiredReservations) &#123;</span><br><span class="line">      &#x2F;&#x2F; Plan.removeReservation 源码分析见&quot;step 3&quot;,主要是内存数据结构的维护</span><br><span class="line">        removeReservation(expiredReservation);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>　　　　</p>
<h3 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h3><p>用户可以在(多个)应用程序的 ApplicationSubmissionContext 中指定 ReservationId 提交到可预订的队列(PlanQueue,具有 reservable 属性的 LeafQueue)   </p>
<p>参见 ApplicationSubmissionContext 的数据结构  </p>
<h3 id="step-7"><a href="#step-7" class="headerlink" title="step 7"></a>step 7</h3><p>常规调度器将从创建的特殊队列中提供容器,以确保遵守资源预定。在预订的时间和资源限制下，用户的(多个)应用程序可以以容量/公平的方式共享资源   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void handle(SchedulerEvent event) &#123;</span><br><span class="line">    switch(event.getType()) &#123;</span><br><span class="line">    ......</span><br><span class="line">    case APP_ADDED:</span><br><span class="line">    &#123;</span><br><span class="line">      AppAddedSchedulerEvent appAddedEvent &#x3D; (AppAddedSchedulerEvent) event;</span><br><span class="line">      &#x2F;&#x2F; 解析 APP 提交的队列</span><br><span class="line">      String queueName &#x3D;</span><br><span class="line">          resolveReservationQueueName(appAddedEvent.getQueue(),</span><br><span class="line">              appAddedEvent.getApplicationId(),</span><br><span class="line">              appAddedEvent.getReservationID());</span><br><span class="line">      if (queueName !&#x3D; null) &#123;</span><br><span class="line">        if (!appAddedEvent.getIsAppRecovering()) &#123;</span><br><span class="line">          addApplication(appAddedEvent.getApplicationId(), queueName,</span><br><span class="line">              appAddedEvent.getUser());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          addApplicationOnRecovery(appAddedEvent.getApplicationId(), queueName,</span><br><span class="line">              appAddedEvent.getUser());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private synchronized String resolveReservationQueueName(String queueName,</span><br><span class="line">      ApplicationId applicationId, ReservationId reservationID) &#123;</span><br><span class="line">    CSQueue queue &#x3D; getQueue(queueName);</span><br><span class="line">    if ((queue &#x3D;&#x3D; null) || !(queue instanceof PlanQueue)) &#123;</span><br><span class="line">      return queueName;</span><br><span class="line">    &#125;</span><br><span class="line">    if (reservationID !&#x3D; null) &#123;</span><br><span class="line">      String resQName &#x3D; reservationID.toString();</span><br><span class="line">      &#x2F;&#x2F; 根据 reservationId 获取对应的叶子队列</span><br><span class="line">      queue &#x3D; getQueue(resQName);</span><br><span class="line">      if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        String message &#x3D;</span><br><span class="line">            &quot;Application &quot;</span><br><span class="line">                + applicationId</span><br><span class="line">                + &quot; submitted to a reservation which is not yet currently active: &quot;</span><br><span class="line">                + resQName;</span><br><span class="line">        this.rmContext.getDispatcher().getEventHandler()</span><br><span class="line">            .handle(new RMAppEvent(applicationId,</span><br><span class="line">                RMAppEventType.APP_REJECTED, message));</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!queue.getParent().getQueueName().equals(queueName)) &#123;</span><br><span class="line">        String message &#x3D;</span><br><span class="line">            &quot;Application: &quot; + applicationId + &quot; submitted to a reservation &quot;</span><br><span class="line">                + resQName + &quot; which does not belong to the specified queue: &quot;</span><br><span class="line">                + queueName;</span><br><span class="line">        this.rmContext.getDispatcher().getEventHandler()</span><br><span class="line">            .handle(new RMAppEvent(applicationId,</span><br><span class="line">                RMAppEventType.APP_REJECTED, message));</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">     &#x2F;&#x2F; 使用 ReservationId 对应的 ReservationQueue 来运行任务, 调度容器....</span><br><span class="line">      queueName &#x3D; resQName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果指定了 PlanQueue 但是没指定 reservationId, 会提交到 PlanQueue 的 default 队列执行</span><br><span class="line">      queueName &#x3D; queueName + ReservationConstants.DEFAULT_QUEUE_SUFFIX;</span><br><span class="line">    &#125;</span><br><span class="line">    return queueName;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="step-8"><a href="#step-8" class="headerlink" title="step 8"></a>step 8</h3><p>预订系统可以兼容容量下降的情况。包括拒绝之前接受最晚的预订兼容 reservable queue 的容量骤减，移动预订到 reservable queue 下的 default队列来兼容超时(预订到期但app 没结束)应用<br>参考”step 5”中 AbstractSchedulerPlanFollower#synchronizePlan 方法中对 plan.getReplanner().plan(plan, null) 的调用和cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,
        defReservationQueue)的逻辑  </p>
<p>官网解释可能不实，原文如下:<br>The system includes mechanisms to adapt to drop in cluster capacity. This consists in replanning by “moving” the reservation if possible, or rejecting the smallest amount of previously accepted reservation (to ensure that other reservation will receive their full amount).</p>
<p>但在 hadoop-2.7.3 和 hadoop-3.2.0的 trunk 分支上 AbstractSchedulerPlanFollower/Planner(只有 SimpleReplanner 实现类)逻辑没有改动，且无相应逻辑  </p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><blockquote>
</blockquote>
<ol>
<li>Q: reservable queue 和 leaf queue 区别<br> A: 其一，只有 leaf queue 才能被设置为 reservable queue，通过对 leaf queue 设置 yarn.scheduler.capacity.&lt;queue-path&gt;.reservable=true。其二，在资源管理的层级体系中 reservable queue 对应的数据结构是 PlanQueue extend ParentQueue。即实际上，reservable queue 是在 leaf queue上做了配置的 ParentQueue。  </li>
<li>Q: PlanQueue 和 ReservationQueue 区别<br> A: PlanQueue 对应一个 reservable queue，ReservationQueue 对应一个 ReservationId，PlanQueue 下面可以创建任意个 ReservationQueue; PlanQueue 是 ParentQueue，ReservationQueue 是 LeafQueue。      </li>
<li>Q: 在名称为 X 的 reservable queue 上预订了资源，reservationId=reservationId_001,提交APP 时 Queue 名字填什么？<br> A: Queue 名字填 X,且需要在 ApplicationSubmissionContext 中设置 reservationId。常规调度器会根据 reservationId 解析出对应的 ReservationQueue(名称与 ReservationId 相同)。  </li>
<li>Q: 在1:00-2:00 预约了&lt;100G,10core&gt;的资源 30 分钟，但是在 1:00前或者 2:00后提交任务 会怎样?<br>A:  常规调度器会拒绝任务(APP_REJECT)。因为找不到 reservationId 对应的 ReservationQueue,早于1:00时队列还没创建,晚于2:00时队列被删除。最好在1:00提交，可能会有等待时间(RS 调度时从deadline 向 arrival 尝试分配)       </li>
<li>Q: 任务运行在哪里?<br>A: 任务运行在与 reservationId 同名的 ReservationQueue 中,如果预约时间过去但是 APP 还没运行完成则默认移动 APP 到与 ReservationQueue 同级的 default 队列中  </li>
<li>Q: 能不能把 reservable queue 当做 leaf queue 用? 每个任务都不指定 ReservationId。<br> A: 可以。提交到 reservable queue 但是不指定 ReservationId 的任务都会被移动到 reservable queue 下的 default 队列运行。</li>
<li>Q: 提交到 reservable queue 中的 app 有的指定了 ReservationId,有的没指定。运行时有什么影响?<br> A: PlanQueue 优先为有 ReservationId 队列分配资源,其次再为 default 队列分配资源，即只能使用那些被预订后剩余的资源，在资源紧张时 default 队列无资源或被其他任意 ReservationQueue 抢占。(这是由 ReservationSystem 提供预订的逻辑决定的。1.不预约的资源不在ReservationSystem 管理下,请求预约时 ReservationSystem 会认为自身管理 PlanQueue 所有资源都能预约出去  2.为所有预约分配完资源之后剩下的才归属 default 队列所有)  </li>
<li>Q: Spark On Yarn 如何使用 ReservationSystem?<br> A: 分两个阶段。第一,使用 Client-RM 协议提交 ReservationSubmissionRequest,预订资源并保存回执的 ReservationId。第二，在 Spark On Yarn 程序中指定 ReservationId 字段，但是此阶段 Spark On Yarn 提交程序尚不完善需要修改源代码。目前 Spark On Yarn 程序使用 createApplicationSubmissionContext 方法来封装 ApplicationSubmissionContext 时, 没有针对 ReservationId 的逻辑。如果有需求的话，可以通过 SparkConf 来传递 ReservationId 字符串,在createApplicationSubmissionContext做解析设置 。    <ol start="9">
<li>Q: ReservationSystem 的适用场景<br>A: 1.资源紧张时需要保证重要生产任务运行,可以使用预订资源的方式 。ReservationSystem 在 PlanQueue 下创建 ReservationQueue，将预订需要的绝对值资源量转化 ReservationQueue 在当前时刻的capacity 和 maxCapacity，将任务在此队列中调度，本质上还是 LeafQueue。绝对资源量转化成百分比资源量擦掉了容器数量和大小，不修改开源抢占调度逻辑 不密集抢占抢占的情况下，不能解决大容器调度的问题。  </li>
</ol>
</li>
</ol>
<h2 id="配置预订系统"><a href="#配置预订系统" class="headerlink" title="配置预订系统"></a>配置预订系统</h2><p>目前可以在 yarn-site.xml 中配置开启ReservationSystem,可以在CapacityScheduler 及 FairScheduler中增加对预订的支持，方式是在capacity-scheduler.xml 或者 fair-scheduler.xml中的任何 LeafQueue的”reservable”属性标记为 true，然后该队列的配额就可以用于预订。即使没有预订资源，应用程序仍然可以被提交到该队列上，它们将以”best-effort”的模式运行在 预订资源中运行的作业 剩下的容量中。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/ReservationSystem.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/ReservationSystem.html</a><br><a href="https://www.slideshare.net/Hadoop_Summit/reservations-based-scheduling-if-youre-late-dont-blame-us" target="_blank" rel="noopener">https://www.slideshare.net/Hadoop_Summit/reservations-based-scheduling-if-youre-late-dont-blame-us</a><br><a href="http://gitbook.net/java/util/java_util_treemap.html" target="_blank" rel="noopener">http://gitbook.net/java/util/java_util_treemap.html</a>  </p>
]]></content>
      <tags>
        <tag>源码解析</tag>
        <tag>Yarn 2.7.3</tag>
        <tag>Yarn ReservationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn PreemptionSystem</title>
    <url>/2019-10-05-Yarn%20PreemptionSystem/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Yarn 使用树状层级队列组织方式来管理资源,所有 NodeManager 持有的资源聚集作为资源根队列 root 来代表集群中所有可用资源,root可有有多个子队列,子队列也可以有自己的子队列,树状层级结构的最底层为叶子队列.除 root 外,每个子队列都会持有父队列一定比例的资源 即最低配额(Configured Capacity),以及最多可持有的资源 即最高配额(Configured Max Capacity).以上是 Yarn 的资源组织方式。<br>Yarn 采用两阶段资源调度模型.第一阶段 客户端向 ResourceManager 申请资源启动 ApplicationMaster 作为 Application 的资源协调和 task 监控角色;第二阶段 计算框架驱动角色通过 AppliationMaster 向 ResourceManager 申请资源运行 Worker 角色。 ApplicationMaster 和 Worker角色资源申请及分配都是异步的过程,当 NodeManager 向 ResourceManager 汇报心跳时,附带了自身正在运行和已经完成的 Container 信息,并触发了资源调度器的 NodeUpdate 事件,调度器通过以下过程尝试分配资源     </p>
<ol>
<li>调度器委派 RootQueue 尝试进行资源分配  </li>
<li>RootQueue 委派其 ChildQueue(直至 LeafQueue) 尝试进行资源分配  </li>
<li>遍历 Application 的 ResourceRequest,尝试进行分配或保留  </li>
<li>若分配或保留成功,则同步 Queue/Application/NodeManager 信息.若分配成功,则触发 Container 的转变为 ALLOCATED 状态:RM 已经分配了资源给 APP(Attempt),但是 AM 此时还不知道,直至 AM 和 RM 的下次心跳时 AM 将对此 Container 做调度:下载依赖,准备运行环境,启动主类等;若保留成功,则该节点后续上报心跳时,将会跳过其分配调度,直至其可用资源量达到了保留资源的要求,则被保留的 Container 将会由 RESERVED 转换为 ALLOCATED 状态.保留资源固然在某种程度上算是浪费,但是保证了大 container 的 application 不会饿死      </li>
<li>NM 监控自身运行的所有 Container 状态,对于新启动和运行状态的 Container 以及运行完成的 Container 都会通过心跳告知 RM,RM 同步信息,更新各 Container 状态.若 Container 已经完成则在 RM 端同步 Queue/Application/NodeManager 信息<br>以上是 Yarn 常规调度机制。<br>层级队列中除 root 外,每个队列可以设置其拥有父队列的最低配额和最高配额.最高配额是队列无论在任何情况下都不会超出的用量,最低配额是在队列有任务时尽可能保证的配额.为了提高集群整体的资源利用率,Yarn 引入了抢占机制:  </li>
<li>在队列中无任务运行时,队列没有必要硬遵守保留最低配额,可以将资源借给负载较高的其他队列     </li>
<li>当借出资源的队列接收到了新提交的应用时,将出借的资源收回以满足资源需求<br>以上是Yarn 抢占调度机制。第 1 点由 Yarn 资源调度器来实现;第 2 点只有调度器实现了 PreemptableResourceScheduler 接口,且抢占策略实现了SchedulingEditPolicy时才能实现<br>本文侧重于第 2 点,并试图解决一些在小集群申请大容器的问题    </li>
</ol>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当队列 A 负载比较大时,可以临时借用负载较低队列 B 的资源.但如果有任务提交到 B 队列上,调度平台处理 B 借出的资源的方式一般有三种      </p>
<table>
<thead>
<tr>
<th>处理方式</th>
<th>B 队列应用延时</th>
<th>A 队列应用恢复代价</th>
<th>浪费/重复工作量</th>
</tr>
</thead>
<tbody><tr>
<td>等待应用完成</td>
<td>高</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>杀死应用</td>
<td>无</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>杀死应用部分容器</td>
<td>无</td>
<td>低</td>
<td>一般</td>
</tr>
</tbody></table>
<p>对于借出资源的处理,传统做法一般是等待 A 队列应用完成,将相应的资源还回,这样对于 B 队列应用程序来说有较高的延迟;直接杀死 A 队列应用是一种比较直接的做法,这对于一些特殊服务的影响很大 e.g. 7*24 的流式应用,优先级较高的服务(设计较好的公司会将这部分放在单独的队列甚至单独集群中以保证高可用).Yarn 抢占机制试图不彻底杀死整个应用,在考虑优先级和浪费工作量的情况下,从超分配队列中选出一些容器,释放掉资源达到还回原队列的目的   </p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>源码解析主要参照:  <a href="https://www.aboutyun.com/thread-24628-1-1.html" target="_blank" rel="noopener">https://www.aboutyun.com/thread-24628-1-1.html</a> ,与 Hadoop2.7.3版本有两处差异:<br>1.Hadoop2.7.3 版本在 TempQueue 中加入了untouchableExtra变量,用以保存在队列不允许抢占时的(used absCapacity)值<br>2.Hadoop2.7.3 版本在 计算各队列瓜分空闲资源时加了一些逻辑,在ProportionalCapacityPreemptionPolicy#computeFixpointAllocation中      </p>
<p>computeFixpointAllocation是抢占调度中最核心的逻辑: 计算每个队列的理想容量,决定了是否在该队列抢占及抢占数量的问题<br>[ProportionalCapacityPreemptionPolicy.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 重新计算每个子队列的理想配额,存储于每个子队列的 idealAssigned 成员变量中</span><br><span class="line">* tot_guarant:父队列的理想配额</span><br><span class="line">* qAlloc:父队列的子队列</span><br><span class="line">* unassigned: tot_guarant 的 clone 对象,父队列的理想配额.将此配额分配给所有子队列</span><br><span class="line">* ignoreGuarantee:该批次子队列是否配置了最低配额.将会影响到每个队列在分配空闲配额时的权重.</span><br><span class="line">* 若为 true,没有配置最低配额,则每个队列均分空闲配额</span><br><span class="line">* 若为 false,配置了最低配额,则每个队列按 最低配额&#x2F;sum(最低配额) 的权重分配最低配额  </span><br><span class="line">*&#x2F;</span><br><span class="line">private void computeFixpointAllocation(ResourceCalculator rc,</span><br><span class="line">      Resource tot_guarant, Collection&lt;TempQueue&gt; qAlloc, Resource unassigned, </span><br><span class="line">      boolean ignoreGuarantee) &#123;</span><br><span class="line">      &#x2F;&#x2F; 按照 欠分配的程度,做排序,下文引用了类内容</span><br><span class="line">    TQComparator tqComparator &#x3D; new TQComparator(rc, tot_guarant);</span><br><span class="line">    PriorityQueue&lt;TempQueue&gt; orderedByNeed &#x3D;</span><br><span class="line">                                 new PriorityQueue&lt;TempQueue&gt;(10,tqComparator);</span><br><span class="line">    for (Iterator&lt;TempQueue&gt; i &#x3D; qAlloc.iterator(); i.hasNext();) &#123;</span><br><span class="line">      TempQueue q &#x3D; i.next();</span><br><span class="line">      if (Resources.greaterThan(rc, tot_guarant, q.current, q.guaranteed)) &#123;</span><br><span class="line">       &#x2F;&#x2F; 在配置了队列可抢占后,untouchableExtra&#x3D;0;若队列不可抢占,则超出最低配额的量算到理想配额内</span><br><span class="line">        q.idealAssigned &#x3D; Resources.add(q.guaranteed, q.untouchableExtra);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        q.idealAssigned &#x3D; Resources.clone(q.current);</span><br><span class="line">      &#125;</span><br><span class="line">      Resources.subtractFrom(unassigned, q.idealAssigned);</span><br><span class="line">      Resource curPlusPend &#x3D; Resources.add(q.current, q.pending);</span><br><span class="line">      &#x2F;&#x2F; 欠分配的队列</span><br><span class="line">      if (Resources.lessThan(rc, tot_guarant, q.idealAssigned, curPlusPend)) &#123;</span><br><span class="line">        orderedByNeed.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 欠分配的队列 瓜分 空闲配额  </span><br><span class="line">    while (!orderedByNeed.isEmpty()</span><br><span class="line">       &amp;&amp; Resources.greaterThan(rc,tot_guarant, unassigned,Resources.none())) &#123;</span><br><span class="line">      Resource wQassigned &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">      &#x2F;&#x2F; 计算每个队列应得的权重  </span><br><span class="line">      resetCapacity(rc, unassigned, orderedByNeed, ignoreGuarantee);</span><br><span class="line">      &#x2F;&#x2F; 使用tqComparator得到最欠分配的队列  依据是 idealAssigned&#x2F;absCapacity</span><br><span class="line">      &#x2F;&#x2F;  超分配队列初始值为 1，欠分配队列初始小于 1 </span><br><span class="line">      Collection&lt;TempQueue&gt; underserved &#x3D;</span><br><span class="line">          getMostUnderservedQueues(orderedByNeed, tqComparator);</span><br><span class="line">      for (Iterator&lt;TempQueue&gt; i &#x3D; underserved.iterator(); i.hasNext();) &#123;</span><br><span class="line">        TempQueue sub &#x3D; i.next();</span><br><span class="line">       &#x2F;&#x2F; 当前轮次, 空闲配额*权重  </span><br><span class="line">        Resource wQavail &#x3D; Resources.multiplyAndNormalizeUp(rc,</span><br><span class="line">            unassigned, sub.normalizedGuarantee, Resource.newInstance(1, 1));</span><br><span class="line">        &#x2F;&#x2F;  min&#123;空闲配额*权重,最高配额-理想配额,需求配额&#125;做理想配额的增量;下文引用了 offer 方法  </span><br><span class="line">        Resource wQidle &#x3D; sub.offer(wQavail, rc, tot_guarant);</span><br><span class="line">        &#x2F;&#x2F; 队列得到的最终值,即上面的 min&#123;三元组&#125;</span><br><span class="line">        Resource wQdone &#x3D; Resources.subtract(wQavail, wQidle);</span><br><span class="line">	    &#x2F;&#x2F; 在该轮得到了资源,那么可能还能得到资源,需要参加下一轮迭代;如果没得到资源,那么就不会再得到资源了(等于最高配额或满足了需求)</span><br><span class="line">        if (Resources.greaterThan(rc, tot_guarant,</span><br><span class="line">              wQdone, Resources.none())) &#123;</span><br><span class="line">          orderedByNeed.add(sub);</span><br><span class="line">        &#125;</span><br><span class="line">        Resources.addTo(wQassigned, wQdone);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 经过这一轮迭代后,全局空闲资源变化</span><br><span class="line">      Resources.subtractFrom(unassigned, wQassigned);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Resource offer(Resource avail, ResourceCalculator rc,</span><br><span class="line">        Resource clusterResource) &#123;</span><br><span class="line">        &#x2F;&#x2F; 最大配额-理想配额:表示该队列最多只能拿到这么多额外资源 </span><br><span class="line">      Resource absMaxCapIdealAssignedDelta &#x3D; Resources.componentwiseMax(</span><br><span class="line">                      Resources.subtract(maxCapacity, idealAssigned),</span><br><span class="line">                      Resource.newInstance(0, 0));</span><br><span class="line">      Resource accepted &#x3D; </span><br><span class="line">          Resources.min(rc, clusterResource, </span><br><span class="line">              absMaxCapIdealAssignedDelta,</span><br><span class="line">              &#x2F;&#x2F; avail:是传入值, 全局空闲资源*队列权重,表明在当前迭代 最多可以给的空闲资源</span><br><span class="line">          Resources.min(rc, clusterResource, avail, </span><br><span class="line">           &#x2F;&#x2F; current+pending-idealAssigned:表示 满足队列中所有应用程序需要的 额外资源 </span><br><span class="line">          Resources.subtract(</span><br><span class="line">              Resources.add(current, pending), idealAssigned)));</span><br><span class="line">              </span><br><span class="line">      Resource remain &#x3D; Resources.subtract(avail, accepted);</span><br><span class="line">      &#x2F;&#x2F; 修改当前队列的理想配额  </span><br><span class="line">      Resources.addTo(idealAssigned, accepted);</span><br><span class="line">      return remain;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>欠分配比较器<br>[TQComparator.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class TQComparator implements Comparator&lt;TempQueue&gt; &#123;</span><br><span class="line">    private ResourceCalculator rc;</span><br><span class="line">    private Resource clusterRes;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(TempQueue tq1, TempQueue tq2) &#123;</span><br><span class="line">      if (getIdealPctOfGuaranteed(tq1) &lt; getIdealPctOfGuaranteed(tq2)) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      if (getIdealPctOfGuaranteed(tq1) &gt; getIdealPctOfGuaranteed(tq2)) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算 idealAssigned &#x2F; guaranteed</span><br><span class="line">    private double getIdealPctOfGuaranteed(TempQueue q) &#123;</span><br><span class="line">      double pctOver &#x3D; Integer.MAX_VALUE;</span><br><span class="line">      if (q !&#x3D; null &amp;&amp; Resources.greaterThan(</span><br><span class="line">          rc, clusterRes, q.guaranteed, Resources.none())) &#123;</span><br><span class="line">        pctOver &#x3D;</span><br><span class="line">            Resources.divide(rc, clusterRes, q.idealAssigned, q.guaranteed);</span><br><span class="line">      &#125;</span><br><span class="line">      return (pctOver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p>第一步: 递归获取所有队列的快照信息，重点包括 used/pending/absCapacity/maxAbsCapacity 信息<br>第二步: 设置 root 队列的初始 idealAssigned 为 absCapacity(100%)，以此为依据将 root 队列的 idealAssigned 分摊给各层队列,即第三步<br>第三步: 根据是否配置了最低配额将所有子队列分为两类，优先满足配置了最低配额的队列需求，然后剩余配额满足未配置最低配额队列的需求。对这两类队列进行资源再平衡 迭代计算出每个子队列的理想配额，即第四步。如果子队列的 used &gt; absCapacity * (1+maxIgnoredOverCapacity)，则需要从其中掠夺资源，即第五步<br>第四步: 首先按照当前使用状态(min{used,capacity})，计算出全局空闲资源量(弹性)，获得欠分配的队列；对欠分配的队列集合进行迭代以求出每个队列的 idealAssigned，在每一轮迭代中，设置每个欠分配队列所占的权重(capacity 为依据)，该权重影响队列在获取空闲资源时的增量；优先对欠分配程度最高的队列进行分配，配额为 min{全局空闲资源量 * 队列权重, maxAbsCapacity-idealAssigned, used+pending-idealAssigned},三元组中第一个值表示可分配给队列的额外配额，第二个值表示在不超过最高配额的条件下能接受的最多额外配额，第三个值表示满足应用程序资源需求的额外配额。若满足了队列的需求则将其剔除出欠分配的队列集合<br>第五步: 如果队列 used &gt; absCapacity * (1+maxIgnoredOverCapacity),那么将会释放掉 (used - idealAssigned) * naturalTerminationFactor (自然终止因子,默认0.2)的资源,则按照 <b>最小化影响 application </b>的原则(maxIgnoredOverCapacity 和 naturalTerminationFactor 都是遵从该原则)，优先释放最晚启动的 application 中的最晚分配的container，优先释放 reserved contaienr，优先释放非 AM 的 container。向常规调度器发送抢占 container 事件，并追踪这些 container 的存活时间，如果在超过了 maxWaitTime(15s)之后还没有释放，则强制常规调度器杀死   </p>
<h2 id="一些误区"><a href="#一些误区" class="headerlink" title="一些误区"></a>一些误区</h2><ol>
<li><b>最小化影响 application 原则是抢占过程中最优先考虑的原则</b>        </li>
<li>抢占调度仅仅是所有队列的资源再平衡过程，<b>不为具体的应用程序调度，不为某个容器做分配或保留</b>。从设计模式原则的角度来看是合理的；抢占调度和常规调度松耦合，仅仅使用总线向常规调度器单向发送抢占/杀死容器事件，从架构分层分模块的角度来看也是合理的      </li>
<li>抢占调度<b>不会平衡队列内部的用户资源使用量</b>，用户资源量的平衡应使用 user limit percent 或者 Fair 去做。e.g. user1 先向队列提交了 10 个 application,user2 后向队列提交了 2 个 application ,在抢占调度时 不会把 user1 占用的资源平衡给 user2 使用;且 如果队列要释放资源,那么由于 user2 的 application 后提交,反而会先于 user1 的 application 被抢占    </li>
<li>抢占调度<b>不会使繁忙队列的资源达到最高配额，且不会使空闲队列在任意条件下都得到最低配额</b>。比如,队列 A 占用了队列 B 的所有资源，那么当 B 上有任务提交时，是 A 和 B 一起抢占 B 的最低配额资源，只不过 B 由于欠分配程度(idealAssigned/absCapacity)比较高，在抢占时多次迭代中都更优先于 A，体现出来就是 B 抢回了资源。在 B used + pending &gt;&gt; capacity 且 idealAssigned &lt; capacity 时，B 的 idealAssigned 会尽快收敛到 capacity，然后和 A 一起瓜分剩余资源。        </li>
<li>关于抢占的量，控制该值的配置主要是两个: yarn.resourcemanager.monitor.capacity.preemption.total_preemption_per_round 每轮总抢占 默认 0.1，表示最多每轮抢占的资源占集群总资源的比例。若每轮抢占总量超过此值，则按比例在每个队列中缩减； yarn.resourcemanager.monitor.capacity.preemption.natural_termination_factor 自然终止因子 默认 0.2。考虑到容器自然终止的情况,即使不杀死容器也能在 5 * maxWaitTime(15s) 内收回 95%的资源，所以使用(used - idealAssigned)乘以该因子作为队列内最终抢占资源量，以尽量减少对 已启动 application 的影响  </li>
<li>在 AM-RM 心跳协议 ApplicationMasterProtocol#allocate 中，AM 通过 AllocateRequest更新自己的需求，包括新增与释放 container。RM通过 AllocateResponse 响应请求，包括新分配的容器集合，释放的容器集合和<b>需要 AM 释放的被抢占容器集合</b>。抢占容器的消息类型分为两类:StrictPreemptionContract，AM 必须释放 RM 指定的容器；PreemptionContract。 AM 可以在满足同等大小资源的条件下灵活的替换 RM 指定的待抢占容器。目前 Yarn 采用的是 PreemptionContract类型，从 AM(用户)的角度来看这是可操作性很高的设计:待抢占的 worker 角色可能存储着 shuffle 文件、可能开启着重要的服务…… 恢复这些 worker 可能需要较多额外的工作，所以 RM 让 AM 去选择杀死哪些 container，只关注 AM 能不能还回等量的资源。但是抢占调度里面追踪着 RM 给 AM 指定的待抢占容器集合，如果 AM 替换掉这些容器，那么如果在抢占调度后续的周期发现这些追踪的容器存活大于 maxWaitTime，那么会直接杀死。这是一个有歧义的设计，目前 SparkOnYarn 的 YarnAllocator 没有对 RM 发给 AM 的待抢占容器集合做任何处理，即等同于等待容器超时被 RM 端杀死      </li>
<li><b>抢占得到的资源可能不足以任何资源请求，但是抢占依旧会进行</b>。控制每轮抢占立即得到的资源总量的参数参考 “一些误区 5”。假设集群中只有两个叶子队列 A和B，最低配额都是 50%。初始状态，A 完全空闲，B 负载很高 抢占了 A 的所有资源。A 队列突然被提交了大量应用，那么在第一轮抢占时 B 是超分配的队列，idealAssigned 初值为50%，A是借出所有资源的队列 idealAssigned 初值为 0，但是 idealAssigned/absCapacity 小于 B，是最欠分配的队列 迭代时每轮都优先分配A，A 能得到的资源为: B 队列 (used 100% - idealAssigned 50%) *自然终止因子 0.2 =10%，且不能超过 集群资源100% * 每轮总抢占比例 0.1 = 10%。抢占资源量可能不足以满足任何 ResourceRequest，对于大型集群来说这个问题可能不足为虑，但是在小集群上可能会有一些难以预知的后果，尤其是在小集群上很大的资源需求(e.g. 40G)       </li>
</ol>
<h2 id="小集群大容器问题"><a href="#小集群大容器问题" class="headerlink" title="小集群大容器问题"></a>小集群大容器问题</h2><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p><img src="img/pictures/yarn_preempt/preempt_queue.png" alt="">   </p>
<p>为简单起见，Yarn 使用默认配置且在不考虑: 虚拟核，AM/Worker 的区别和分配/保留的区别。集群有三台服务器，每台服务器有 80G 内存，共计有 240G 的内存资源。有两个叶子队列: A 和 B，最低配额都是 50%，最高配额都是 100%。当 A 负载较高而 B 空闲时，A 使用了整个集群的资源，A 中只有一个应用 app_A，启动的 container 都是 4G 大小。此时有新任务 app_B 提交到队列 B，且需要的资源量大于 B 的最低配额，则在第一次抢占时 B 队列会获得(240-120) * 0.2 自然终止因子 = 24G 的资源，且该轮抢占最大资源量不能超过 240 * 0.1 每轮抢占资源量比例 = 24G，这些抢占的 contaienr 均匀分布在集群的所有节点上，即图中红色 container 为被抢占，绿色 container 为未被抢占    </p>
<ul>
<li><p>场景 1: 假设 app_B 待分配的 container 大小为 40G，每个节点上只有 8G 的空闲资源，不足以启动该 container。且即使这些被抢占的 container 都分布在一个节点上，也不足以启动 40G JVM。 抢占虽然发生，但是 B 没有使用，最终这些抢占释放的资源会被 app_A 利用。这样就陷入了由周期性抢占导致的困局: 抢占调度 平衡资源-&gt; B 无法利用资源-&gt; A 可以利用资源-&gt;A 超分配,B 欠分配-&gt;抢占调度 平衡资源-&gt;…..  具体表现是: B 中的任务无法启动，A及app_A 中最近启动的容器一直处于 被抢占-&gt;启动成为最新-&gt;被抢占……的循环中  </p>
</li>
<li><p>场景 2: 假设 app_B 待分配的 container 大小为 20G，每个节点上只有 8G 的空闲资源，不足以启动 20G 的 container，也会陷入周期性抢占导致的困局。但是如果这些被抢占的 container 分布在一个节点上，足以启动 20G 的 JVM。这是因为 JVM 大小不高于每轮抢占资源总量且不大于每台服务器内存总量的缘故    </p>
</li>
</ul>
<p>注: 常规调度器不希望一个容器占有节点太多的资源，所以对于大 container，不一定会做保留<br>[LeafQueue.java]</p>
<pre><code>boolean shouldAllocOrReserveNewContainer(FiCaSchedulerApp application,
      Priority priority, Resource required) {
    int requiredContainers = application.getTotalRequiredResources(priority);
    int reservedContainers = application.getNumReservedContainers(priority);
    int starvation = 0;
    if (reservedContainers &gt; 0) {
      float nodeFactor = 
          Resources.ratio(
              resourceCalculator, required, getMaximumAllocation()
              );      
       // 使用所需节点的百分比来对大型容器施加偏差…
       // 防止需要使用整个节点的极端情况
      // Use percentage of node required to bias against large containers...
      // Protect against corner case where you need the whole node with
      // Math.min(nodeFactor, minimumAllocationFactor)
      starvation = 
          (int)((application.getReReservations(priority) / (float)reservedContainers) * 
                (1.0f - (Math.min(nodeFactor, getMinimumAllocationFactor())))
               );  
      if (LOG.isDebugEnabled()) {
        LOG.debug(&quot;needsContainers:&quot; +
            &quot; app.#re-reserve=&quot; + application.getReReservations(priority) + 
            &quot; reserved=&quot; + reservedContainers + 
            &quot; nodeFactor=&quot; + nodeFactor + 
            &quot; minAllocFactor=&quot; + getMinimumAllocationFactor() +
            &quot; starvation=&quot; + starvation);
      }
    }
    return (((starvation + requiredContainers) - reservedContainers) &gt; 0);</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><b>方案 1</b><br>对于场景 1，可以从两个角度优化: 提高配置增加每轮抢占资源量及自然终止因子，以提高每轮抢占可以立即得到的资源量；规定应用程序单个容器的大小不能高于每轮抢占资源量。将场景 1 的问题转换问场景 2 的问题<br>对于场景 2，尽可能使被抢占容器分布在同一个节点上，为”最小化影响 Application”，可以在每个节点上按照设定的选取规则尝试抢占容器(但是并未真的杀死)以满足大容器并计算抢占代价(sum(currentTime-containerStartTime))，选择抢占代价最低的节点抢占。  </p>
<p>优点:</p>
<ol>
<li>可以提高启动大容器的可能性，减少大容器调度延时    </li>
</ol>
<p>缺点:  </p>
<ol>
<li>增加每轮抢占资源量和自然终止因子,将增加集群和队列资源在平衡点附近抖动程度(队列释放-&gt;阶梯式下降,队列获取-&gt;阶梯式上升)。最好配合yarn.resourcemanager.monitor.capacity.preemption.max_ignored_over_capacity 属性使用。还是最小化影响原则，减小借用资源不多的队列的抖动      </li>
<li>提高抢占配置，提供能够启动大容器的资源量，将增加了被杀死的容器数量，扩大了影响范围，恢复任务产生的无效工作量也会增加      </li>
<li>尽可能在节点上抢占容器启动大容器，而不是在集群所有节点上抢占最晚启动的应用程序，导致这些节点资源利用率抖动极大  </li>
<li>由于抢占调度和常规调度解耦，抢占调度在节点上抢占出大容器的空间，常规调度也未必在该空间内分配大容器  </li>
</ol>
<p>仅限于抢占频率较低的场景，并使用某些参量(欠分配队列 totalPending, minResourceRequest)来决定 走默认抢占逻辑还是集中在节点上释放资源      </p>
<p><b>方案 2</b>  </p>
<p><a href="https://jiulongzhu.github.io/2019/10/28/Yarn-ReservationSystem/">资源预订系统</a></p>
<p><b>方案 3</b><br>标签系统：对节点进行分类或分组的一种方式，应用程序可以指定在特定标签的节点执行。可以配置资源队列可以访问的节点标签集合，应用程序只能提交到这些包含该标签的队列上来使用这些具有标签的节点的计算资源<br>yarn.scheduler.capacity.&lt;queue_path&gt;.capacity 属性是<b>默认标签</b>(无标签)的资源配置，所有的队列都可以访问无标签的节点；yarn.scheduler.capacity.&lt;queue_path&gt;.accessible-node-labels 属性用于指定队列可访问的标签节点，在不指定的情况下可以继承父队列的权限，若希望让某队列只能访问无标签节点，设置为空格即可；yarn.scheduler.capacity.&lt;queue_path&gt;.accessible-node-labels.&lt;label&gt;.capacity 指定队列可以使用该标签资源的最低配额；yarn.scheduler.capacity.&lt;queue_path&gt;.accessible-node-labels.&lt;label&gt;.maximum-capacity 指定队列可以使用该标签资源的最高配额     </p>
<p>适用场景 </p>
<ol>
<li>机构路由: BU A的任务，只能运行在具有 A 标签的 NM 上    </li>
<li>服务路由: Hbase 的数据分析任务，只能运行在具有 Hbase 标签的 NM 上    </li>
<li>特殊机器: 只有深度学习任务可以运行在具有 GPU 标签的 NM 上        </li>
</ol>
<p>新增或修改一些节点，配置其标签，并设置仅有某些队列具有该标签资源的使用权限，大内存应用程序专用    </p>
<p>优点:</p>
<ol>
<li>可以运行大内存应用，且 SLA 高  </li>
</ol>
<p>缺点:  </p>
<ol>
<li>标签资源空闲时其他应用无法使用，集群资源利用率相对较低  </li>
<li>需要额外的服务器成本  </li>
</ol>
<h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><ul>
<li>yarn.resourcemanager.scheduler.monitor.enable<br>设置为 true ,启用抢占  </li>
<li>yarn.resourcemanager.scheduler.monitor.policies<br>启用抢占时,抢占策略主类.RM 将配置的主类启动在独立线程中,周期性的执行抢占.默认是org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.ProportionalCapacityPreemptionPolicy  </li>
<li>yarn.resourcemanager.monitor.capacity.preemption.monitoring_interval<br>周期性执行抢占策略的间隔,单位毫秒,默认是 3000  </li>
<li>yarn.resourcemanager.monitor.capacity.preemption.max_wait_before_kill<br>自容器被标记为被抢占到抢占策略强制杀死该容器的时间,单位毫秒,默认15000.留给 AM 灵活杀死 container 的时间,如果希望快速收回资源可以适当调小    </li>
<li>yarn.resourcemanager.monitor.capacity.preemption.total_preemption_per_round<br>每轮抢占最大资源总量占集群无标签资源的比例,默认 0.1. 即每轮抢占最多可以收回相当于集群无标签资源总量的10%,若每轮抢占资源量超过此值,则按比例在每个待抢占队列进行缩减    </li>
<li>yarn.resourcemanager.monitor.capacity.preemption.max_ignored_over_capacity<br>忽略抢占的阈值,默认 0.1.当队列资源使用量 used &gt; absCapacity(1+0.1)时,认为其应该还回资源,才会抢占容器.用于避免资源消耗和配额的剧烈波动,最小化影响      </li>
<li>yarn.resourcemanager.monitor.capacity.preemption.natural_termination_factor<br>自然终止因子,统计发现值为 0.5 或者为 0 时,都会在 5* 15秒(上述第三配置项)内收回 95%的资源,默认 0.2.为每个队列设置抢占目标后,再乘以此值作为最终的抢占目标.假设第一周期,某队列待抢占值为 10G,那么最终抢占为 2G.第二周期待抢占值为 7G,最终抢占为 1.4G…以一种平滑的方式回收,降低波动.可以适当增加此值以加快回收速度  </li>
</ul>
<h2 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h2><ol>
<li>方案设计时考虑了很多，从尝试借鉴 CPU 抢占、内存 SWAP 模式、用户体验、架构分层等角度思考设计一个抢占调度系统的想法。有时间再整理吧     </li>
<li>关于开源抢占系统通用优化的初步想法<br>调度系统抢占的容器先不杀死，而是打一个标记，比如:MARK_PREEMPTED_KILL,在资源分配时优先使用这些标记的节点或者资源紧缺时使用 以尽可能使容器能自然终止(类似 jvm软引用)，无资源分配时则不杀死。其一可以保证 在周期性抢占造成的困局中，队列使用不到这些资源时，这些资源不会被反复无效调度，而是继续运行任务；其二 或许能提高资源抢占相应速度，代价是需要完善常规调度的逻辑，分配时如何处理MARK_PREEMPTED_KILL，保留时如何处理MARK_PREEMPTED_KILL…    </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/NodeLabel.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/NodeLabel.html</a><br><a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html#Capacity\_Scheduler\_container\_preemption" target="_blank" rel="noopener">https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html#Capacity\_Scheduler\_container\_preemption</a><br><a href="https://www.aboutyun.com/thread-24628-1-1.html" target="_blank" rel="noopener">https://www.aboutyun.com/thread-24628-1-1.html</a></p>
]]></content>
      <tags>
        <tag>源码解析</tag>
        <tag>Yarn 2.7.3</tag>
        <tag>Yarn PreemptionSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn movetoqueue 导致的UI指标错误的修复思路</title>
    <url>/2019-09-15-Yarn:movetoqueue%E5%AF%BC%E8%87%B4%E7%9A%84UIcontainer%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>多个线上运行状态私有云的某些资源队列,在无任何 Application 提交及运行、资源队列完全空闲的情况下, 
Used Capacity、Absolute Used Capacity、Used Resource、Num Containers指标非零异常  </p>
<a id="more"></a>

<blockquote>
</blockquote>
<p>在Yarn ResourceManager管理界面中,有 scheduler 选项卡,展示了Yarn 当前使用的调度器及各资源队列的信息(YarnUI-&gt;scheduler-&gt;Application Queue),其中每项指标代表的含义是:<br>Queue State: 表示当前队列的状态,有 RUNNING/STOPPED 两种状态<br>Used Capacity: 表示当前队列已使用的资源占当前队列总资源的百分比<br>Configured Capacity: 表示当前队列的资源占父队列资源的百分比<br>Configured Max Capacity: 表示当前队列资源最大能占父队列资源的百分比<br>Absolute Used Capacity: 表示当前队列已使用的资源占 root 队列资源(整个集群)的百分比<br>Absolute Configured Capacity: 表示当前队列的资源占 root 队列总资源的百分比<br>Absolute Configured Max Capacity: 表示当前的队列的资源最大能占 root 队列的百分比<br>Used Resources: 表示当前队列已使用的资源总量(资源以内存和虚拟核形态表示,基本调度单位)<br>Num Schedulable Applications: 表示当前队列调度的应用个数
Num Non-Schedulable Applications: 表示当前队列没有调度(积压,pending)的应用个数<br>Num Containers: 表示当前队列已经启动的 container 个数<br>Max Applications: 表示当前队列最大并发调度应用个数<br>Max Applications Per User: 表示当前队列对每个用户最大并发调度应用个数<br>Max Application Master Resources: 表示所有 Application 的 AM 可使用资源量之和的最大值<br>Used Application Master Resources: 表示当前队列中所有 Application 的 AM 使用资源量之和<br>Max Application Master Resources Per User: 表示当前队列中每个用户的 Application 的 AM 使用资源量之和的最大值<br>Configured Minimum User Limit Percent: 表示队列每个用户分配的最低资源百分比(资源保障)<br>Configured User Limit Factor: 表示每个用户能占用的队列资源的百分比<br>Accessible Node Labels:  表示当前队列可在哪些节点上分配资源 (*为全部节点)<br>Preemption: 是否允许资源抢占  </p>
<p>指标可分为两类:配置型指标,静态数据 不会变化,如 Configured Capacity;状态型指标,动态数据 随应用的提交运行结束而变化,如 Used Capacity.<br>运行时异常指标如下图,无 Application 运行的情况下,low 队列状态型指标为负</p>
<p><img src="/img/pictures/negative/negative_e7a766275896.png" alt=""></p>
<h2 id="先期判断"><a href="#先期判断" class="headerlink" title="先期判断"></a>先期判断</h2><h3 id="指标关联的变量定位"><a href="#指标关联的变量定位" class="headerlink" title="指标关联的变量定位"></a>指标关联的变量定位</h3><p>线上 hadoop 版本: hadoop 2.7.3<br>Yarn ResourceManager 管理界面启动的入口是org.apache.hadoop.yarn.server.resourcemanager.ResourceManager#startWebApp()<br>[ResourceManager.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void startWepApp() &#123;</span><br><span class="line">	....</span><br><span class="line">    Builder&lt;ApplicationMasterService&gt; builder &#x3D; </span><br><span class="line">        WebApps</span><br><span class="line">            .$for(&quot;cluster&quot;, ApplicationMasterService.class, masterService,</span><br><span class="line">                &quot;ws&quot;)</span><br><span class="line">            .with(conf)</span><br><span class="line">            .withHttpSpnegoPrincipalKey(</span><br><span class="line">                YarnConfiguration.RM_WEBAPP_SPNEGO_USER_NAME_KEY)</span><br><span class="line">            .withHttpSpnegoKeytabKey(</span><br><span class="line">                YarnConfiguration.RM_WEBAPP_SPNEGO_KEYTAB_FILE_KEY)</span><br><span class="line">            .at(webAppAddress);</span><br><span class="line">   	....</span><br><span class="line">    webApp &#x3D; builder.start(new RMWebApp(this));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RMWebApp 主要逻辑是使用 Google Guice 做依赖注入,并分发请求绑定后台逻辑,大致相当于 SpringMVC 系统中的 Dispatcher 的角色<br>对 Yarn UI界面左侧边栏 scheduler 的请求会转发给 RmController#scheduler()方法处理<br>[RMWebApp.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setup() &#123;</span><br><span class="line">    ...</span><br><span class="line">    bind(RMWebApp.class).toInstance(this);</span><br><span class="line">    if (rm !&#x3D; null) &#123;</span><br><span class="line">      bind(ResourceManager.class).toInstance(rm);</span><br><span class="line">      bind(ApplicationBaseProtocol.class).toInstance(rm.getClientRMService());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    route(&quot;&#x2F;scheduler&quot;, RmController.class, &quot;scheduler&quot;);</span><br><span class="line">    route(pajoin(&quot;&#x2F;queue&quot;, QUEUE_NAME), RmController.class, &quot;queue&quot;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RmController#scheduler() 先获取到 Guice 注入的 ResourceManager,然后依据 RM 使用的调度器做页面渲染.<br>页面渲染逻辑的入口是CapacitySchedulerPage#render()<br>[RmController.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void scheduler() &#123;</span><br><span class="line">    ...</span><br><span class="line">    ResourceManager rm &#x3D; getInstance(ResourceManager.class);</span><br><span class="line">    ResourceScheduler rs &#x3D; rm.getResourceScheduler();</span><br><span class="line">    if (rs &#x3D;&#x3D; null || rs instanceof CapacityScheduler) &#123;</span><br><span class="line">      setTitle(&quot;Capacity Scheduler&quot;);</span><br><span class="line">      &#x2F;&#x2F;渲染</span><br><span class="line">      render(CapacitySchedulerPage.class);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rs instanceof FairScheduler) &#123;</span><br><span class="line">      setTitle(&quot;Fair Scheduler&quot;);</span><br><span class="line">      render(FairSchedulerPage.class);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line"> protected void render(Class&lt;? extends View&gt; cls) &#123;</span><br><span class="line">    context().rendered &#x3D; true;</span><br><span class="line">    getInstance(cls).render();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>泛型上界是 View,调用栈是:<br>View#render()<br>&ensp;&ensp;-&gt;HtmlPage#render()<br>&ensp;&ensp;&ensp;&ensp;&ensp;-&gt;TwoColumnLayout#render(html)<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-&gt;CapacitySchedulerPage#content()<br>[CapacitySchedulerPage.java] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Class&lt;? extends SubView&gt; content() &#123;</span><br><span class="line">    return QueuesBlock.class;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>QueuesBlock 是 CapacitySchedulerPage 的内部类,用于展示CapacityScheduler 的 DashBoard 信息,包含队列、标签、应用概览信息,并构建根队列 root 来做为后续递归渲染的起点<br>[QueuesBlock.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class QueuesBlock extends HtmlBlock &#123;</span><br><span class="line">    final CapacityScheduler cs;</span><br><span class="line">    final CSQInfo csqinfo;</span><br><span class="line">    private List&lt;NodeLabel&gt; nodeLabelsInfo;</span><br><span class="line">    </span><br><span class="line">    public void render(Block html) &#123;</span><br><span class="line">        ...</span><br><span class="line">        float used &#x3D; 0;</span><br><span class="line">        if (null &#x3D;&#x3D; nodeLabelsInfo</span><br><span class="line">            || (nodeLabelsInfo.size() &#x3D;&#x3D; 1 &amp;&amp; nodeLabelsInfo.get(0)</span><br><span class="line">                .getLabelName().isEmpty())) &#123;</span><br><span class="line">                &#x2F;&#x2F;创建根队列,作为后续渲染的起点</span><br><span class="line">          CSQueue root &#x3D; cs.getRootQueue();</span><br><span class="line">          CapacitySchedulerInfo sinfo &#x3D;</span><br><span class="line">              new CapacitySchedulerInfo(root, new NodeLabel(</span><br><span class="line">                  RMNodeLabelsManager.NO_LABEL));</span><br><span class="line">          csqinfo.csinfo &#x3D; sinfo;</span><br><span class="line">          csqinfo.qinfo &#x3D; null;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">          ul.li().</span><br><span class="line">            ...</span><br><span class="line">            _(QueueBlock.class)._();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          for (NodeLabel label : nodeLabelsInfo) &#123;</span><br><span class="line">            ....</span><br><span class="line">            underLabel.li().</span><br><span class="line">            ...</span><br><span class="line">            _(QueueBlock.class)._()._();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;Application List 界面</span><br><span class="line">      ul._()._().</span><br><span class="line">      script().$type(&quot;text&#x2F;javascript&quot;).</span><br><span class="line">          _(&quot;$(&#39;#cs&#39;).hide();&quot;)._()._().</span><br><span class="line">      _(RMAppsBlock.class);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从 rootQueue 开始递归,Queue 检查自身有没有子队列 subQueues,若无则其本身为 LeafQueue,使用 LeafQueueInfoBlock#render()渲染叶子队列信息,使用 QueueUsersInfoBlock#render()渲染队列下的用户信息;若有子队列则其本身为ParentQueue,使用 QueueBlock#render()渲染,直至叶子队列<br>[QueuesBlock.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void render(Block html) &#123;</span><br><span class="line">      ArrayList&lt;CapacitySchedulerQueueInfo&gt; subQueues &#x3D;</span><br><span class="line">          (csqinfo.qinfo &#x3D;&#x3D; null) ? csqinfo.csinfo.getQueues().getQueueInfoList()</span><br><span class="line">              : csqinfo.qinfo.getQueues().getQueueInfoList();</span><br><span class="line">      UL&lt;Hamlet&gt; ul &#x3D; html.ul(&quot;#pq&quot;);</span><br><span class="line">      for (CapacitySchedulerQueueInfo info : subQueues) &#123;</span><br><span class="line">  	  ...</span><br><span class="line">          if (info.getQueues() &#x3D;&#x3D; null) &#123;</span><br><span class="line">          li.ul(&quot;#lq&quot;).li()._(LeafQueueInfoBlock.class)._()._();</span><br><span class="line">          li.ul(&quot;#lq&quot;).li()._(QueueUsersInfoBlock.class)._()._();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          li._(QueueBlock.class);</span><br><span class="line">        &#125;</span><br><span class="line">  	...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由于异常指标位于叶子队列信息中,所以暂且不看QueueUsersInfoBlock.java<br>[LeafQueueInfoBlock.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String nodeLabel;</span><br><span class="line">final CapacitySchedulerLeafQueueInfo lqinfo;</span><br><span class="line">@Inject LeafQueueInfoBlock(ViewContext ctx, CSQInfo info) &#123;</span><br><span class="line">      super(ctx);</span><br><span class="line">      lqinfo &#x3D; (CapacitySchedulerLeafQueueInfo) info.qinfo;</span><br><span class="line">      nodeLabel &#x3D; info.label;</span><br><span class="line">    &#125;</span><br><span class="line">protected void render(Block html) &#123;</span><br><span class="line">      if (nodeLabel &#x3D;&#x3D; null) &#123;</span><br><span class="line">        renderLeafQueueInfoWithoutParition(html);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        renderLeafQueueInfoWithPartition(html);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">虽然按照 nodeLabel 做了分支,但是核心逻辑都是</span><br><span class="line">renderQueueCapacityInfo方法和renderCommonLeafQueueInfo方法,</span><br><span class="line">这两个方法分别展示不同方面的指标,和 Yarn UI 展示的指标相同 </span><br><span class="line"></span><br><span class="line">private void renderQueueCapacityInfo(final ResponseInfo ri) &#123;</span><br><span class="line">      ri.</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Used Capacity:&quot;, percent(lqinfo.getUsedCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Configured Capacity:&quot;, percent(lqinfo.getCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Configured Max Capacity:&quot;, percent(lqinfo.getMaxCapacity() &#x2F; 100)).</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Absolute Used Capacity:&quot;, percent(lqinfo.getAbsoluteUsedCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Absolute Configured Capacity:&quot;, percent(lqinfo.getAbsoluteCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Absolute Configured Max Capacity:&quot;, percent(lqinfo.getAbsoluteMaxCapacity() &#x2F; 100)).</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Used Resources:&quot;, lqinfo.getResourcesUsed().toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  private void renderCommonLeafQueueInfo(final ResponseInfo ri) &#123;</span><br><span class="line">      ri.</span><br><span class="line">      _(&quot;Num Schedulable Applications:&quot;, Integer.toString(lqinfo.getNumActiveApplications())).</span><br><span class="line">      _(&quot;Num Non-Schedulable Applications:&quot;, Integer.toString(lqinfo.getNumPendingApplications())).</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Num Containers:&quot;, Integer.toString(lqinfo.getNumContainers())).</span><br><span class="line">      _(&quot;Max Applications:&quot;, Integer.toString(lqinfo.getMaxApplications())).</span><br><span class="line">      _(&quot;Max Applications Per User:&quot;, Integer.toString(lqinfo.getMaxApplicationsPerUser())).</span><br><span class="line">      _(&quot;Max Application Master Resources:&quot;, lqinfo.getAMResourceLimit().toString()).</span><br><span class="line">      _(&quot;Used Application Master Resources:&quot;, lqinfo.getUsedAMResource().toString()).</span><br><span class="line">      _(&quot;Max Application Master Resources Per User:&quot;, lqinfo.getUserAMResourceLimit().toString()).</span><br><span class="line">      _(&quot;Configured Minimum User Limit Percent:&quot;, Integer.toString(lqinfo.getUserLimit()) + &quot;%&quot;).</span><br><span class="line">      _(&quot;Configured User Limit Factor:&quot;, StringUtils.format(</span><br><span class="line">          &quot;%.1f&quot;, lqinfo.getUserLimitFactor())).</span><br><span class="line">      _(&quot;Accessible Node Labels:&quot;, StringUtils.join(&quot;,&quot;, lqinfo.getNodeLabels())).</span><br><span class="line">      _(&quot;Preemption:&quot;, lqinfo.getPreemptionDisabled() ? &quot;disabled&quot; : &quot;enabled&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常指标计算方式"><a href="#异常指标计算方式" class="headerlink" title="异常指标计算方式"></a>异常指标计算方式</h3><p>注:集群没有使用 label 系统,所以下述的 nodeLabel 视为””即可</p>
<ul>
<li><p>Used Capacity</p>
<p>  [AbstractCSQueue.java]</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final synchronized float getUsedCapacity(final String nodeLabel) &#123;</span><br><span class="line">    &#x2F;&#x2F;集群所有资源 * 该队列的绝对容量百分比 &#x3D; 该队列的绝对容量 </span><br><span class="line">    Resource availableToQueue &#x3D;</span><br><span class="line">        Resources.multiply(</span><br><span class="line">            labelManager.getResourceByLabel(nodeLabel, this.clusterResource),</span><br><span class="line">            queueCapacities.getAbsoluteCapacity(nodeLabel));</span><br><span class="line">   &#x2F;&#x2F;使用 queueUsage 中记录的使用量除以该队列的绝对容量得到队列的 Used Capacity</span><br><span class="line">   &#x2F;&#x2F;queueUsage 的类型为 ResourceUsage</span><br><span class="line">    return</span><br><span class="line">        Resources.divide(resourceCalculator, this.clusterResource,</span><br><span class="line">            queueUsage.getUsed(nodeLabel), availableToQueue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Absolute Used Capacity</p>
<p>  算法和Used Capacity算法相似,只是分母不同,AbsoluteUsedCapacity 计算时分母是整个集群的资源  </p>
<p>  [AbstractCSQueue.java]</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final synchronized float getAbsoluteUsedCapacity(final String nodeLabel) &#123;</span><br><span class="line">   Resource labeledResources &#x3D;</span><br><span class="line">              labelManager.getResourceByLabel(nodeLabel, this.clusterResource);</span><br><span class="line">   return Resources.divide(resourceCalculator, this.clusterResource,</span><br><span class="line">       queueUsage.getUsed(nodeLabel), labeledResources);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Used Resource</p>
<p>  &ensp;&ensp;使用的是Queue 按 Label 记录的资源信息<br>  queueResourceUsage.getUsed(nodeLabel)  </p>
</li>
<li><p>Num Containers</p>
<p>  &ensp;&ensp;使用的 Queue 本身记录的信息<br>  numContainers = leafQueue.getNumContainers();  </p>
</li>
</ul>
<blockquote>
</blockquote>
<p>综上所述:<br>四个指标中,队列层面的Used Capacity 、Absolute Used Capacity 、Used Resource 均和 ResourceUsage维护 used 资源信息有关;numContainer 是 LeafQueue 自身维护的 container 数量.这些指标的变化逻辑在 AbstractCSQueue的 assignContainer()和 releaseContainer()中,即和 container 的释放/申请有关.
而在队列完全空闲的时候,四个指标为负,初步定位可能是 Container 重复释放或无效释放的原因.</p>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><h3 id="猜测重复释放"><a href="#猜测重复释放" class="headerlink" title="猜测重复释放"></a>猜测重复释放</h3><p>在已经出现指标异常的私有云上,对出现异常时日期前后的 resourcemanager 日志进行分析,检测其中出现”Assigned container”和”Released  container”字符串的数量,从日志层面对 container 的申请和释放次数做一个简单的判断.这种方式适用于集群作业周期性较强且没有跨天任务运行的情况.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egrep -o &quot;Assigned container&quot; resourcemanager.log | sort | uniq -c</span><br><span class="line">egrep -o &quot;Released container&quot; resourcemanager.log | sort | uniq -c</span><br></pre></td></tr></table></figure>

<p>从结果上看,”Assigned container”和”Released container”字符串出现次数是一致的,可能不是重复释放的问题  </p>
<h3 id="猜测无效释放"><a href="#猜测无效释放" class="headerlink" title="猜测无效释放"></a>猜测无效释放</h3><p>对无效释放的猜想源自于重复释放和 rm 日志中的”Null container completed…”,猜测可能对于 nullContainer 处理有问题,修改了系统维护的信息, 导致了负值    </p>
<p>UI 的 kill 操作,命令行 yarn application –kill 和 RMApp 的正常结束都会释放 container,由 APP_ATTEMPT_REMOVED 事件触发,
回收 AppAttemp 持有的runningContainer 和 reservedContainer,核心逻辑在 CapacityScheduler#completedContainer()方法,但是其中对于 RMContainer 和 Application 都做了校验,不会修改维护信息;如果 RMContainer 对象内持有的 contianer 对象为空的话,会抛出 NullPointerException,也不会修改维护信息. 所以无效释放的猜测不合理,此处代码证明重复释放也不合理
[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected synchronized void completedContainer(RMContainer rmContainer,</span><br><span class="line">      ContainerStatus containerStatus, RMContainerEventType event) &#123; </span><br><span class="line">    &#x2F;&#x2F;rmContaienr 空值校验  </span><br><span class="line">    if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">      LOG.info(&quot;Null container completed...&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">    FiCaSchedulerApp application &#x3D;</span><br><span class="line">        getCurrentAttemptForContainer(container.getId());</span><br><span class="line">    ApplicationId appId &#x3D;</span><br><span class="line">    &#x2F;&#x2F;如果 RMContainer 映射的 container 为空,则此处会 NullPointerException</span><br><span class="line">        container.getId().getApplicationAttemptId().getApplicationId();</span><br><span class="line">    &#x2F;&#x2F;application 空值校验</span><br><span class="line">    if (application &#x3D;&#x3D; null) &#123;</span><br><span class="line">      LOG.info(&quot;Container &quot; + container + &quot; of&quot; + &quot; unknown application &quot;</span><br><span class="line">          + appId + &quot; completed with event &quot; + event);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="movetoqueue"><a href="#movetoqueue" class="headerlink" title="movetoqueue"></a>movetoqueue</h3><p>重复释放和无效释放的猜测证否之后,只好再去仔细研究 系统指标异常前的几个运行的任务日志,对 application 的 attempt 和每个 contianer 状态机的状态和 触发事件按照时间线标注出来,对application 发生的所有事件还原出来,发现了其中一个 application 的以下信息  </p>
<blockquote>
<p>1.提交到 root.high 队列后,队列资源不足,在某些节点上为该 applicaiton reserve 资源,其他 application 调度时不会再该节点上分配资源<br>2.application 被从 high 队列移动了 low 队列<br>3.container 被移动队列时,源队列和目标队列的资源有变动,两个队列都会被 re-sort,以便优先在资源利用率最低的 queue 调度,所以有每个 container 的移动有四条日志:queueMoveOut 队列的信息,queueMoveOut 的父队列信息(有几个 parentQueue 就会有几条日志),queuMoveIn 队列信息,queueMoveIn 的父队列信息<br>4.在 move container 前后有一个 container: container_e08_1565789460020_5864_01_000002,在 high队列上分配了资源,被 move 到 low 队列后,containerCompleted 之后,释放资源到了 low 队列<br>5.<b>在 move container 前后有一个 container: container_e08_1565789460020_5864_01_000080,在 high 队列上保留了资源,move 操作没有影响到该 container,但是containerCompleted之后释放资源到了 low 队列</b>. </p>
</blockquote>
<p>日志如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO LeafQueue: assignedContainer application attempt&#x3D;appattempt_1565789460020_5864_000001 container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6:8041, NodeHttpAddress: hadoop6:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: null, ] queue&#x3D;high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:420864, vCores:20&gt;, usedCapacity&#x3D;1.4421053, absoluteUsedCapacity&#x3D;0.86526316, numApps&#x3D;3, numContainers&#x3D;20 clusterResource&#x3D;&lt;memory:486400, vCores:136&gt; type&#x3D;OFF_SWITCH  </span><br><span class="line">INFO RMContainerImpl: container_e08_1565789460020_5864_01_000080 Container Transitioned from NEW to RESERVED</span><br><span class="line">INFO LeafQueue: Reserved container  application&#x3D;application_1565789460020_5864 resource&#x3D;&lt;memory:11264, vCores:1&gt; queue&#x3D;high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:443392, vCores:22&gt;, usedCapacity&#x3D;1.5192982, absoluteUsedCapacity&#x3D;0.91157895, numApps&#x3D;3, numContainers&#x3D;22 usedCapacity&#x3D;1.5192982 absoluteUsedCapacity&#x3D;0.91157895 used&#x3D;&lt;memory:443392, vCores:22&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO ParentQueue: Re-sorting assigned queue: root.high stats: high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:454656, vCores:23&gt;, usedCapacity&#x3D;1.5578947, absoluteUsedCapacity&#x3D;0.93473685, numApps&#x3D;3, numContainers&#x3D;23</span><br><span class="line">....moving</span><br><span class="line">INFO LeafQueue: movedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6:8041, NodeHttpAddress: hadoop6:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: Token &#123; kind: ContainerToken, service:  &#125;, ] resource&#x3D;&lt;memory:11264, vCores:1&gt; queueMoveOut&#x3D;high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:431104, vCores:20&gt;, usedCapacity&#x3D;1.477193, absoluteUsedCapacity&#x3D;0.88631576, numApps&#x3D;3, numContainers&#x3D;20 usedCapacity&#x3D;1.477193 absoluteUsedCapacity&#x3D;0.88631576 used&#x3D;&lt;memory:431104, vCores:20&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO ParentQueue: movedContainer queueMoveOut&#x3D;root usedCapacity&#x3D;0.9768421 absoluteUsedCapacity&#x3D;0.9768421 used&#x3D;&lt;memory:475136, vCores:24&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO LeafQueue: movedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6:8041, NodeHttpAddress: hadoop6:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: Token &#123; kind: ContainerToken, service: &#125;, ] resource&#x3D;&lt;memory:11264, vCores:1&gt; queueMoveIn&#x3D;low: capacity&#x3D;0.1, absoluteCapacity&#x3D;0.1, usedResources&#x3D;&lt;memory:-22528, vCores:-3&gt;, usedCapacity&#x3D;-0.4631579, absoluteUsedCapacity&#x3D;-0.04631579, numApps&#x3D;0, numContainers&#x3D;-3 usedCapacity&#x3D;-0.4631579 absoluteUsedCapacity&#x3D;-0.04631579 used&#x3D;&lt;memory:-22528, vCores:-3&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO ParentQueue: movedContainer queueMoveIn&#x3D;root usedCapacity&#x3D;1.0 absoluteUsedCapacity&#x3D;1.0 used&#x3D;&lt;memory:486400, vCores:25&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">....moved</span><br><span class="line">INFO CapacityScheduler: App: application_1565789460020_5864 successfully moved from high to: low</span><br><span class="line">INFO LeafQueue: completedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000080, NodeId: hadoop5:8041, NodeHttpAddress: hadoop5:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: null, ] queue&#x3D;low: capacity&#x3D;0.1, absoluteCapacity&#x3D;0.1, usedResources&#x3D;&lt;memory:0, vCores:-1&gt;, usedCapacity&#x3D;0.0, absoluteUsedCapacity&#x3D;0.0, numApps&#x3D;1, numContainers&#x3D;-1 cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO LeafQueue: completedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6.:8041, NodeHttpAddress: hadoop6.cn:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: Token &#123; kind: ContainerToken, service: &#125;, ] queue&#x3D;low: capacity&#x3D;0.1, absoluteCapacity&#x3D;0.1, usedResources&#x3D;&lt;memory:-1024, vCores:-2&gt;, usedCapacity&#x3D;-0.021052632, absoluteUsedCapacity&#x3D;-0.002105263, numApps&#x3D;1, numContainers&#x3D;-2 cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>猜测:application 在移动队列后,对 reservedContainer 没有移动或维护信息不同步,导致了源队列的资源泄露给了目标队列,从而目标队列的 UsedCapacity 为负<br>复现方式<br>&ensp;&ensp;&ensp;&ensp;第一步:提交 application 到资源紧张的 Queue<br>&ensp;&ensp;&ensp;&ensp;第二步:待在 RM 的日志中看到”Trying to fulfill reservation for application ${APPLICATION_ID} on node …”和”Trying to schedule on node…, available:…” 表明 CapacityScheduler为该 ApplicationId 保留了资源,跳过在此 nm 上为其他 app 分配 container<br>&ensp;&ensp;&ensp;&ensp;第三步: 使用 yarn application -movetoqueue ${APPLICATION_ID} -queue ${TOQueue}<br>&ensp;&ensp;&ensp;&ensp;第四步: 待在 RM 日志中看到了”App:${APPLICATION_ID} successfully moved ${FROMQUEUE} to ${TOQUEUE}”后,使用 yarn application –kill ${APPLICATION_ID} 或等待 app 结束<br>&ensp;&ensp;&ensp;&ensp;第五步: 在 YarnUI上查看被移动的目标队列${TOQUEUE}的信息  </p>
</blockquote>
<p>注:<br>&ensp;&ensp;&ensp;&ensp;1.一定要在资源紧张的队列上提交 app,以触发调度系统的保留资源.在空闲队列上提交任务复现不了指标异常的问题<br>&ensp;&ensp;&ensp;&ensp;2.最好移动到一个完全空闲的队列上,否则即使复现了资源泄露,也不易看出来  </p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>以下代码出自于 hadoop 2.7.3版本<br>Yarn 是一个资源调度平台,集群内存资源和 cpu 资源被 Yarn 抽象为 Resource{memory,core},客户端对 Yarn 的资源请求和 Yarn 内部的资源调度都是以 Container 为基本单位的<br>当客户端向资源队列 Queue 提交 Application 时, 客户端申请的 AM 以及 AM 申请新的执行角色(e.g. spark 的 executor)都是在Container 中运行,那么对于 Yarn 调度的 Container,资源信息被多维聚合[app状态|container状态|container用途|用户|标签]统计维护:    </p>
<ul>
<li>Queue.包括直接申请的叶子队列及其所有的父队列    <ol>
<li>Queue(AbstractCSQueue)<br>&ensp;&ensp;主要指标是 container 数量;保存着 QueueMetrics 和 ResourceUsage(ByLabel) 的引用<br> a. ParentQueue<br>&ensp;&ensp;主要指标是运行的 application数量;保存着所有资源子队列的集合<br> b. LeafQueue 
&ensp;&ensp; 主要指标是每个用户提交 app 的数量和资源用途用量(ResourceUsageByUser);保存着队列 running 和 pending 的 app[attemp]信息               </li>
<li>QueueMetrics<br>&ensp;&ensp;保留着queue 的指标信息,包括[提交|运行|积压|完成|杀死|失败]app 数量、[分配|待分配|积压]的[container|内存|虚拟核]信息、活跃的[app|user]信息;保存着用户级别的 &lt;username,QueueMetrics&gt;映射  </li>
<li>ResourceUsage<br>&ensp;&ensp;保留着&lt;label,UsageByLabel&gt;信息,分为used、pending、amused、reserved 四类  </li>
</ol>
</li>
<li>Application(SchedulerApplicationAttempt). app 中维护着当前正在运行的 container,及 yarn 为其保留的 container 信息</li>
<li>NodeManager. container 所在的 NM 维护着自身运行的所有 container,并通过 RM 心跳汇报所有 container 状态机状态,触发 RM 对container 状态的更新或释放    </li>
</ul>
<blockquote>
</blockquote>
<p>综上:<br>&ensp;&ensp;&ensp;&ensp;1.指标异常与 container 申请释放有关,所以需要研究 <b>正常申请释放与应用移动队列</b> 对上述维护信息的影响<br>&ensp;&ensp;&ensp;&ensp;2.UI 展示的 numContainers 数据取自 AbstractCSQueue 维护 numContainer 成员变量;usedCapacity,absoluteUsedCapacity,usedResource 均取自AbstractCSQueue$ResourceUsage.used 成员变量.需要关注以上变量在资源申请释放过程中的变化    </p>
<h3 id="正常的资源分配和释放过程"><a href="#正常的资源分配和释放过程" class="headerlink" title="正常的资源分配和释放过程"></a>正常的资源分配和释放过程</h3><p>RM 的资源分配和资源释放都是被动触发,客户端提交 application 到 RMClientService,app 信息暂存在指定资源队列中,待 NM 向 RM 通过心跳汇报自身信息时 RM 将对该 NM 触发调度,在情况允许的情况下(e.g. 目标队列具有该 NM 的 access 权限,NM 剩余资源满足 app 中一个 ResourceRequest 申请的资源),将在该 NM 上划出 ResourceRequest 要求的资源,并同步 Queue/Application/NodeManager 维护的信息;当 container 完成退出之后,NodeManager 注意到 container 状态机变化,并将其信息附带在心跳中汇报给 RM,触发 Queue/Application/NodeManager 状态变化和信息同步<br>以下代码较为关注资源信息的维护同步,对于其他细节不再赘述    </p>
<h3 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h3><p><img src="/img/pictures/negative/yarn_node_update_pic.png" alt=""></p>
<p>NM 通过心跳触发 CapacityScheduler 调度,CS 首先按照 NM 上报的信息同步 RM 的信息,为新启动的 container 触发 LAUNCHED 事件,为结束的 container 触发FINISHED 事件;并试图在该节点上分配资源<br>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void handle(SchedulerEvent event) &#123;</span><br><span class="line">...</span><br><span class="line">case NODE_UPDATE:</span><br><span class="line">    &#123;</span><br><span class="line">      NodeUpdateSchedulerEvent nodeUpdatedEvent &#x3D; (NodeUpdateSchedulerEvent)event;</span><br><span class="line">      RMNode node &#x3D; nodeUpdatedEvent.getRMNode();</span><br><span class="line">      &#x2F;&#x2F;同步 RM 信息</span><br><span class="line">      nodeUpdate(node);</span><br><span class="line">      if (!scheduleAsynchronously) &#123;</span><br><span class="line">      &#x2F;&#x2F;试图在 nm 分配资源</span><br><span class="line">        allocateContainersToNode(getNode(node.getNodeID()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依据汇报心跳的 NodeManager 是否被保留了资源执行相应的逻辑<br>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private synchronized void allocateContainersToNode(FiCaSchedulerNode node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    RMContainer reservedContainer &#x3D; node.getReservedContainer();</span><br><span class="line">    &#x2F;&#x2F;当前 node 被某 applocation 保留了</span><br><span class="line">    if (reservedContainer !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerApp reservedApplication &#x3D;</span><br><span class="line">          getCurrentAttemptForContainer(reservedContainer.getContainerId());</span><br><span class="line">      &#x2F;&#x2F; Try to fulfill the reservation</span><br><span class="line">      LOG.info(&quot;Trying to fulfill reservation for application &quot; + </span><br><span class="line">          reservedApplication.getApplicationId() + &quot; on node: &quot; + </span><br><span class="line">          node.getNodeID());</span><br><span class="line">      LeafQueue queue &#x3D; ((LeafQueue)reservedApplication.getQueue());</span><br><span class="line">      CSAssignment assignment &#x3D;</span><br><span class="line">          queue.assignContainers(</span><br><span class="line">              clusterResource,</span><br><span class="line">              node,</span><br><span class="line">              new ResourceLimits(labelManager.getResourceByLabel(</span><br><span class="line">                  RMNodeLabelsManager.NO_LABEL, clusterResource)));</span><br><span class="line">      ....</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;当前节点未被保留</span><br><span class="line">    if (node.getReservedContainer() &#x3D;&#x3D; null) &#123;</span><br><span class="line">     	...</span><br><span class="line">     	&#x2F;&#x2F;交由 root 队列代理分配.root 是资源队列树形结构的根节点,类型一定ParentQueue</span><br><span class="line">        root.assignContainers(</span><br><span class="line">            clusterResource,</span><br><span class="line">            node,</span><br><span class="line">            new ResourceLimits(labelManager.getResourceByLabel(</span><br><span class="line">                RMNodeLabelsManager.NO_LABEL, clusterResource)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      LOG.info(&quot;Skipping scheduling since node &quot; + node.getNodeID() + </span><br><span class="line">          &quot; is reserved by application &quot; + </span><br><span class="line">          node.getReservedContainer().getContainerId().getApplicationAttemptId()</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ParentQueue 将节点委派给子队列,试图分配资源<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public synchronized CSAssignment assignContainers(Resource clusterResource,</span><br><span class="line">     FiCaSchedulerNode node, ResourceLimits resourceLimits) &#123;</span><br><span class="line">   CSAssignment assignment &#x3D; </span><br><span class="line">       new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);</span><br><span class="line">   Set&lt;String&gt; nodeLabels &#x3D; node.getLabels();</span><br><span class="line">   ...校验 queue 对 node 的 access 权限</span><br><span class="line">   while (canAssign(clusterResource, node)) &#123;</span><br><span class="line">     ...校验 queue 资源是否超限      </span><br><span class="line">     &#x2F;&#x2F; Schedule 递归交由子队列去分配</span><br><span class="line">     CSAssignment assignedToChild &#x3D; </span><br><span class="line">         assignContainersToChildQueues(clusterResource, node, resourceLimits);</span><br><span class="line">     assignment.setType(assignedToChild.getType());</span><br><span class="line">     &#x2F;&#x2F; Done if no child-queue assigned anything</span><br><span class="line">     &#x2F;&#x2F; 如果分配到了资源, assignedToChild 大于 Resource&lt;0,0&gt;</span><br><span class="line">     if (Resources.greaterThan(</span><br><span class="line">             resourceCalculator, clusterResource, </span><br><span class="line">             assignedToChild.getResource(), Resources.none())) &#123;</span><br><span class="line">             &#x2F;&#x2F;同步维护的信息</span><br><span class="line">       super.allocateResource(clusterResource, assignedToChild.getResource(),</span><br><span class="line">           nodeLabels);</span><br><span class="line">       Resources.addTo(assignment.getResource(), assignedToChild.getResource());</span><br><span class="line">       ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;     </span><br><span class="line">   return assignment;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>先看如果分配到资源的话 同步的信息:<br>1.按照 label 去更新 ResourceUsage 中维护的用户使用资源 used(incUsed 方法)<br>2.增加了该队列的 numContainer 数量<br>需要注意的是 <b>无论后续得到的是 allocated container 还是 reserved container,都增加了 numContainer的值,增加了用户 USED 类型的内存和虚拟核数量</b><br>[AbstractCSQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized void allocateResource(Resource clusterResource, </span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    &#x2F;&#x2F; Update usedResources by labels</span><br><span class="line">    if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.incUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.incUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++numContainers;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看对 queueUsage:ResourceUsage 做了什么操作<br>ResourceUsage 中维护了一个Map结构 usages,key 是标签类型,value 是 UsageByLabel;UsageByLabel 中只有一个数组 Resource[],数组中的每个值分别表征着 USED,PENDING,AMUSED,RESERVED 用途的 Resource 数量<br>[ResourceUsage.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &lt;labelName,UsageByLabel&gt;</span><br><span class="line">private Map&lt;String, UsageByLabel&gt; usages;</span><br><span class="line">public void incUsed(String label, Resource res) &#123;</span><br><span class="line">    _inc(label, ResourceType.USED, res);</span><br><span class="line"> &#125;</span><br><span class="line"> private void _inc(String label, ResourceType type, Resource res) &#123;</span><br><span class="line">     ...</span><br><span class="line">     UsageByLabel usage &#x3D; getAndAddIfMissing(label);</span><br><span class="line">     Resources.addTo(usage.resArr[type.idx], res);      </span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>UsageByLabel 使用一个 Resource[]数组来存储资源的用途和用量<br>[UsageByLabel.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class UsageByLabel &#123;</span><br><span class="line">  &#x2F;&#x2F; usage by label, contains all UsageType</span><br><span class="line">  private Resource[] resArr;</span><br><span class="line">  public UsageByLabel(String label) &#123;</span><br><span class="line">    resArr &#x3D; new Resource[ResourceType.values().length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; resArr.length; i++) &#123;</span><br><span class="line">      resArr[i] &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private enum ResourceType &#123;</span><br><span class="line">  USED(0), PENDING(1), AMUSED(2), RESERVED(3);</span><br><span class="line">  private int idx;</span><br><span class="line">  private ResourceType(int value) &#123;</span><br><span class="line">    this.idx &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到资源分配,root 队列深度优先遍历所有子队列,尝试在叶子队列上分配资源<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized CSAssignment assignContainers(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerNode node, ResourceLimits currentResourceLimits) &#123;</span><br><span class="line">	....</span><br><span class="line">    &#x2F;&#x2F; Check for reserved resources</span><br><span class="line">    RMContainer reservedContainer &#x3D; node.getReservedContainer();</span><br><span class="line">    if (reservedContainer !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerApp application &#x3D; </span><br><span class="line">          getApplication(reservedContainer.getApplicationAttemptId());</span><br><span class="line">      synchronized (application) &#123;</span><br><span class="line">        return assignReservedContainer(application, node, reservedContainer,</span><br><span class="line">            clusterResource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对目前活跃的 application,尝试在当前 NM 上分配资源</span><br><span class="line">    for (FiCaSchedulerApp application : activeApplications) &#123;</span><br><span class="line">    	....</span><br><span class="line">      synchronized (application) &#123;</span><br><span class="line">         ....        </span><br><span class="line">          &#x2F;&#x2F; Schedule in priority order</span><br><span class="line">        for (Priority priority : application.getPriorities()) &#123;</span><br><span class="line">          ResourceRequest anyRequest &#x3D;</span><br><span class="line">              application.getResourceRequest(priority, ResourceRequest.ANY);</span><br><span class="line">         if (null &#x3D;&#x3D; anyRequest) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">          ....校验性工作</span><br><span class="line">          &#x2F;&#x2F;校验通过,在此节点上分配资源</span><br><span class="line">          CSAssignment assignment &#x3D;  </span><br><span class="line">            assignContainersOnNode(clusterResource, node, application, priority, </span><br><span class="line">                null, currentResourceLimits);</span><br><span class="line">	.....</span><br><span class="line">          &#x2F;&#x2F; Did we schedule or reserve a container?</span><br><span class="line">          Resource assigned &#x3D; assignment.getResource();</span><br><span class="line">          if (Resources.greaterThan(</span><br><span class="line">              resourceCalculator, clusterResource, assigned, Resources.none())) &#123;</span><br><span class="line">            &#x2F;&#x2F;更新当前[叶子]队列的 numContainer,ResourceUsageByLabel和 ResourceUsageByUser.</span><br><span class="line">            &#x2F;&#x2F;比 ParentQueue.allocateResource 多出了一个用户层面的资源统计</span><br><span class="line">            allocateResource(clusterResource, application, assigned,</span><br><span class="line">                node.getLabels());</span><br><span class="line">            .....            </span><br><span class="line">            return assignment;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL_ASSIGNMENT;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先看LeafQueue#allocateResource 更新信息时更新的指标和内容
LeafQueue 和ParentQueue  一样,使用抽象父类AbstractCSQueue#allocateResource() 更新当前队列的 numContainer 和 标签层面的 ResourceUsage<br>然后使用 LeafQueue 中维护的Map&lt;String,User&gt;成员变量 users来维护用户标签层面的资源信息 
[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized void allocateResource(Resource clusterResource,</span><br><span class="line">      SchedulerApplicationAttempt application, Resource resource,</span><br><span class="line">      Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;使用的是 AbstractCSQueue#allocateResource,和 ParentQueue更新的指标及内容相同:numContainer,ResourceUsageByLabel</span><br><span class="line">    super.allocateResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    &#x2F;&#x2F;更新用户层面的 ResourceUsage</span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.assignContainer(resource, nodeLabels);</span><br><span class="line">    Resources.subtractFrom(application.getHeadroom(), resource); &#x2F;&#x2F; headroom</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>User 类中有一个 ResourceUsage,维护着在用户层面 各标签的资源用途和用量<br>[User.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class User &#123;</span><br><span class="line">    ResourceUsage userResourceUsage &#x3D; new ResourceUsage();</span><br><span class="line">    volatile Resource userResourceLimit &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">    int pendingApplications &#x3D; 0;</span><br><span class="line">    int activeApplications &#x3D; 0;</span><br><span class="line">     public void assignContainer(Resource resource,</span><br><span class="line">        Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">        userResourceUsage.incUsed(resource);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (String label : nodeLabels) &#123;</span><br><span class="line">          userResourceUsage.incUsed(label, resource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上文 LeafQueue#assignContainers方法 遍历每个活跃的 application,尝试在当前 nodemanager 上分配资源,调用 assignContainersOnNode()方法进行下一步的分配逻辑,并增加 app 在本地化层面分配的 container 数量,此指标逻辑不在此讨论<br>按照本地性优先级,优先分配  NODE_LOCAL(本节点)&gt;RACK_LOCAL(本机架)&gt;OFF_SWITCH(跨机架)<br>YARN 的本地性不同于 MR/SPARK 的本地性,YARN的本地性性体现在 Client/AM申请 container 的时候可以指定 container 所在的节点,此处的 NODE_LOCAL、RACK_LOCAL 和 OFF_SWITCH 是相对于申请 container 时指定的节点而言;数据本地化计算其实更多的是靠计算框架配合,按照数据所处的位置优先分配给计算节点(e.g. RDD#getPreferredLocations)<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private CSAssignment assignContainersOnNode(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerNode node, FiCaSchedulerApp application, Priority priority,</span><br><span class="line">      RMContainer reservedContainer, ResourceLimits currentResoureLimits) &#123;</span><br><span class="line">    Resource assigned &#x3D; Resources.none();</span><br><span class="line">    NodeType requestType &#x3D; null;</span><br><span class="line">    MutableObject allocatedContainer &#x3D; new MutableObject();</span><br><span class="line">    &#x2F;&#x2F; Data-local</span><br><span class="line">    ResourceRequest nodeLocalResourceRequest &#x3D;</span><br><span class="line">        application.getResourceRequest(priority, node.getNodeName());</span><br><span class="line">    if (nodeLocalResourceRequest !&#x3D; null) &#123;</span><br><span class="line">      requestType &#x3D; NodeType.NODE_LOCAL;</span><br><span class="line">      assigned &#x3D;</span><br><span class="line">          assignNodeLocalContainers(clusterResource, nodeLocalResourceRequest, </span><br><span class="line">            node, application, priority, reservedContainer,</span><br><span class="line">            allocatedContainer, currentResoureLimits);</span><br><span class="line">      if (Resources.greaterThan(resourceCalculator, clusterResource,</span><br><span class="line">          assigned, Resources.none())) &#123;</span><br><span class="line">        &#x2F;&#x2F;update locality statistics</span><br><span class="line">        if (allocatedContainer.getValue() !&#x3D; null) &#123;</span><br><span class="line">          application.incNumAllocatedContainers(NodeType.NODE_LOCAL,</span><br><span class="line">            requestType);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CSAssignment(assigned, NodeType.NODE_LOCAL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Rack-local</span><br><span class="line">    ResourceRequest rackLocalResourceRequest &#x3D;</span><br><span class="line">        application.getResourceRequest(priority, node.getRackName());</span><br><span class="line">    if (rackLocalResourceRequest !&#x3D; null) &#123;</span><br><span class="line">      if (!rackLocalResourceRequest.getRelaxLocality()) &#123;</span><br><span class="line">        return SKIP_ASSIGNMENT;</span><br><span class="line">      &#125;</span><br><span class="line">      if (requestType !&#x3D; NodeType.NODE_LOCAL) &#123;</span><br><span class="line">        requestType &#x3D; NodeType.RACK_LOCAL;</span><br><span class="line">      &#125;</span><br><span class="line">      assigned &#x3D; </span><br><span class="line">          assignRackLocalContainers(clusterResource, rackLocalResourceRequest, </span><br><span class="line">            node, application, priority, reservedContainer,</span><br><span class="line">            allocatedContainer, currentResoureLimits);</span><br><span class="line">      if (Resources.greaterThan(resourceCalculator, clusterResource,</span><br><span class="line">          assigned, Resources.none())) &#123;</span><br><span class="line">        if (allocatedContainer.getValue() !&#x3D; null) &#123;</span><br><span class="line">          application.incNumAllocatedContainers(NodeType.RACK_LOCAL,</span><br><span class="line">            requestType);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CSAssignment(assigned, NodeType.RACK_LOCAL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Off-switch</span><br><span class="line">    ResourceRequest offSwitchResourceRequest &#x3D;</span><br><span class="line">        application.getResourceRequest(priority, ResourceRequest.ANY);</span><br><span class="line">    if (offSwitchResourceRequest !&#x3D; null) &#123;</span><br><span class="line">      if (!offSwitchResourceRequest.getRelaxLocality()) &#123;</span><br><span class="line">        return SKIP_ASSIGNMENT;</span><br><span class="line">      &#125;</span><br><span class="line">      if (requestType !&#x3D; NodeType.NODE_LOCAL</span><br><span class="line">          &amp;&amp; requestType !&#x3D; NodeType.RACK_LOCAL) &#123;</span><br><span class="line">        requestType &#x3D; NodeType.OFF_SWITCH;</span><br><span class="line">      &#125;</span><br><span class="line">      assigned &#x3D;</span><br><span class="line">          assignOffSwitchContainers(clusterResource, offSwitchResourceRequest,</span><br><span class="line">            node, application, priority, reservedContainer,</span><br><span class="line">            allocatedContainer, currentResoureLimits);</span><br><span class="line">      if (allocatedContainer.getValue() !&#x3D; null) &#123;</span><br><span class="line">        application.incNumAllocatedContainers(NodeType.OFF_SWITCH, requestType);</span><br><span class="line">      &#125;</span><br><span class="line">      return new CSAssignment(assigned, NodeType.OFF_SWITCH);</span><br><span class="line">    &#125;</span><br><span class="line">    return SKIP_ASSIGNMENT;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>LeafQueue#assignNodeLocalContainers,assignRackLocalContainers,assignOffSwitchContainers的核心逻辑被封装为一处,只是本地化类型 NodeType 不同<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Resource assignContainer(Resource clusterResource, FiCaSchedulerNode node, </span><br><span class="line">      FiCaSchedulerApp application, Priority priority, </span><br><span class="line">      ResourceRequest request, NodeType type, RMContainer rmContainer,</span><br><span class="line">      MutableObject createdContainer, ResourceLimits currentResoureLimits) &#123;</span><br><span class="line">    ....    </span><br><span class="line">    Resource capability &#x3D; request.getCapability();</span><br><span class="line">    Resource available &#x3D; node.getAvailableResource();</span><br><span class="line">    Resource totalResource &#x3D; node.getTotalResource();</span><br><span class="line">    if (!Resources.lessThanOrEqual(resourceCalculator, clusterResource,</span><br><span class="line">        capability, totalResource)) &#123;</span><br><span class="line">      LOG.warn(&quot;Node : &quot; + node.getNodeID()</span><br><span class="line">          + &quot; does not have sufficient resource for request : &quot; + request</span><br><span class="line">          + &quot; node total capability : &quot; + node.getTotalResource());</span><br><span class="line">      return Resources.none();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Create the container if necessary</span><br><span class="line">    Container container &#x3D; </span><br><span class="line">        getContainer(rmContainer, application, node, capability, priority);</span><br><span class="line">  	...</span><br><span class="line">      boolean shouldAllocOrReserveNewContainer &#x3D; shouldAllocOrReserveNewContainer(</span><br><span class="line">        application, priority, capability);</span><br><span class="line">    &#x2F;&#x2F;依据 节点可用资源量与申请的资源量 做除法来判断节点剩余资源能否满足需求 </span><br><span class="line">    int availableContainers &#x3D; </span><br><span class="line">        resourceCalculator.computeAvailableContainers(available, capability);</span><br><span class="line">    boolean needToUnreserve &#x3D; Resources.greaterThan(resourceCalculator,clusterResource,</span><br><span class="line">        currentResoureLimits.getAmountNeededUnreserve(), Resources.none());</span><br><span class="line">	</span><br><span class="line">    if (availableContainers &gt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果节点上足够分配一个 container 则分配</span><br><span class="line">      ....</span><br><span class="line">      &#x2F;&#x2F;调用 application 和 nodemanager 的方法,触发这两处的信息同步</span><br><span class="line">      RMContainer allocatedContainer &#x3D; </span><br><span class="line">          application.allocate(type, node, priority, request, container);</span><br><span class="line">          </span><br><span class="line">      node.allocateContainer(allocatedContainer);</span><br><span class="line">      </span><br><span class="line">      createdContainer.setValue(allocatedContainer);</span><br><span class="line">      return container.getResource();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	....</span><br><span class="line">        &#x2F;&#x2F;节点上没有足够的资源满足需求,则为该 application 保留该节点的资源</span><br><span class="line">        reserve(application, priority, node, rmContainer, container);</span><br><span class="line">        return request.getCapability();</span><br><span class="line">      &#125;</span><br><span class="line">      return Resources.none();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上文有三处地方需要同步资源信息:reserve()方法,FiCaSchedulerApp#allocate,FiCaSchedulerNode#allocateContainer<br>先看FiCaSchedulerApp#allocate方法,在 application 层面修改了什么信息<br>[FiCaSchedulerApp.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,</span><br><span class="line">     Priority priority, ResourceRequest request, </span><br><span class="line">     Container container) &#123;</span><br><span class="line">    ....</span><br><span class="line">   &#x2F;&#x2F;将 container 封装成 RMContainer 的形式,记录在 application 的所有 container 集合 newlyAllocatedContainers 和 运行态(相对 reserved)的 container 集合 liveContainers 中  </span><br><span class="line">   RMContainer rmContainer &#x3D; new RMContainerImpl(container, this</span><br><span class="line">       .getApplicationAttemptId(), node.getNodeID(),</span><br><span class="line">       appSchedulingInfo.getUser(), this.rmContext);</span><br><span class="line">   newlyAllocatedContainers.add(rmContainer);</span><br><span class="line">   liveContainers.put(container.getId(), rmContainer);    </span><br><span class="line">   ....</span><br><span class="line">   &#x2F;&#x2F;更新 metrics 信息</span><br><span class="line">   List&lt;ResourceRequest&gt; resourceRequestList &#x3D; appSchedulingInfo.allocate(</span><br><span class="line">       type, node, priority, request, container);</span><br><span class="line">    &#x2F;&#x2F;当前 app 消费的资源量</span><br><span class="line">   Resources.addTo(currentConsumption, container.getResource());</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F;触发 RMContainer 状态机变化,container 可以准备运行时环境,下载依赖等</span><br><span class="line">   rmContainer.handle(</span><br><span class="line">       new RMContainerEvent(container.getId(), RMContainerEventType.START));</span><br><span class="line">   RMAuditLogger.logSuccess(getUser(), </span><br><span class="line">       AuditConstants.ALLOC_CONTAINER, &quot;SchedulerApp&quot;, </span><br><span class="line">       getApplicationId(), container.getId());</span><br><span class="line">   return rmContainer;</span><br></pre></td></tr></table></figure>
<p>AppSchedulingInfo#allocate 更新 QueueMetrics 信息<br>[AppSchedulingInfo.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized public List&lt;ResourceRequest&gt; allocate(NodeType type,</span><br><span class="line">      SchedulerNode node, Priority priority, ResourceRequest request,</span><br><span class="line">      Container container) &#123;</span><br><span class="line">    List&lt;ResourceRequest&gt; resourceRequests &#x3D; new ArrayList&lt;ResourceRequest&gt;();</span><br><span class="line">    &#x2F;&#x2F;本地化层面的统计信息</span><br><span class="line">    if (type &#x3D;&#x3D; NodeType.NODE_LOCAL) &#123;</span><br><span class="line">      allocateNodeLocal(node, priority, request, container, resourceRequests);</span><br><span class="line">    &#125; else if (type &#x3D;&#x3D; NodeType.RACK_LOCAL) &#123;</span><br><span class="line">      allocateRackLocal(node, priority, request, container, resourceRequests);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      allocateOffSwitch(node, priority, request, container, resourceRequests);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueMetrics metrics &#x3D; queue.getMetrics();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;对QueueMetrics 做已经分配的资源的统计</span><br><span class="line">    metrics.allocateResources(user, 1, request.getCapability(), true);</span><br><span class="line">    metrics.incrNodeTypeAggregations(user, type);</span><br><span class="line">    return resourceRequests;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>QueueMetrics#allocateResource 对 userMetrics 做判断;对 parent 也做了判断 如果parent 非空那么会递归更新 parent 的信息,对userMetrics 和 parent 执行的方法都是 QueueMetrics#allocateResources,更新的指标一样:增加 allocate 的 container 数量,内存量,虚拟核数量<br>[QueueMetrics.java] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void allocateResources(String user, int containers, Resource res,</span><br><span class="line">      boolean decrPending) &#123;</span><br><span class="line">    allocatedContainers.incr(containers);</span><br><span class="line">    aggregateContainersAllocated.incr(containers);</span><br><span class="line">    allocatedMB.incr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.incr(res.getVirtualCores() * containers);</span><br><span class="line">    if (decrPending) &#123;</span><br><span class="line">      _decrPendingResources(containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>FiCaSchedulerNode#allocateContainer, NodeManager 同步 allocate 信息 
[FiCaSchedulerNode.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void allocateContainer(RMContainer rmContainer) &#123;</span><br><span class="line">    Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">     &#x2F;&#x2F;减少当前 nm 的可用资源,增加当前 nm 的已分配资源</span><br><span class="line">    deductAvailableResource(container.getResource());</span><br><span class="line">    &#x2F;&#x2F;增加自身维护的 numContainer 数量,不同于 AbstractCSQueue.numContainers,维护Queue维度和 NodeManager 维度的 container 数量</span><br><span class="line">    ++numContainers;</span><br><span class="line">    &#x2F;&#x2F;启动的 container 列表</span><br><span class="line">    launchedContainers.put(container.getId(), rmContainer);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void deductAvailableResource(Resource resource) &#123;</span><br><span class="line">    Resources.subtractFrom(availableResource, resource);</span><br><span class="line">    Resources.addTo(usedResource, resource);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果在节点上 reserve 了资源,同步的信息和 allocate 的方式相似,会更新 QueueMetrics 对 reserved[containr|memory|core]的信息,更新application reservedContainer 及 currentReservationMemroy 信息,更新 NodeManager 当前 reservedContainer 信息<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void reserve(FiCaSchedulerApp application, Priority priority, </span><br><span class="line">      FiCaSchedulerNode node, RMContainer rmContainer, Container container) &#123;</span><br><span class="line">    &#x2F;&#x2F;传入的 rmContainer 为 null</span><br><span class="line">    if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">      getMetrics().reserveResource(</span><br><span class="line">          application.getUser(), container.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Inform the application </span><br><span class="line">    rmContainer &#x3D; application.reserve(node, priority, rmContainer, container);</span><br><span class="line">    &#x2F;&#x2F; Update the node</span><br><span class="line">    node.reserveResource(application, priority, rmContainer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>QueueMetrics#reserveResource在下方有一个对 parent 的判断,递归调用依次更新 ParentQueue 的信息;有一个对 userMetrics 的判断,对 QueueMetrics 中维护的 users:Map[String, QueueMetrics] 同步用户层面的统计信息,执行的方法都是当前方法QueueMetrics#reserveResource(),同步reserved 资源信息:增加 reserved container 数量,内存量,虚拟核数量  </p>
<p>[QueueMetrics.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void reserveResource(String user, Resource res) &#123;</span><br><span class="line">    reservedContainers.incr();</span><br><span class="line">    reservedMB.incr(res.getMemory());</span><br><span class="line">    reservedVCores.incr(res.getVirtualCores());</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>application 同步 reserved container 信息<br>[SchedulerApplicationAttempt.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized RMContainer reserve(SchedulerNode node, Priority priority,</span><br><span class="line">     RMContainer rmContainer, Container container) &#123;</span><br><span class="line">    &#x2F;&#x2F;上游传入的 rmContainer 为 null</span><br><span class="line">   if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">     rmContainer &#x3D; </span><br><span class="line">         new RMContainerImpl(container, getApplicationAttemptId(), </span><br><span class="line">             node.getNodeID(), appSchedulingInfo.getUser(), rmContext);</span><br><span class="line">     &#x2F;&#x2F;增加当前 application 保留的资源信息</span><br><span class="line">     Resources.addTo(currentReservation, container.getResource());</span><br><span class="line">     resetReReservations(priority);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; Note down the re-reservation</span><br><span class="line">     addReReservation(priority);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;在 container 信息中设置了绑定节点的信息....</span><br><span class="line">   rmContainer.handle(new RMContainerReservedEvent(container.getId(), </span><br><span class="line">       container.getResource(), node.getNodeID(), priority));</span><br><span class="line">       &#x2F;&#x2F;加入到维护的 reservedContainer 信息中</span><br><span class="line">   Map&lt;NodeId, RMContainer&gt; reservedContainers &#x3D; </span><br><span class="line">       this.reservedContainers.get(priority);</span><br><span class="line">   if (reservedContainers &#x3D;&#x3D; null) &#123;</span><br><span class="line">     reservedContainers &#x3D; new HashMap&lt;NodeId, RMContainer&gt;();</span><br><span class="line">     this.reservedContainers.put(priority, reservedContainers);</span><br><span class="line">   &#125;</span><br><span class="line">   reservedContainers.put(node.getNodeID(), rmContainer);</span><br><span class="line">   return rmContainer;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>FicaSchedulerNode#reserveResource(),NodeManager 同步 reserved container 信息<br>[FicaSchedulerNode.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void reserveResource(</span><br><span class="line">      SchedulerApplicationAttempt application, Priority priority,</span><br><span class="line">      RMContainer container) &#123;</span><br><span class="line">    &#x2F;&#x2F; Check if it&#39;s already reserved</span><br><span class="line">    RMContainer reservedContainer &#x3D; getReservedContainer();</span><br><span class="line">    ....空值校验性,重复保留校验等操作</span><br><span class="line">    &#x2F;&#x2F;设置当前节点保留的 container 为传入值</span><br><span class="line">    setReservedContainer(container);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>综上:<br>        CS 调度器在 NM 上为 APP 分配 container 时,会同步 [Parent | Leaf] Queue/APP/NM 三个位置维护的信息<br>    1.分配时,无论从叶子队列得到 allocated 或 reserved 类型的 container, 其 <b>ParentQueue</b>都会维护:<br>&ensp;&ensp;&ensp;&ensp;ParentQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp;ParentQueue <b>标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>    2.分配时,无论从叶子队列得到 allocated 或 reserved 类型的 container, <b>LeafQueue</b> 本身都会维护:<br>&ensp;&ensp;&ensp;&ensp; LeafQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp; LeafQueue 维护的<b>标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>&ensp;&ensp;&ensp;&ensp; LeafQueue 维护的<b>用户标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>    3.在节点上申请资源时,按照节点剩余可用资源和资源需求量做除法,若满足需求则分配为 allocatedContainer,不满足则分配 reservedContainer<br>    4.若在节点上分配 allocatedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp; Application 方面:newlyAllocatedContainers和 livingContainers 列表,app 已占用资源量<br>&ensp;&ensp;&ensp;&ensp; NodeManager 方面:numContainer 数量,NM 可用资源量,NM 已用资源量,NM 启动的 container 列表<br>&ensp;&ensp;&ensp;&ensp; QueueMetrics 方面:LeafQueue 及所有 ParentQueue<b>自身QueueMetrics</b>的allocated [containerNum | MB | core]信息;LeafQueue 及其所有 ParentQueue 在<b>用户维度 QueueMetrics</b> 的 allocated [containerNum | MB | cores]信息<br>    5.若在节点上分配 reservedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp;Application 方面:reservedContainers 列表,app 已保留资源量<br>&ensp;&ensp;&ensp;&ensp;NodeManager 方面:设置 NM 保留的 container 为本次的 reservedContainer<br>&ensp;&ensp;&ensp;&ensp;QueueMetrics 方面:LeafQueue 及所有 ParentQueue<b>自身 QueueMetrics</b>的 reserved [containerNum | MB | core]信息;LeafQueue 及其所有 ParentQueue 在<b>用户维度QueueMetrics</b> 的 reserved [containerNum | MB | core ]信息  </p>
</blockquote>
<h3 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h3><p>以客户端在命令行执行 “yarn application –kill ${APPLICATION_ID}”为例<br>RM 中响应请求 方法调用栈为:<br>-&gt;ClientRMService#forceKillApplication<br>&ensp;&ensp;-&gt;RMAppImpl$KillAttemptTransition#transition<br>&ensp;&ensp;&ensp;&ensp;-&gt;RMAppAttemptImpl$BaseFinalTransition#transition<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-&gt;CapacityScheduler#handle()   </p>
<p>application 结束时,主要做了三件事情,  </p>
<ol>
<li>Container: 释放 APP 持有的<b> living,reserved </b> container  </li>
<li>Application(QueueMetrcis): 清理 LeafQueue 及其 ParentQueue 在 <b>APP</b> 层面的统计(e.g. appRunnings);清理 LeafQueue 在<b>用户APP</b> 层面的统计  </li>
<li>AM(ResourceUsage): 释放 LeafQueue 及其 ParentQueue 在 <b>AM</b> 层面的资源用量;  释放 LeafQueue 在<b>用户AM</b> 层面的统计(AMUSED)  </li>
</ol>
<p>由于复现指标异常成功后,发现移动到目标队列后,目标队列增加的资源总量是 spark.executor.memory 的整数倍(executor-mem 11G,driver-memory 2G),所以对上述的第二点和第三点不多分析,主要关注 <b>非 AM 的container</b> 的释放,livingContainers 和 reservedContainer 的释放代码是同一个,仅仅是释放 container 的文字性说明(原文: diagnostics 意为诊断)不同<br>[CapactiyScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void handle(SchedulerEvent event) &#123;</span><br><span class="line">....</span><br><span class="line"> case APP_ATTEMPT_REMOVED:</span><br><span class="line">    &#123;</span><br><span class="line">      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent &#x3D;</span><br><span class="line">          (AppAttemptRemovedSchedulerEvent) event;</span><br><span class="line">      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),</span><br><span class="line">        appAttemptRemovedEvent.getFinalAttemptState(),</span><br><span class="line">        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">    ....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private synchronized void doneApplicationAttempt(</span><br><span class="line">      ApplicationAttemptId applicationAttemptId,</span><br><span class="line">      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) &#123;</span><br><span class="line">    </span><br><span class="line">    FiCaSchedulerApp attempt &#x3D; getApplicationAttempt(applicationAttemptId);</span><br><span class="line">    SchedulerApplication&lt;FiCaSchedulerApp&gt; application &#x3D;</span><br><span class="line">        applications.get(applicationAttemptId.getApplicationId());</span><br><span class="line">        ....</span><br><span class="line">    &#x2F;&#x2F;从 app 维护的 livingContainer 列表中,释放掉 allocated acquired running 状态的 container</span><br><span class="line">    for (RMContainer rmContainer : attempt.getLiveContainers()) &#123;</span><br><span class="line">    &#x2F;&#x2F;在 kill 时keepContainer 为 false;在 failed 时,keepContainer 按场景可为 true</span><br><span class="line">      if (keepContainers</span><br><span class="line">          &amp;&amp; rmContainer.getState().equals(RMContainerState.RUNNING)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;1.释放 container</span><br><span class="line">      completedContainer(</span><br><span class="line">        rmContainer,</span><br><span class="line">        SchedulerUtils.createAbnormalContainerStatus(</span><br><span class="line">        &#x2F;&#x2F;COMPLETED_APPLICATION:Container of a completed application</span><br><span class="line">          rmContainer.getContainerId(), SchedulerUtils.COMPLETED_APPLICATION),</span><br><span class="line">        RMContainerEventType.KILL);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;从 app 维护的 reservedContainer 列表中,释放掉 reserved 状态的 container</span><br><span class="line">    for (RMContainer rmContainer : attempt.getReservedContainers()) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.释放 container</span><br><span class="line">      completedContainer(</span><br><span class="line">        rmContainer,</span><br><span class="line">        SchedulerUtils.createAbnormalContainerStatus(</span><br><span class="line">          rmContainer.getContainerId(), &quot;Application Complete&quot;),</span><br><span class="line">        RMContainerEventType.KILL);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2. 清理 pending 的 resourceRequest,并同步 [LeafQueue | ParentQueue] [本身 | 用户]维度的 QueueMetrics appRunnings | appPendings </span><br><span class="line">    attempt.stop(rmAppAttemptFinalState);</span><br><span class="line">    String queueName &#x3D; attempt.getQueue().getQueueName();</span><br><span class="line">    CSQueue queue &#x3D; queues.get(queueName);</span><br><span class="line">    if (!(queue instanceof LeafQueue)) &#123;</span><br><span class="line">      LOG.error(&quot;Cannot finish application &quot; + &quot;from non-leaf queue: &quot;</span><br><span class="line">          + queueName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;3. 同步 [LeafQueue | ParentQueue] [本身 | 用户]维度 QueueUsage 的 AMUSED 指标</span><br><span class="line">      queue.finishApplicationAttempt(attempt, queue.getQueueName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>CapacityScheduler#completedContainer主要做了一些校验,避免无效释放<br>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> protected synchronized void completedContainer(RMContainer rmContainer,</span><br><span class="line">    ContainerStatus containerStatus, RMContainerEventType event) &#123;</span><br><span class="line">  if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">    LOG.info(&quot;Null container completed...&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">  FiCaSchedulerApp application &#x3D;</span><br><span class="line">      getCurrentAttemptForContainer(container.getId());</span><br><span class="line">  ApplicationId appId &#x3D;</span><br><span class="line">      container.getId().getApplicationAttemptId().getApplicationId();</span><br><span class="line">  if (application &#x3D;&#x3D; null) &#123;</span><br><span class="line">    LOG.info(&quot;Container &quot; + container + &quot; of&quot; + &quot; unknown application &quot;</span><br><span class="line">        + appId + &quot; completed with event &quot; + event);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;container 所在的 NM视图</span><br><span class="line">  FiCaSchedulerNode node &#x3D; getNode(container.getNodeId());</span><br><span class="line">   &#x2F;&#x2F;代理 container 的 LeafQueue</span><br><span class="line">  LeafQueue queue &#x3D; (LeafQueue)application.getQueue();</span><br><span class="line">  queue.completedContainer(clusterResource, application, node, </span><br><span class="line">      rmContainer, containerStatus, event, null, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先按照 RMContainer 状态机状态判断后续将当前 container 按照 reservedContainer处理或者 allocatedContainer 处理<br>然后若释放 container 成功,则同步 用户和标签维度 QueueUsage的 USED 指标,减少 Queue 运行的 container 数量<br>最后若当前 Queue 非 rootQueue,则递归同步当前 Queue 的所有 ParentQueue做上述处理<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void completedContainer(Resource clusterResource, </span><br><span class="line">      FiCaSchedulerApp application, FiCaSchedulerNode node, RMContainer rmContainer, </span><br><span class="line">      ContainerStatus containerStatus, RMContainerEventType event, CSQueue childQueue,</span><br><span class="line">      boolean sortQueues) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      boolean removed &#x3D; false;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">	&#x2F;&#x2F; 1. 若 contaienr 状态机为 reserved 状态,在节点上解除 reserve</span><br><span class="line">        if (rmContainer.getState() &#x3D;&#x3D; RMContainerState.RESERVED) &#123;</span><br><span class="line">          removed &#x3D; unreserve(application, rmContainer.getReservedPriority(),</span><br><span class="line">              node, rmContainer);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 2.若 container 状态机不为 reserved 状态,在节点上解除 allocate,并使 NM 释放 container</span><br><span class="line">          removed &#x3D;</span><br><span class="line">            application.containerCompleted(rmContainer, containerStatus, event);</span><br><span class="line">          node.releaseContainer(container);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;3.释放 同步 QueueUsage</span><br><span class="line">        if (removed) &#123;</span><br><span class="line">          releaseResource(clusterResource, application,</span><br><span class="line">              container.getResource(), node.getLabels());</span><br><span class="line">          LOG.info(&quot;completedContainer&quot; +</span><br><span class="line">              &quot; container&#x3D;&quot; + container +</span><br><span class="line">              &quot; queue&#x3D;&quot; + this +</span><br><span class="line">              &quot; cluster&#x3D;&quot; + clusterResource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;4.递归执行 Parent的释放逻辑</span><br><span class="line">      if (removed) &#123;</span><br><span class="line">        getParent().completedContainer(clusterResource, application, node,</span><br><span class="line">          rmContainer, null, event, this, sortQueues);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先看第 4 处对 ParentQueue 的处理<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void completedContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, FiCaSchedulerNode node, </span><br><span class="line">      RMContainer rmContainer, ContainerStatus containerStatus, </span><br><span class="line">      RMContainerEventType event, CSQueue completedChildQueue,</span><br><span class="line">      boolean sortQueues) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">      &#x2F;&#x2F;使用 AbstractCSQueue 中releaseResource方法</span><br><span class="line">        super.releaseResource(clusterResource, rmContainer.getContainer()</span><br><span class="line">            .getResource(), node.getLabels());</span><br><span class="line">	...</span><br><span class="line">        &#x2F;&#x2F;resort sub-queue</span><br><span class="line">     	....</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Inform the parent</span><br><span class="line">      if (parent !&#x3D; null) &#123;</span><br><span class="line"> 	&#x2F;&#x2F;递归 ParentQueue#completedContainer 方法</span><br><span class="line">        parent.completedContainer(clusterResource, application, </span><br><span class="line">            node, rmContainer, null, event, this, sortQueues);</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ParentQueue 在 container 释放时,无论是 allocatedContainer 还是 reservedContainer,都更新: 
1.按标签更新 QueueUsage 中 USED 用途的资源量<br>2.ParentQueue 中运行 container 的数量 
[AbstractCSQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;1.QueueUsageByLabel</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">        &#x2F;&#x2F;2.减少当前 Queue 的 container 的数量</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看第 3 处对 LeafQueue 的处理, 需要注意的是:无论 container 是 allocatedContainer 还是 reversedContainer 在此处都是作为ResourceUsage中 <b>USED</b> 类型的资源来减少的(虽然 ResourceType 枚举中有 RESERVED 类型),且 numContainer 都减少了 1个单位<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized void releaseResource(Resource clusterResource, </span><br><span class="line">      FiCaSchedulerApp application, Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.同步当前队列在 标签维度 ResourceUsage 中 USED 类型的资源,并减少 Queue 中 numContainer</span><br><span class="line">    super.releaseResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    &#x2F;&#x2F;2.同步 app 所属用户在标签维度上的度量信息  </span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.releaseContainer(resource, nodeLabels);</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>[AbstractCSQueue.java]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">     &#x2F;&#x2F;1.同步 label 层面的 QueueUsage 的资源量;无论 reservedContainer 还是 allocatedContainer 都是使用 #decUsed(resource)</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">      &#x2F;&#x2F;2.减少当前队列启动的 container 数量.无论 reservedContainer 还是 allocatedContainer  </span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>LeafQueue 中维护了一个 users:Map[String,User]以保存当前各 user 在 USED,PENDING,AMUSED,RESERVED 用途使用资源的度量<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void releaseContainer(Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      &#x2F;&#x2F;还是 decUsed(resource),无论 reservedContainer 还是 allocatedContainer</span><br><span class="line">        userResourceUsage.decUsed(resource);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (String label : nodeLabels) &#123;</span><br><span class="line">          userResourceUsage.decUsed(label, resource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在回到LeafQueue#completedContainer方法,按照 RMContainer状态机状态来区分 reservedContainer 还是 allocatedContainer 做处理<br>先看对 allocated 的处理逻辑<br>[FicaSchedulerApp.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized public boolean containerCompleted(RMContainer rmContainer,</span><br><span class="line">      ContainerStatus containerStatus, RMContainerEventType event) &#123;</span><br><span class="line">    &#x2F;&#x2F;维护相应的引用列表</span><br><span class="line">    if (null &#x3D;&#x3D; liveContainers.remove(rmContainer.getContainerId())) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    newlyAllocatedContainers.remove(rmContainer);</span><br><span class="line">    Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">    ContainerId containerId &#x3D; container.getId();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.RM 端准备 container 的 结束和清理等任务,待 NM 心跳通过 NodeHeartbeatResponse 交于 NM 做清理</span><br><span class="line">    rmContainer.handle(</span><br><span class="line">        new RMContainerFinishedEvent(</span><br><span class="line">            containerId,</span><br><span class="line">            containerStatus, </span><br><span class="line">            event)</span><br><span class="line">        );</span><br><span class="line">    ... </span><br><span class="line">    &#x2F;&#x2F;2.同步 QueueMetrics</span><br><span class="line">    Resource containerResource &#x3D; rmContainer.getContainer().getResource();</span><br><span class="line">    queue.getMetrics().releaseResources(getUser(), 1, containerResource);</span><br><span class="line">    &#x2F;&#x2F;3.减少当前 app 消费的资源</span><br><span class="line">    Resources.subtractFrom(currentConsumption, containerResource);</span><br><span class="line">    ....</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>主要看第2步 释放 contaienr 同步 QueueMetrics 的指标和内容,<br>1.同步 QueueMetrics 及其 ParentQueue QueueMetrics 的指标: allocate [containerNum | MB | core]<br>2.同步 QueueMetrics 及其 ParentQueue QueueMetrics 用户维度的 QueueMetrics 指标: allocate [containerNum | MB | core]<br>[QueueMetrics.java] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void releaseResources(String user, int containers, Resource res) &#123;</span><br><span class="line">    &#x2F;&#x2F;当前资源队列指标</span><br><span class="line">    allocatedContainers.decr(containers);</span><br><span class="line">    aggregateContainersReleased.incr(containers);</span><br><span class="line">    allocatedMB.decr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.decr(res.getVirtualCores() * containers);</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    &#x2F;&#x2F;资源队列中用户指标</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;递归 父资源队列</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看释放allocatedContainer 过程中,NM 对该 container 的处理<br>1.删掉 launchedContainer 对该 container 的引用<br>2.增加该节点的可用资源,减少已经资源,减少启动的 numContainer 指标<br>[SchedulerNode.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void releaseContainer(Container container) &#123;</span><br><span class="line">    ..</span><br><span class="line">    &#x2F;&#x2F;1.删除引用</span><br><span class="line">    if (null !&#x3D; launchedContainers.remove(container.getId())) &#123;</span><br><span class="line">     &#x2F;&#x2F;2.指标维护</span><br><span class="line">      updateResource(container);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;Released container &quot; + container.getId() + &quot; of capacity &quot;</span><br><span class="line">        + container.getResource() + &quot; on host &quot; + rmNode.getNodeAddress()</span><br><span class="line">        + &quot;, which currently has &quot; + numContainers + &quot; containers, &quot;</span><br><span class="line">        + getUsedResource() + &quot; used and &quot; + getAvailableResource()</span><br><span class="line">        + &quot; available&quot; + &quot;, release resources&#x3D;&quot; + true);</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void updateResource(Container container) &#123;</span><br><span class="line">    addAvailableResource(container.getResource());</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void addAvailableResource(Resource resource) &#123;</span><br><span class="line">     ...</span><br><span class="line">    Resources.addTo(availableResource, resource);</span><br><span class="line">    Resources.subtractFrom(usedResource, resource);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>释放 reservedContainer,对 reversedContainer 的处理<br>1.application 方面:删除对 reservedContainer 的引用,减少 currentReservation 资源数<br>2.nodemanager方面: 设置当前 nm 的reservedContainer 为 null
3.QueueMetrics 方面: 同步[ParentQueue | LeafQueue] [本身 | 用户]维度的指标 reserved [containerNum | MB | core]<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean unreserve(FiCaSchedulerApp application, Priority priority,</span><br><span class="line">      FiCaSchedulerNode node, RMContainer rmContainer) &#123;</span><br><span class="line">      &#x2F;&#x2F;1.application: unreserve</span><br><span class="line">    if (application.unreserve(node, priority)) &#123;</span><br><span class="line">     &#x2F;&#x2F;2. nodemanager: unreserveResource</span><br><span class="line">      node.unreserveResource(application);</span><br><span class="line">     &#x2F;&#x2F;3.QueueMetrics</span><br><span class="line">      getMetrics().unreserveResource(application.getUser(),</span><br><span class="line">          rmContainer.getContainer().getResource());</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>application 和 nodemanager 层面的逻辑比较简单,且看 QueueMetrics 方面的同步<br>[QueueMetrics.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void unreserveResource(String user, Resource res) &#123;</span><br><span class="line">  &#x2F;&#x2F;当前资源队列 QueueMetrics的 reserved [container | MB | core] 指标</span><br><span class="line">    reservedContainers.decr();</span><br><span class="line">    reservedMB.decr(res.getMemory());</span><br><span class="line">    reservedVCores.decr(res.getVirtualCores());</span><br><span class="line">    &#x2F;&#x2F;当前资源队列 在用户维度的 reserved [container | MB | core] 指标</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;父资源队列在 其本身和用户维度的 reserved [container | MB | core] 指标</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>综上:<br>CS 调度器在为 APP 释放container 时,会同步 [Parent | Leaf]Queue/APP/NM 三个位置维护的信息  </p>
<ol>
<li>释放时,无论是释放 allocated 或 reserved 类型的 container,其 <b>ParentQueue</b> 都会维护:
&ensp;&ensp;&ensp;&ensp;ParentQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp;ParentQueue 维护的<b>标签维度</b>的QueueUsage 中 USED 用途的资源量  </li>
<li>释放时,无论是释放 allocated 或 reserved 类型的 container,其 <b>LeafQueue</b> 都会维护:<br>&ensp;&ensp;&ensp;&ensp;LeafQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp;LeafQueue 维护的<b>标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>&ensp;&ensp;&ensp;&ensp;LeafQueue 维护的<b>用户标签维度</b>的 QueueUsage 中 USED 用途的资源量  </li>
<li>释放 container 时,按照该 container 的状态机状态做细分,分为 reservedContainer 和 allocatedContainer 两类做处理  </li>
<li>若在节点上释放 allocatedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp;Application 方面:newlyAllocatedContainers 和 reservedContainers 列表,app已占用资源量<br>&ensp;&ensp;&ensp;&ensp;NodeManager方面:numContainer数量,NM 可用资源量,NM 已用资源量,NM 启动的 container 列表<br>&ensp;&ensp;&ensp;&ensp;QueueMetrics 方面:LeafQueue 和所有 ParentQueue <b>自身 QueueMetrics</b> 的 reserved [containerNum | MB | core]信息;LeafQueue 和所有 ParentQueue 在<b>用户维度 QueueMetrics </b> 的  reserved [containerNum | MB | core]信息  </li>
<li>若在节点上释放 reservedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp;Application 方面:reservedContainers 列表,app 已保留资源量<br>&ensp;&ensp;&ensp;&ensp; NodeManager 方面:设置 NM 保留的 container 为 null<br>&ensp;&ensp;&ensp;&ensp; QueueMetrics 方面:LeafQueue 及所有 ParentQueue<b>自身 QueueMetrics</b>的 reserved [containerNum | MB | core]信息;LeafQueue 及其所有 ParentQueue 在<b>用户维度QueueMetrics</b> 的 reserved [containerNum | MB | core ]信息  </li>
</ol>
<p>Container 释放过程和申请过程 对于 Queue/Application/NM三个位置维护的 Queue/QueueUsageByLabel/QueueUsageByUser/QueueMetrics信息,恰好是一一对应的  </p>
<p>对于 YarnUI 指标异常问题,比较关注的 Queue.numContainer 和 QueueUsageByLabel.resArr[ResourceType.USED]两个指标,一次 allocated/reversed/Container 的申请对应着 numContainer++和 ResourceUsage.incUsed;一次 container 的释放对应着 numContainer–和 ResourceUsage.decUsed   </p>
<h3 id="movetoqueue-时资源转移过程"><a href="#movetoqueue-时资源转移过程" class="headerlink" title="movetoqueue 时资源转移过程"></a>movetoqueue 时资源转移过程</h3><p>使用命令 “yarn application -movetoqueue ${APPID} -queue ${TO}”
可以将 ${APPID}的 APP 移动到目标资源队列 ${TO}<br>ClientRMService 相应请求的调用栈是:<br>-&gt;ClientRMService#moveApplicationAcrossQueues<br>&ensp;&ensp;-&gt;RMAppImpl$RMAppMoveTransition#transition<br>&ensp;&ensp;&ensp;&ensp;-&gt;CapacityScheduler#moveApplication  </p>
<p>application 从源资源队列移动到目标资源队列分为几步:  </p>
<ol>
<li>向目标队列提交application 并做校验,包括 access 权限、目标队列的 app 数量超限、目标队列中用户提交 app 数量超限,若提交成功则增加所有 ParentQueue 的 numApplication 数量(但是没有增加自身的 numApplication 数量)    </li>
<li>转移源队列中所有非 reserved 的 container 到目标队列,源队列(LeafQueue)释放 container,减少<b>标签维度和用户维度</b>的 ResourceUsage USED 类型资源量,并减少源队列的所有父队列(ParentQueue) <b>标签维度</b>的 ResourceUsage USED 类型资源量;增加目标队列(LeafQueue) <b>标签维度和用户维度</b>的 ResourceUsage USED 类型资源量,并增加目标队列的所有父队列(ParentQueue) <b>标签维度</b>的 ResourceUsage USED 类型资源量.指标数量维护在Queue/ResourceUsage/QueueMetrics 中,此处没有处理 livingContainers 的 QueueMetrics ,在第 5 步中统一处理 QueueMetrics    </li>
<li>源队列中移除 appAttemptd,并同步 QueueUsageByUser 和 QueueUsageByLabel 中 AMUSED类型的资源量  </li>
<li>在源队列的所有 ParentQueue 中移除此 Application    </li>
<li>同步源队列和目标队列中所有非 AM container 移动导致的 QueueMetrics 变化  </li>
<li>同步用户维度的 appAttempt 统计信息<br>[CapacityScheduler.java]  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized String moveApplication(ApplicationId appId,</span><br><span class="line">     String targetQueueName) throws YarnException &#123;</span><br><span class="line">   FiCaSchedulerApp app &#x3D;</span><br><span class="line">       getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));</span><br><span class="line">   String sourceQueueName &#x3D; app.getQueue().getQueueName();</span><br><span class="line">   LeafQueue source &#x3D; getAndCheckLeafQueue(sourceQueueName);</span><br><span class="line">   String destQueueName &#x3D; handleMoveToPlanQueue(targetQueueName);</span><br><span class="line">   LeafQueue dest &#x3D; getAndCheckLeafQueue(destQueueName);</span><br><span class="line">   String user &#x3D; app.getUser();</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F;1. 转移 Application</span><br><span class="line">     dest.submitApplication(appId, user, destQueueName);</span><br><span class="line">   &#125; catch (AccessControlException e) &#123;</span><br><span class="line">     throw new YarnException(e);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;2.转移 livingContainer</span><br><span class="line">   for (RMContainer rmContainer : app.getLiveContainers()) &#123;</span><br><span class="line">     source.detachContainer(clusterResource, app, rmContainer);</span><br><span class="line">     &#x2F;&#x2F; attach the Container to another queue</span><br><span class="line">     dest.attachContainer(clusterResource, app, rmContainer);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;3.源资源队列移除attempt,并同步QueueUsage</span><br><span class="line">   source.finishApplicationAttempt(app, sourceQueueName);</span><br><span class="line">   &#x2F;&#x2F;4.源队列的父队列移除 application</span><br><span class="line">   source.getParent().finishApplication(appId, app.getUser());</span><br><span class="line">  &#x2F;&#x2F;5.同步源队列和目标队列的 QueueMetrics</span><br><span class="line">   app.move(dest);</span><br><span class="line">   &#x2F;&#x2F;6.提交attemp</span><br><span class="line">   dest.submitApplicationAttempt(app, user);</span><br><span class="line">   applications.get(appId).setQueue(dest);</span><br><span class="line">   LOG.info(&quot;App: &quot; + app.getApplicationId() + &quot; successfully moved from &quot;</span><br><span class="line">       + sourceQueueName + &quot; to: &quot; + destQueueName);</span><br><span class="line">   return targetQueueName;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>第 2 步中,遍历 app 的 livingContainer,把每个 container 从源队列及父队列释放,减少源队列及父队列的指标<br>先看源队列 LeafQueue 的释放逻辑<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void detachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">      releaseResource(clusterResource, application, rmContainer.getContainer()</span><br><span class="line">          .getResource(), node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; container&#x3D;&quot; + rmContainer.getContainer()</span><br><span class="line">          + &quot; resource&#x3D;&quot; + rmContainer.getContainer().getResource()</span><br><span class="line">          + &quot; queueMoveOut&#x3D;&quot; + this + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity()</span><br><span class="line">          + &quot; absoluteUsedCapacity&#x3D;&quot; + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot;</span><br><span class="line">          + queueUsage.getUsed() + &quot; cluster&#x3D;&quot; + clusterResource);</span><br><span class="line">      &#x2F;&#x2F;ParentQueue#detachContainer</span><br><span class="line">      getParent().detachContainer(clusterResource, application, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  synchronized void releaseResource(Resource clusterResource, </span><br><span class="line">      FiCaSchedulerApp application, Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">     &#x2F;&#x2F;1.减少 标签维度的 ResourceUsage USED 用途的资源;并减少当前 Queue 的 numContainer 数量</span><br><span class="line">    super.releaseResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    &#x2F;&#x2F;2.减少 提交用户在 标签维度的 ResourceUsage USED 用途的资源</span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.releaseContainer(resource, nodeLabels);</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">  &#x2F;&#x2F;ResourceUsageByLabel USED 用途的资源量</span><br><span class="line">  protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">        &#x2F;&#x2F;Queue 的运行 container 数量</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;第 2 处,ResourceUsageByUser USED 用途的资源量</span><br><span class="line">public void releaseContainer(Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">        userResourceUsage.decUsed(resource);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (String label : nodeLabels) &#123;</span><br><span class="line">          userResourceUsage.decUsed(label, resource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>ParentQueue 释放 container 时,减少了用户维度的 ResourceUsage 在 USED 用途上资源量<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void detachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">      super.releaseResource(clusterResource,</span><br><span class="line">          rmContainer.getContainer().getResource(),</span><br><span class="line">          node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; queueMoveOut&#x3D;&quot; + getQueueName()</span><br><span class="line">          + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity() + &quot; absoluteUsedCapacity&#x3D;&quot;</span><br><span class="line">          + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot; + queueUsage.getUsed() + &quot; cluster&#x3D;&quot;</span><br><span class="line">          + clusterResource);</span><br><span class="line">      &#x2F;&#x2F; Inform the parent</span><br><span class="line">      if (parent !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;递归父队列</span><br><span class="line">        parent.detachContainer(clusterResource, application, rmContainer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">  protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    &#x2F;&#x2F; Update usedResources by labels</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将 container 从源队列转移到目标队列时,会增加目标队列及其父队列的指标<br>先看目标队列(LeafQueue)增加的指标<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void attachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">          &#x2F;&#x2F;1.增加 LeafQueue 标签维度的 ResourceUsage 和用户维度的 ResourceUsage, USED 类型的资源量;并增加numContainer</span><br><span class="line">      allocateResource(clusterResource, application, rmContainer.getContainer()</span><br><span class="line">          .getResource(), node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; container&#x3D;&quot; + rmContainer.getContainer()</span><br><span class="line">              &#x2F;&#x2F;add by jiulong.zhu@20190903</span><br><span class="line">              +&quot; containerState&#x3D;&quot;+rmContainer.getState()</span><br><span class="line">          + &quot; resource&#x3D;&quot; + rmContainer.getContainer().getResource()</span><br><span class="line">          + &quot; queueMoveIn&#x3D;&quot; + this + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity()</span><br><span class="line">          + &quot; absoluteUsedCapacity&#x3D;&quot; + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot;</span><br><span class="line">          + queueUsage.getUsed() + &quot; cluster&#x3D;&quot; + clusterResource);</span><br><span class="line">      &#x2F;&#x2F;2.增加 ParentQueue 标签维度的 ResourceUsage USED 类型的资源量;并增加 ParentQueue 的 numContainer 数量</span><br><span class="line">      getParent().attachContainer(clusterResource, application, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  synchronized void allocateResource(Resource clusterResource,</span><br><span class="line">      SchedulerApplicationAttempt application, Resource resource,</span><br><span class="line">      Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#allocateResource 增加标签维度的 ResourceUsage USED 用途的用量;增加 Queue 的numContainers  </span><br><span class="line">    super.allocateResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    &#x2F;&#x2F;增加当前用户 标签维度的 ResourceUsage USED 用途的用量  </span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.assignContainer(resource, nodeLabels);</span><br><span class="line">    </span><br><span class="line">    Resources.subtractFrom(application.getHeadroom(), resource);</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">    if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.info(getQueueName() + </span><br><span class="line">          &quot; user&#x3D;&quot; + userName + </span><br><span class="line">          &quot; used&#x3D;&quot; + queueUsage.getUsed() + &quot; numContainers&#x3D;&quot; + numContainers +</span><br><span class="line">          &quot; headroom &#x3D; &quot; + application.getHeadroom() +</span><br><span class="line">          &quot; user-resources&#x3D;&quot; + user.getUsed()</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;AbstractCSQueue#allocateResource</span><br><span class="line">   synchronized void allocateResource(Resource clusterResource, </span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.incUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.incUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++numContainers;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看将 container 移动到目标队列时,目标队列的 ParentQueue 增加的逻辑<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void attachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">          &#x2F;&#x2F;1.增加 ParentQueue 在标签维度的 ResourceUsage USED 用量 </span><br><span class="line">          &#x2F;&#x2F;AbstractCSQueue#allocateResource</span><br><span class="line">      super.allocateResource(clusterResource, rmContainer.getContainer()</span><br><span class="line">          .getResource(), node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; queueMoveIn&#x3D;&quot; + getQueueName()</span><br><span class="line">          + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity() + &quot; absoluteUsedCapacity&#x3D;&quot;</span><br><span class="line">          + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot; + queueUsage.getUsed() + &quot; cluster&#x3D;&quot;</span><br><span class="line">          + clusterResource);</span><br><span class="line">      &#x2F;&#x2F;2.递归增加 ParentQueue 的所有 ParentQueue 的 ResourceUsage USED 用量  </span><br><span class="line">      if (parent !&#x3D; null) &#123;</span><br><span class="line">        parent.attachContainer(clusterResource, application, rmContainer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;AbstractCSQueue#allocateResource</span><br><span class="line">  synchronized void allocateResource(Resource clusterResource, </span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.incUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.incUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++numContainers;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 3 步:删除源队列中该 app 的 currentApplicationAttempt,并同步 LeafQueue 中用户提交的 app 数量变化<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void finishApplicationAttempt(FiCaSchedulerApp application, String queue) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      removeApplicationAttempt(application, getUser(application.getUser()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;空实现</span><br><span class="line">    getParent().finishApplicationAttempt(application, queue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public synchronized void removeApplicationAttempt(</span><br><span class="line">      FiCaSchedulerApp application, User user) &#123;</span><br><span class="line">    boolean wasActive &#x3D; activeApplications.remove(application);</span><br><span class="line">    if (!wasActive) &#123;</span><br><span class="line">      pendingApplications.remove(application);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;正在运行的 app_attempt,则减少 LeafQueue 的 [ResourceUsage | ResourceUsageByUser] 中AMUSED 占用的资源量</span><br><span class="line">      queueUsage.decAMUsed(application.getAMResource());</span><br><span class="line">      user.getResourceUsage().decAMUsed(application.getAMResource());</span><br><span class="line">    &#125;</span><br><span class="line">    applicationAttemptMap.remove(application.getApplicationAttemptId());</span><br><span class="line">     &#x2F;&#x2F; 在 ResourceUsageByUser 同步 numApplication 指标</span><br><span class="line">    user.finishApplication(wasActive);</span><br><span class="line">    if (user.getTotalApplications() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      users.remove(application.getUser());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Check if we can activate more applications</span><br><span class="line">    activateApplications();</span><br><span class="line">    LOG.info(&quot;Application removed -&quot; +</span><br><span class="line">        &quot; appId: &quot; + application.getApplicationId() + </span><br><span class="line">        &quot; user: &quot; + application.getUser() + </span><br><span class="line">        &quot; queue: &quot; + getQueueName() +</span><br><span class="line">        &quot; #user-pending-applications: &quot; + user.getPendingApplications() +</span><br><span class="line">        &quot; #user-active-applications: &quot; + user.getActiveApplications() +</span><br><span class="line">        &quot; #queue-pending-applications: &quot; + getNumPendingApplications() +</span><br><span class="line">        &quot; #queue-active-applications: &quot; + getNumActiveApplications()</span><br><span class="line">        );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 4 步:对于源队列的所有 ParentQueue,移除 app 的 currentApplicationAttempt,并减少资源队列的运行 numApplication 值<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void finishApplication(ApplicationId application, String user) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      removeApplication(application, user);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;递归 父队列</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.finishApplication(application, user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private synchronized void removeApplication(ApplicationId applicationId, </span><br><span class="line">      String user) &#123;</span><br><span class="line">    --numApplications;</span><br><span class="line">    LOG.info(&quot;Application removed -&quot; +</span><br><span class="line">        &quot; appId: &quot; + applicationId + </span><br><span class="line">        &quot; user: &quot; + user + </span><br><span class="line">        &quot; leaf-queue of parent: &quot; + getQueueName() + </span><br><span class="line">        &quot; #applications: &quot; + getNumApplications());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 5 步: 将 app 持有的所有 allocatedContainer(包括 AM container)和 reservedContainer,移动到目标队列,并修改 QueueMetrics<br>[SchedulerApplicationAttempt.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void move(Queue newQueue) &#123;</span><br><span class="line">    QueueMetrics oldMetrics &#x3D; queue.getMetrics();</span><br><span class="line">    QueueMetrics newMetrics &#x3D; newQueue.getMetrics();</span><br><span class="line">    String user &#x3D; getUser();</span><br><span class="line">    &#x2F;&#x2F;修改 livingContainer 的 QueueMetrics</span><br><span class="line">    for (RMContainer liveContainer : liveContainers.values()) &#123;</span><br><span class="line">      Resource resource &#x3D; liveContainer.getContainer().getResource();</span><br><span class="line">      oldMetrics.releaseResources(user, 1, resource);</span><br><span class="line">      newMetrics.allocateResources(user, 1, resource, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;修改 reservedContainer的 QueueMetrics</span><br><span class="line">    for (Map&lt;NodeId, RMContainer&gt; map : reservedContainers.values()) &#123;</span><br><span class="line">      for (RMContainer reservedContainer : map.values()) &#123;</span><br><span class="line">        Resource resource &#x3D; reservedContainer.getReservedResource();</span><br><span class="line">        oldMetrics.unreserveResource(user, resource);</span><br><span class="line">        newMetrics.reserveResource(user, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;移动 pending ResourceRequest,同步信息:QueueMetrics.appsRunning,Queue下的用户列表    </span><br><span class="line">    appSchedulingInfo.move(newQueue);</span><br><span class="line">    this.queue &#x3D; newQueue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>修改 livingContainers 和 reservedContainers 的所有逻辑都在 QueueMetrics中,其中<br>1.releaseResources,释放 livingContainer: [ParentQueue | LeafQueue] [本身 | 用户维度] 的 allocated [Containers | MB | Core]指标<br>2.allocateResource,申请 livingContainer: [ParentQueue | LeafQueue] [本身 | 用户维度] 的 allocated [Containers | MB | Core]指标<br>3.unreserveResource,释放 reservedContainer:[ParentQueue | LeafQueue] [本身 | 用户维度] 的 reserved [Containers| MB | Core]指标<br>4.reserveResource,申请 reservedContainer:[ParentQueue | LeafQueue] [本身 | 用户维度] 的 reserved [Container | MB | Core]指标<br>[QueueMetrics.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void releaseResources(String user, int containers, Resource res) &#123;</span><br><span class="line">    allocatedContainers.decr(containers);</span><br><span class="line">    aggregateContainersReleased.incr(containers);</span><br><span class="line">    allocatedMB.decr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.decr(res.getVirtualCores() * containers);</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> public void allocateResources(String user, int containers, Resource res,</span><br><span class="line">      boolean decrPending) &#123;</span><br><span class="line">    allocatedContainers.incr(containers);</span><br><span class="line">    aggregateContainersAllocated.incr(containers);</span><br><span class="line">    allocatedMB.incr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.incr(res.getVirtualCores() * containers);</span><br><span class="line">    if (decrPending) &#123;</span><br><span class="line">      _decrPendingResources(containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void unreserveResource(String user, Resource res) &#123;</span><br><span class="line">    reservedContainers.decr();</span><br><span class="line">    reservedMB.decr(res.getMemory());</span><br><span class="line">    reservedVCores.decr(res.getVirtualCores());</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void reserveResource(String user, Resource res) &#123;</span><br><span class="line">    reservedContainers.incr();</span><br><span class="line">    reservedMB.incr(res.getMemory());</span><br><span class="line">    reservedVCores.incr(res.getVirtualCores());</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 6 步:同步目标队列 application 和 applicationAttempt信息<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void submitApplicationAttempt(FiCaSchedulerApp application,</span><br><span class="line">      String userName) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      User user &#x3D; getUser(userName);</span><br><span class="line">      &#x2F;&#x2F;增加 Queue 和 User 维度 application &#x2F; applicationAttempt 的值</span><br><span class="line">      addApplicationAttempt(application, user);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; We don&#39;t want to update metrics for move app</span><br><span class="line">    if (application.isPending()) &#123;</span><br><span class="line">     &#x2F;&#x2F;增加 Queue 和 User 维度 QueueMetrics 中 appsPending 的值</span><br><span class="line">      metrics.submitAppAttempt(userName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;空实现</span><br><span class="line">    getParent().submitApplicationAttempt(application, userName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上:<br>把 application 从源资源队列到目标队列的过程中,在 Queue/ResourceUsageByLabel/ResourceUsageByUser/QueueMetrics 中的变动<br>1.对于 livingContainers,<br>&ensp;&ensp;&ensp;&ensp;Queue 方面:减少源队列及其父队列的 numContainer 值;增加目标队列及其父队列的 numContainer<br>&ensp;&ensp;&ensp;&ensp;ResourceUsage 方面:减少源队列及其父队列的 ResourceUsageByLabel USED 类型的资源量,增加目标队列及其父队列的 ResourceUsageByLabel USED 类型的资源量; 减少源队列(LeafQueue)的 ResourceUsageByUser USED 类型的资源量,增加目标队列(LeafQueue) 的 ResourceUsageByUser USED 类型的资源量;<br>&ensp;&ensp;&ensp;&ensp;QueueMetrics 方面:减少源队列及其父队列的 allocated[Container | MB | Core]指标,增加目标队列及其父队列的 allocated [Container | MB | Core]<br>2.对于 reservedContainers,<br>&ensp;&ensp;&ensp;&ensp;ResourceUsage:减少源队列[LeafQueue | ParentQueue] [本身 | 用户维度] 的reserved [Container | MB | Core]指标,增加目标队列[LeafQueue | ParentQueue] [本身 | 用户维度] 的 reserved [Container | MB | Core]指标  </p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>结合 “正常的资源分配和释放过程”和”movetoqueue 过程中的资源转移过程 “,可以还原一个被转移队列的 application 的资源变动过程<br>application 中非 reservedContianer(状态机:allocated,acquired,running) 的资源变动过程如下表  </p>
<table>
<thead>
<tr>
<th align="left">allocatedContainer</th>
<th align="center">分配</th>
<th align="center">movetoqueue</th>
<th align="center">释放</th>
</tr>
</thead>
<tbody><tr>
<td align="left">numContainer</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">ResourceUsageByLabel(USED)</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">QueueMetrics</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
</tbody></table>
<p>application 中 reservedContianer(状态机:reversed) 的资源变动过程如下表   </p>
<table>
<thead>
<tr>
<th align="left">reversedContainer</th>
<th align="center">分配</th>
<th align="center">movetoqueue</th>
<th align="center">释放</th>
</tr>
</thead>
<tbody><tr>
<td align="left">numContainer</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">ResourceUsageByLabel(USED)</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">QueueMetrics</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
</tbody></table>
<blockquote>
</blockquote>
<p>从上述两表中可知:<br>1.在没有 movetoqueue 操作的情况下, 源队列和目标队列一致,无论 allocatedContainer 或 reservedContainer 的分配和释放都是守恒的,一次指标的增加对应着一次指标的减少<br>2.在源队列资源比较充裕,且有 movetoqueue 操作的情况下,application 没有 reservedContainer 的情况下(上述表一),在分配时源队列指标增加,movetoqueue 时,源队列减少指标且目标队列增加指标,在释放时减少目标队列(app 当前归属队列)的指标.指标的增减也是平衡的,这也就是在资源充裕的队列上无法复现该问题的原因<br>3.在源队列资源比较紧张,且有 movetoqueue 操作的情况下,application 有 reservedContainer 和 allocatedContainer(上述表一和表二),对于 allocatedContainer 来说,资源在分配-&gt;movetoque-&gt;释放的过程中是平衡的(表一);但是对于 reversedContainer 来说,在源队列中分配到资源时,增加了源队列的 numContainer 和 ResourceUsageByLabel 中 USED 用途的资源量,movetoqueue 时没有相应的操作,仅仅是修改了 QueueMetrcis 内的指标,在释放时 container 资源被加入到目标队列的指标中(上述表二).<b>源队列分配出去的资源没有回收,目标队列得到了不是自身分配出去的资源</b>.这样导致了即使源队列和目标队列中完全无任务时,源队列的 numContainer 和 ResourceUsageByLabel 值为正值,目标队列的 numContainer 和 ResourceUsage 值为负值,Yarn UI -&gt;scheduler-&gt;queue 内的 Num Containers/Used Capacity/Absolute Used Capacity/Used Resources 正是基于 队列的 numContainer 和 ResourceUsageByLabel(USED) 展示和计算的,也就是指标异常的问题     </p>
<p>指标异常(无任务时 为负)
<img src="/img/pictures/negative/negative_e7a766275896.png" alt=""></p>
<p>指标异常(无任务时 为正)
<img src="/img/pictures/negative/negative_aead-04d8e67b1357.png" alt=""></p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>1.对于源队列来说,类似于资源泄露,自身资源未能回收,释放到了目标队列.这样对于后续提交到源队列的任务来说,不能分配到资源运行(USED 泄露趋于 100%),但实际上源队列没有任务在运行<br>2.对于目标队列来说,多出了一些资源,导致自身一些指标为负,可能会导致一些未知的问题.以下纯属个人猜测: 例如 同步问题,Queue 有很多的剩余资源,但是 NodeManager 上没有 available 资源;指标负值可能对内部的运算产生未预期的问题  </p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>针对 reservedContainer 在 movetoqueue 操作过程中,资源释放申请不守恒的漏洞,如下表  </p>
<table>
<thead>
<tr>
<th align="left">reversedContainer</th>
<th align="center">分配</th>
<th align="center">movetoqueue</th>
<th align="center">释放</th>
</tr>
</thead>
<tbody><tr>
<td align="left">numContainer</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">ResourceUsageByLabel(USED)</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">QueueMetrics</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
</tbody></table>
<blockquote>
</blockquote>
<p>问题:<br>&ensp;&ensp;&ensp;&ensp;YarnUI 中指标 Num Container、Used Capacity、Absolute Used Capacity、Used Resource 异常和 Queue成员变量numContainer及 QueueUsageByLabel 中 USED 用途的资源量有关<br>目标:<br>&ensp;&ensp;&ensp;&ensp;解决 numContainer 和 ResourceUsageByLabel(USED)在 movetoqueue 时,没有”减少源队列的指标”且没有”增加目标队列指标”的问题<br>途径:<br>&ensp;&ensp;&ensp;&ensp;1.需要在 movetoqueue 时,每个 reservedContainer 都应触发 “源队列减少指标”和”目标队列增加指标”的行为 
&ensp;&ensp;&ensp;&ensp;源码中有封装好的代码且上文多次提到,即 LeafQueue#releaseResource方法和 LeafQueue.allocateResource方法,但是其中有额外的 对 headroom 的同步逻辑.一方面,在”正常的分配和释放”过程中,无论申请和分配的 container 是 allocated 或是 reversed 都会执行 LeafQueue#releaseResource 和 LeafQueue.allocateResource 修改 numContainer 和 ResourceUsageByLabel 的同时修改 headroom值;另一方面 move container中对 headroom 增加和减少 同一个Resource 是幂等的.所以 movetoqueue 操作对于每一个 container 的移动都可以选择触发这两个方法来增加对 numContainer 和 ResourceUsageByLabel 的操作.LeafQueue#detachContainer()和 LeafQueueattachContainer()  中有递归本队列及当前队列此逻辑的过程.直接用即可<br>修改方案:<br>&ensp;&ensp;&ensp;&ensp;CapacitySchedule#moveApplication(ApplicationId appId,String targetQueueName) 方法修改如下  </p>
<p>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public synchronized String moveApplication(ApplicationId appId,</span><br><span class="line">      String targetQueueName) throws YarnException &#123;</span><br><span class="line">    FiCaSchedulerApp app &#x3D;</span><br><span class="line">        getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));</span><br><span class="line">    String sourceQueueName &#x3D; app.getQueue().getQueueName();</span><br><span class="line">    LeafQueue source &#x3D; getAndCheckLeafQueue(sourceQueueName);</span><br><span class="line">    String destQueueName &#x3D; handleMoveToPlanQueue(targetQueueName);</span><br><span class="line">    LeafQueue dest &#x3D; getAndCheckLeafQueue(destQueueName);</span><br><span class="line">    &#x2F;&#x2F; Validation check - ACLs, submission limits for user &amp; queue</span><br><span class="line">    String user &#x3D; app.getUser();</span><br><span class="line">    try &#123;</span><br><span class="line">      dest.submitApplication(appId, user, destQueueName);</span><br><span class="line">    &#125; catch (AccessControlException e) &#123;</span><br><span class="line">      throw new YarnException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Move all live containers</span><br><span class="line">    for (RMContainer rmContainer : app.getLiveContainers()) &#123;</span><br><span class="line">      source.detachContainer(clusterResource, app, rmContainer);</span><br><span class="line">      &#x2F;&#x2F; attach the Container to another queue</span><br><span class="line">      dest.attachContainer(clusterResource, app, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;description:解决 reservedContainer 在 movetoqueue 操作过程中,Queue.numContainer 指标和 ResourceUsageByLabel.USED 资源量</span><br><span class="line">    &#x2F;&#x2F;释放申请不守恒,导致 Yarn UI &quot;Num Container&quot;,&quot;Used Capacity&quot;,&quot;Absolute Used Capacity&quot;,&quot;Used Resource&quot;</span><br><span class="line">    &#x2F;&#x2F;指标在队列无任务运行时不为 0 的问题</span><br><span class="line">    &#x2F;&#x2F;modify by jiulong.zhu@20190903</span><br><span class="line">    &#x2F;&#x2F;++add start</span><br><span class="line">    for (RMContainer rmContainer : app.getReservedContainers()) &#123;</span><br><span class="line">      source.detachContainer(clusterResource, app, rmContainer);</span><br><span class="line">      dest.attachContainer(clusterResource, app, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;++add end</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Detach the application..</span><br><span class="line">    source.finishApplicationAttempt(app, sourceQueueName);</span><br><span class="line">    source.getParent().finishApplication(appId, app.getUser());</span><br><span class="line">    &#x2F;&#x2F; Finish app &amp; update metrics</span><br><span class="line">    app.move(dest);</span><br><span class="line">    &#x2F;&#x2F; Submit to a new queue</span><br><span class="line">    dest.submitApplicationAttempt(app, user);</span><br><span class="line">    applications.get(appId).setQueue(dest);</span><br><span class="line">    LOG.info(&quot;App: &quot; + app.getApplicationId() + &quot; successfully moved from &quot;</span><br><span class="line">        + sourceQueueName + &quot; to: &quot; + destQueueName);</span><br><span class="line">    return targetQueueName;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒烟测试用例"><a href="#冒烟测试用例" class="headerlink" title="冒烟测试用例"></a>冒烟测试用例</h2><p>[TestCapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testReservedContainerLeakWhenMoveApplication() throws Exception &#123;</span><br><span class="line">  CapacitySchedulerConfiguration csConf</span><br><span class="line">          &#x3D; new CapacitySchedulerConfiguration();</span><br><span class="line">  csConf.setQueues(CapacitySchedulerConfiguration.ROOT, new String[] &#123;&quot;a&quot;, &quot;b&quot;&#125;);</span><br><span class="line">  csConf.setCapacity(&quot;root.a&quot;,50);</span><br><span class="line">  csConf.setMaximumCapacity(&quot;root.a&quot;,100);</span><br><span class="line">  csConf.setUserLimitFactor(&quot;root.a&quot;,100);</span><br><span class="line">  csConf.setCapacity(&quot;root.b&quot;,50);</span><br><span class="line">  csConf.setMaximumCapacity(&quot;root.b&quot;,100);</span><br><span class="line">  csConf.setUserLimitFactor(&quot;root.b&quot;,100);</span><br><span class="line"></span><br><span class="line">  YarnConfiguration conf&#x3D;new YarnConfiguration(csConf);</span><br><span class="line">  conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class,</span><br><span class="line">          ResourceScheduler.class);</span><br><span class="line">  RMNodeLabelsManager mgr&#x3D;new NullRMNodeLabelsManager();</span><br><span class="line">  mgr.init(conf);</span><br><span class="line">  MockRM rm1 &#x3D; new MockRM(csConf);</span><br><span class="line">  CapacityScheduler scheduler&#x3D;(CapacityScheduler) rm1.getResourceScheduler();</span><br><span class="line">  rm1.getRMContext().setNodeLabelManager(mgr);</span><br><span class="line">  rm1.start();</span><br><span class="line">  MockNM nm1 &#x3D; rm1.registerNode(&quot;127.0.0.1:1234&quot;, 8 * GB);</span><br><span class="line">  MockNM nm2 &#x3D; rm1.registerNode(&quot;127.0.0.2:1234&quot;, 8 * GB);</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * simulation</span><br><span class="line">   * app1: (1 AM,1 running container)</span><br><span class="line">   * app2: (1 AM,1 reserved container)</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; launch an app to queue, AM container should be launched in nm1</span><br><span class="line">  RMApp app1 &#x3D; rm1.submitApp(1 * GB, &quot;app_1&quot;, &quot;user_1&quot;, null, &quot;a&quot;);</span><br><span class="line">  MockAM am1 &#x3D; MockRM.launchAndRegisterAM(app1, rm1, nm1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; launch another app to queue, AM container should be launched in nm1</span><br><span class="line">  RMApp app2 &#x3D; rm1.submitApp(1 * GB, &quot;app_2&quot;, &quot;user_1&quot;, null, &quot;a&quot;);</span><br><span class="line">  MockAM am2 &#x3D; MockRM.launchAndRegisterAM(app2, rm1, nm1);</span><br><span class="line"></span><br><span class="line">  am1.allocate(&quot;*&quot;, 4 * GB, 1, new ArrayList&lt;ContainerId&gt;());</span><br><span class="line">  &#x2F;&#x2F;this containerRequest should be reserved</span><br><span class="line">  am2.allocate(&quot;*&quot;, 4 * GB, 1, new ArrayList&lt;ContainerId&gt;());</span><br><span class="line"></span><br><span class="line">  RMNode rmNode1 &#x3D; rm1.getRMContext().getRMNodes().get(nm1.getNodeId());</span><br><span class="line">  &#x2F;&#x2F; Do node heartbeats 2 times</span><br><span class="line">  &#x2F;&#x2F; First time will allocate container for app1, second time will reserve</span><br><span class="line">  &#x2F;&#x2F; container for app2</span><br><span class="line">  scheduler.handle(new NodeUpdateSchedulerEvent(rmNode1));</span><br><span class="line">  scheduler.handle(new NodeUpdateSchedulerEvent(rmNode1));</span><br><span class="line"></span><br><span class="line">  FiCaSchedulerApp schedulerApp1 &#x3D;</span><br><span class="line">          scheduler.getApplicationAttempt(am1.getApplicationAttemptId());</span><br><span class="line">  FiCaSchedulerApp schedulerApp2 &#x3D;</span><br><span class="line">          scheduler.getApplicationAttempt(am2.getApplicationAttemptId());</span><br><span class="line">  &#x2F;&#x2F; APP1:  1 AM, 1 allocatedContainer</span><br><span class="line">  Assert.assertEquals(2, schedulerApp1.getLiveContainers().size());</span><br><span class="line">  &#x2F;&#x2F; APP2:  1 AM,1 reservedContainer</span><br><span class="line">  Assert.assertEquals(1,schedulerApp2.getLiveContainers().size());</span><br><span class="line">  Assert.assertEquals(1,schedulerApp2.getReservedContainers().size());</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * before,move app2 which has one reservedContainer</span><br><span class="line">   *&#x2F;</span><br><span class="line">  LeafQueue srcQueue &#x3D; (LeafQueue) scheduler.getQueue(&quot;a&quot;);</span><br><span class="line">  LeafQueue desQueue &#x3D; (LeafQueue) scheduler.getQueue(&quot;b&quot;);</span><br><span class="line">  Assert.assertEquals(4,srcQueue.getNumContainers());</span><br><span class="line">  Assert.assertEquals(10*GB,srcQueue.getUsedResources().getMemorySize());&#x2F;&#x2F; AM: 2*1GB   container: 4GB running,4GB reserved</span><br><span class="line">  Assert.assertEquals(0,desQueue.getNumContainers());</span><br><span class="line">  Assert.assertEquals(0,desQueue.getUsedResources().getMemorySize());</span><br><span class="line">  &#x2F;&#x2F;app1 ResourceUsage (0 reserved)</span><br><span class="line">  Assert.assertEquals(5*GB,schedulerApp1.getAppAttemptResourceUsage().getAllUsed().getMemorySize());</span><br><span class="line">  Assert.assertEquals(0,schedulerApp1.getCurrentReservation().getMemorySize());</span><br><span class="line">  &#x2F;&#x2F;app2  ResourceUsage (4GB reserved)</span><br><span class="line">  Assert.assertEquals(1*GB,schedulerApp2.getAppAttemptResourceUsage().getAllUsed().getMemorySize());</span><br><span class="line">  Assert.assertEquals(4*GB,schedulerApp2.getCurrentReservation().getMemorySize());</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * move app2 which has one reservedContainer</span><br><span class="line">   *&#x2F;</span><br><span class="line">  scheduler.moveApplication(app2.getApplicationId(),&quot;b&quot;);</span><br><span class="line">  &#x2F;&#x2F; finish.keep the order,if killing app1 first,the reservedContainer of app2 will be allocated</span><br><span class="line">  rm1.killApp(app2.getApplicationId());</span><br><span class="line">  rm1.killApp(app1.getApplicationId());</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * after,moved app2 which has one reservedContainer</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; after fixed</span><br><span class="line">    Assert.assertEquals(0, srcQueue.getNumContainers());</span><br><span class="line">    Assert.assertEquals(0, desQueue.getNumContainers());</span><br><span class="line">    Assert.assertEquals(0, srcQueue.getUsedResources().getMemorySize());</span><br><span class="line">    Assert.assertEquals(0, desQueue.getUsedResources().getMemorySize());</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;*&#123;</span><br><span class="line">    &#x2F;&#x2F; before fixed</span><br><span class="line">    &#x2F;&#x2F; &lt;b&gt; the reserved container borrowed from srcQueue and returned to desQueue,</span><br><span class="line">    &#x2F;&#x2F; but the numContainer and UsedResource did not sync when moving app to another queue &lt;&#x2F;b&gt;</span><br><span class="line">    Assert.assertEquals(+1,srcQueue.getNumContainers());    &#x2F;&#x2F;true</span><br><span class="line">    Assert.assertEquals(-1,desQueue.getNumContainers());    &#x2F;&#x2F;true</span><br><span class="line">    Assert.assertEquals(+4*GB, srcQueue.getUsedResources().getMemorySize());    &#x2F;&#x2F;true</span><br><span class="line">    Assert.assertEquals(-4*GB, desQueue.getUsedResources().getMemorySize());    &#x2F;&#x2F;true</span><br><span class="line">  &#125;*&#x2F;</span><br><span class="line">  rm1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线上测试用例"><a href="#线上测试用例" class="headerlink" title="线上测试用例"></a>线上测试用例</h2>]]></content>
      <tags>
        <tag>源码解析</tag>
        <tag>Yarn 2.7.3</tag>
        <tag>Yarn 优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ExecutorAllocationManager源码分析</title>
    <url>/2019-08-09-ExecutorAllocationManager/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Spark 为 Standalone 和 CoarseGrained(Yarn/Mesos)调度模式提供了动态资源(executor)分配功能,可以根据 Application 的工作负载动态调整其占用的资源.在多 Application 同时运行的情况下,可以提高资源利用率.原理是Spark 定时调度,利用正在运行和积压的任务数推算出需要的executor 数量并和已持有的数量对比,增加 executor;利用维护的节点空闲时间信息,释放掉空闲的 executor.</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code>在SparkOnYarn任务执行的时候,发现了下面几条日志:
ExecutorAllocationManager: Requesting 2 new executors because tasks are backlogged (new desired total will be 7)
ExecutorAllocationManager: Removing executor 6 because it has been idle for 180 seconds (new desired total will be 5)
上述日志没有时间先后及因果关系,发现ExecutorAllocationManager 会依据积压的任务申请新的 executor,并在 executor 空闲一段时间后释放 executor.</code></pre><h2 id="开启方法"><a href="#开启方法" class="headerlink" title="开启方法"></a>开启方法</h2><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><pre><code>仅以资源调度平台最通用的 yarn 举例
   1.spark 源代码编译时需支持 yarn 特性  
   2.将 $SPARK_HOME/common/network-yarn/target/scala-&lt;version&gt;/spark-&lt;version&gt;-yarn-shuffle.jar移动到各 NodeManager 的 classpath 下  
   3.各节点的yarn-site.xml 配置文件中,设置 yarn.nodemanager.aux-services为spark_shuffle,yarn.nodemanager.aux-services.spark_shuffle.class为org.apache.spark.network.yarn.YarnShuffleService
   4.etc/hadoop/yarn-env.sh文件中,增加NodeManager 的堆内存YARN_HEAPSIZE,以减少 shuffle 期间的 GC 频率
   5.重启所有的 NodeManager</code></pre><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><pre><code>必须把下面两个参数默认都是 false,需要设置为 true
spark.dynamicAllocation.enabled true        开启动态资源分配机制
spark.shuffle.service.enabled true      使用额外的 shuffle service 服务,可以使 executor 被移除时,不会删除该 executor写入的 shuffle数据.
spark.shuffle.service.port 7337   额外的 shuffle service 服务所占用的端口</code></pre><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>spark.dynamicAllocation.enabled true<br>spark.shuffle.service.enabled true<br>spark.dynamicAllocation.minExecutors 2        动态数量下界<br>spark.dynamicAllocation.maxExecutors 100     动态数量上界<br>spark.dynamicAllocation.initialExecutors 2     executor初始化时申请的数量<br>spark.dynamicAllocation.schedulerBacklogTimeout 60s  被积压的任务等待时间超过此值时,触发一次executor申请<br>spark.dynamicAllocation.sustainedSchedulerBacklogTimeout 60s 和spark.dynamicAllocation.schedulerBacklogTimeout值相同,用于后续的executor申请<br>spark.dynamicAllocation.executorIdleTimeout 180s     executor在空闲了该时间之后,释放该 executor<br>spark.dynamicAllocation.cachedExecutorIdleTimeout infinity  缓存了数据的 executor 在空闲了该时间之后,释放该 executor.一般不修改即不删除   </p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>ExecutorAllocationManager 被调用的入口是 SparkContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SparkContext.scala]</span><br><span class="line">    val dynamicAllocationEnabled &#x3D; Utils.isDynamicAllocationEnabled(_conf) &#x2F;&#x2F;判断 spark.dynamicAllocation.enable 参数</span><br><span class="line">    _executorAllocationManager &#x3D;</span><br><span class="line">      if (dynamicAllocationEnabled) &#123;</span><br><span class="line">        schedulerBackend match &#123;</span><br><span class="line">          case b: ExecutorAllocationClient &#x3D;&gt;	&#x2F;&#x2F;子类是 StandaloneSchdulerBackend 和 CoarseGrainedSchedulerBackend,没有 Local</span><br><span class="line">            Some(new ExecutorAllocationManager(</span><br><span class="line">              schedulerBackend.asInstanceOf[ExecutorAllocationClient], listenerBus, _conf,</span><br><span class="line">              _env.blockManager.master))</span><br><span class="line">          case _ &#x3D;&gt;</span><br><span class="line">            None</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        None</span><br><span class="line">      &#125;</span><br><span class="line">    _executorAllocationManager.foreach(_.start())</span><br></pre></td></tr></table></figure>

<p>ExecutorAllocationManager中的关键成员变量,主要用于申请/注销 executor 时的信息维护</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ExecutorAllocationManager.scala]</span><br><span class="line">  &#x2F;&#x2F;在下次申请 executor 时的滚动增量	</span><br><span class="line">  private var numExecutorsToAdd &#x3D; 1</span><br><span class="line">  &#x2F;&#x2F;当前已持有的 executor 数量.如果运行中所有的 executor 都挂了,该值正是 application 向 clustermanager 申请的 executor 数量,而非再从 initExecutorNum 和 numExecutorToAdd 滚动增加至挂掉前状态</span><br><span class="line">  private var numExecutorsTarget &#x3D; initialNumExecutors</span><br><span class="line">  &#x2F;&#x2F;已经请求释放但是还没被释放的 executor 列表</span><br><span class="line">  private val executorsPendingToRemove &#x3D; new mutable.HashSet[String]</span><br><span class="line">  &#x2F;&#x2F;application 所有的 executor</span><br><span class="line">  private val executorIds &#x3D; new mutable.HashSet[String]</span><br><span class="line">  &#x2F;&#x2F; A timestamp of when an addition should be triggered, or NOT_SET if it is not set</span><br><span class="line">  &#x2F;&#x2F; This is set when pending tasks are added but not scheduled yet</span><br><span class="line">  private var addTime: Long &#x3D; NOT_SET</span><br><span class="line">   &#x2F;&#x2F;&lt;executorId,最大存活时间&gt;信息.在 executor 第一次注册或不再运行任务时设置</span><br><span class="line">  private val removeTimes &#x3D; new mutable.HashMap[String, Long]</span><br><span class="line">  &#x2F;&#x2F;是否是 application初始化时期.为 true 时,不会申请executor;当开始执行任务后或者executor 已经过了超时时间 时为 false</span><br><span class="line">  @volatile private var initializing: Boolean &#x3D; true</span><br><span class="line">  &#x2F;&#x2F;用于 executor 本地化计算分配,调用 clustermanager 接口的必须参数</span><br><span class="line">  private var localityAwareTasks &#x3D; 0</span><br><span class="line">  &#x2F;&#x2F;用于 executor 本地化计算分配,调用cm 接口的必须参数</span><br><span class="line">  private var hostToLocalTaskCount: Map[String, Int] &#x3D; Map.empty</span><br></pre></td></tr></table></figure>

<p>周期性检测 application 的工作负载,动态调节executor 的数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutorAllocationManager.scala</span><br><span class="line"> def start(): Unit &#x3D; &#123;</span><br><span class="line">    listenerBus.addToManagementQueue(listener)</span><br><span class="line">    val scheduleTask &#x3D; new Runnable() &#123;</span><br><span class="line">      override def run(): Unit &#x3D; &#123;</span><br><span class="line">             ...</span><br><span class="line">             schedule()</span><br><span class="line">             ...</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定时调度,间隔100ms</span><br><span class="line">    executor.scheduleWithFixedDelay(scheduleTask, 0, intervalMillis, TimeUnit.MILLISECONDS)</span><br><span class="line">    &#x2F;&#x2F;先向集群申请初始化数量的 executor. numExecutorTarget 初始值是 max(spark.dynamicAllocation.minExecutors,spark.dynamicAllocation.initialExecutors,spark.executor.instances),其他两个参数是 0 和 Map.Empty</span><br><span class="line">    client.requestTotalExecutors(numExecutorsTarget, localityAwareTasks, hostToLocalTaskCount)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>schedule 方法的逻辑分为两块,1.检测是否要申请 executor 以及申请 2.检测是否要释放 executor 以及释放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private def schedule(): Unit &#x3D; synchronized &#123;</span><br><span class="line">    val now &#x3D; clock.getTimeMillis</span><br><span class="line">    &#x2F;&#x2F;申请</span><br><span class="line">    updateAndSyncNumExecutorsTarget(now)</span><br><span class="line">    &#x2F;&#x2F;待释放列表</span><br><span class="line">    val executorIdsToBeRemoved &#x3D; ArrayBuffer[String]()</span><br><span class="line">    &#x2F;&#x2F;保留未超时的 executor,将超时的 executor 加入到待释放列表</span><br><span class="line">    removeTimes.retain &#123; case (executorId, expireTime) &#x3D;&gt;</span><br><span class="line">      val expired &#x3D; now &gt;&#x3D; expireTime</span><br><span class="line">      if (expired) &#123;</span><br><span class="line">        initializing &#x3D; false</span><br><span class="line">        executorIdsToBeRemoved +&#x3D; executorId</span><br><span class="line">      &#125;</span><br><span class="line">      !expired</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;释放</span><br><span class="line">    if (executorIdsToBeRemoved.nonEmpty) &#123;</span><br><span class="line">      removeExecutors(executorIdsToBeRemoved)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先看释放 executor 的逻辑,比较简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private def removeExecutors(executors: Seq[String]): Seq[String] &#x3D; synchronized &#123;</span><br><span class="line">  val executorIdsToBeRemoved &#x3D; new ArrayBuffer[String]</span><br><span class="line">  logInfo(&quot;Request to remove executorIds: &quot; + executors.mkString(&quot;, &quot;))</span><br><span class="line">  &#x2F;&#x2F;当前存活的节点数</span><br><span class="line">  val numExistingExecutors &#x3D; allocationManager.executorIds.size - executorsPendingToRemove.size</span><br><span class="line">  var newExecutorTotal &#x3D; numExistingExecutors</span><br><span class="line">  executors.foreach &#123; executorIdToBeRemoved &#x3D;&gt;</span><br><span class="line">  &#x2F;&#x2F;如果删除该节点,导致存活节点数小于动态资源下界或者小于当前需要的资源数,则不删除</span><br><span class="line">    if (newExecutorTotal - 1 &lt; minNumExecutors) &#123;</span><br><span class="line">      logDebug(s&quot;Not removing idle executor $executorIdToBeRemoved because there are only &quot; +</span><br><span class="line">        s&quot;$newExecutorTotal executor(s) left (minimum number of executor limit $minNumExecutors)&quot;)</span><br><span class="line">    &#125; else if (newExecutorTotal - 1 &lt; numExecutorsTarget) &#123;</span><br><span class="line">      logDebug(s&quot;Not removing idle executor $executorIdToBeRemoved because there are only &quot; +</span><br><span class="line">        s&quot;$newExecutorTotal executor(s) left (number of executor target $numExecutorsTarget)&quot;)</span><br><span class="line">    &#125; else if (canBeKilled(executorIdToBeRemoved)) &#123;</span><br><span class="line">      executorIdsToBeRemoved +&#x3D; executorIdToBeRemoved</span><br><span class="line">      newExecutorTotal -&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (executorIdsToBeRemoved.isEmpty) &#123;</span><br><span class="line">    return Seq.empty[String]</span><br><span class="line">  &#125;</span><br><span class="line">  val executorsRemoved &#x3D; if (testing) &#123;</span><br><span class="line">    executorIdsToBeRemoved</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      client.killExecutors(executorIdsToBeRemoved, adjustTargetNumExecutors &#x3D; false,</span><br><span class="line">      countFailures &#x3D; false, force &#x3D; false)</span><br><span class="line">  &#125;</span><br><span class="line">   client.requestTotalExecutors(numExecutorsTarget, localityAwareTasks, hostToLocalTaskCount)</span><br><span class="line">  newExecutorTotal &#x3D; numExistingExecutors</span><br><span class="line">  if (testing || executorsRemoved.nonEmpty) &#123;</span><br><span class="line">    executorsRemoved.foreach &#123; removedExecutorId &#x3D;&gt;</span><br><span class="line">      newExecutorTotal -&#x3D; 1</span><br><span class="line">      logInfo(s&quot;Removing executor $removedExecutorId because it has been idle for &quot; +</span><br><span class="line">        s&quot;$executorIdleTimeoutS seconds (new desired total will be $newExecutorTotal)&quot;)</span><br><span class="line">      executorsPendingToRemove.add(removedExecutorId)</span><br><span class="line">    &#125;</span><br><span class="line">    executorsRemoved</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    logWarning(s&quot;Unable to reach the cluster manager to kill executor&#x2F;s &quot; +</span><br><span class="line">      s&quot;$&#123;executorIdsToBeRemoved.mkString(&quot;,&quot;)&#125; or no executor eligible to kill!&quot;)</span><br><span class="line">    Seq.empty[String]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>killExecutors 的逻辑在对接底层资源调度平台(Standalone,CoarseGrained)的实现类中,以CoarseGrainedSchedulerBackend为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CoarseGrainedSchedulerBackend.scala]</span><br><span class="line">final override def killExecutors(</span><br><span class="line">      executorIds: Seq[String],</span><br><span class="line">      adjustTargetNumExecutors: Boolean,</span><br><span class="line">      countFailures: Boolean,</span><br><span class="line">      force: Boolean): Seq[String] &#x3D; &#123;</span><br><span class="line">    val response &#x3D; synchronized &#123;</span><br><span class="line">      val (knownExecutors, unknownExecutors) &#x3D; executorIds.partition(executorDataMap.contains)</span><br><span class="line">      unknownExecutors.foreach &#123; id &#x3D;&gt;</span><br><span class="line">        logWarning(s&quot;Executor to kill $id does not exist!&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">     &#x2F;&#x2F;从待删除的列表中过滤掉确定被删除但还未被删除的和没有正在跑task 的 executor,作为此次请求 cm 释放的executor</span><br><span class="line">      val executorsToKill &#x3D; knownExecutors</span><br><span class="line">        .filter &#123; id &#x3D;&gt; !executorsPendingToRemove.contains(id) &#125;</span><br><span class="line">        .filter &#123; id &#x3D;&gt; force || !scheduler.isExecutorBusy(id) &#125;</span><br><span class="line">      executorsToKill.foreach &#123; id &#x3D;&gt; executorsPendingToRemove(id) &#x3D; !countFailures &#125;</span><br><span class="line">      logInfo(s&quot;Actual list of executor(s) to be killed is $&#123;executorsToKill.mkString(&quot;, &quot;)&#125;&quot;)</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; If we do not wish to replace the executors we kill, sync the target number of executors</span><br><span class="line">      &#x2F;&#x2F; with the cluster manager to avoid allocating new ones. When computing the new target,</span><br><span class="line">      &#x2F;&#x2F; take into account executors that are pending to be added or removed.</span><br><span class="line">      val adjustTotalExecutors &#x3D;</span><br><span class="line">        if (adjustTargetNumExecutors) &#123;</span><br><span class="line">          requestedTotalExecutors &#x3D; math.max(requestedTotalExecutors - executorsToKill.size, 0)</span><br><span class="line">          ..</span><br><span class="line">          doRequestTotalExecutors(requestedTotalExecutors)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          numPendingExecutors +&#x3D; knownExecutors.size</span><br><span class="line">          Future.successful(true)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      val killExecutors: Boolean &#x3D;&gt; Future[Boolean] &#x3D;</span><br><span class="line">        if (!executorsToKill.isEmpty) &#123;</span><br><span class="line">          _ &#x3D;&gt; doKillExecutors(executorsToKill)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          _ &#x3D;&gt; Future.successful(false)</span><br><span class="line">        &#125;</span><br><span class="line">      val killResponse &#x3D; adjustTotalExecutors.flatMap(killExecutors)(ThreadUtils.sameThread)</span><br><span class="line">      killResponse.flatMap(killSuccessful &#x3D;&gt;</span><br><span class="line">        Future.successful (if (killSuccessful) executorsToKill else Seq.empty[String])</span><br><span class="line">      )(ThreadUtils.sameThread)</span><br><span class="line">    &#125;</span><br><span class="line">    defaultAskTimeout.awaitResult(response)</span><br><span class="line">  &#125;</span><br><span class="line">   protected def doKillExecutors(executorIds: Seq[String]): Future[Boolean] &#x3D;</span><br><span class="line">    Future.successful(false)</span><br></pre></td></tr></table></figure>
<p>doKillExecutor和doRequestTotalExecutors在 CoarseGrainedSchedulerBackend 中有默认实现,里面内容比较有迷惑性,其实逻辑在YarnSchedulerBackend中,封装了YarnClientSchedulerBackend 和 YarnClusterSchedulerBackend 实现类的通用逻辑.ResourceManager 端的逻辑不在此讨论</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[YarnSchedulerBackend.scala]</span><br><span class="line">  override def doKillExecutors(executorIds: Seq[String]): Future[Boolean] &#x3D; &#123;</span><br><span class="line">    yarnSchedulerEndpointRef.ask[Boolean](KillExecutors(executorIds))</span><br><span class="line">  &#125;</span><br><span class="line">  override def doRequestTotalExecutors(requestedTotal: Int): Future[Boolean] &#x3D; &#123;</span><br><span class="line">    yarnSchedulerEndpointRef.ask[Boolean](prepareRequestExecutors(requestedTotal))</span><br></pre></td></tr></table></figure>
<p>再看申请 executor 的逻辑,对 ExecutorAllocationManager#start#schedule#updateAndSyncNumExecutorsTarget(now)方法做解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private def updateAndSyncNumExecutorsTarget(now: Long): Int &#x3D; synchronized &#123;</span><br><span class="line">    val maxNeeded &#x3D; maxNumExecutorsNeeded</span><br><span class="line">    if (initializing) &#123;</span><br><span class="line">      &#x2F;&#x2F;application job 还没有开始执行第一个 stage,所以不需要申请额外的资源</span><br><span class="line">       0</span><br><span class="line">    &#125; else if (maxNeeded &lt; numExecutorsTarget) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果当前计算出所需的资源小于已经拥有的资源,那么没有必要再申请新的,申请了也是空闲</span><br><span class="line">      &#x2F;&#x2F;可以代入一些值做debug</span><br><span class="line">      val oldNumExecutorsTarget &#x3D; numExecutorsTarget</span><br><span class="line">      numExecutorsTarget &#x3D; math.max(maxNeeded, minNumExecutors)</span><br><span class="line">      numExecutorsToAdd &#x3D; 1</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;math.max(maxNeeded, minNumExecutors)与numExecutorsTarget且maxNeeded &lt; numExecutorsTarget</span><br><span class="line">      if (numExecutorsTarget &lt; oldNumExecutorsTarget) &#123;</span><br><span class="line">        &#x2F;&#x2F; We lower the target number of executors but don&#39;t actively kill any yet.  Killing is</span><br><span class="line">        &#x2F;&#x2F; controlled separately by an idle timeout.  It&#39;s still *helpful* to reduce the target number</span><br><span class="line">        &#x2F;&#x2F; in case an executor just happens to get lost (eg., bad hardware, or the cluster manager</span><br><span class="line">        &#x2F;&#x2F; preempts it) -- in that case, there is no point in trying to immediately  get a new</span><br><span class="line">        &#x2F;&#x2F; executor, since we wouldn&#39;t even use it yet.</span><br><span class="line">        &#x2F;&#x2F;同步当前需要的 executor 数量给 cm</span><br><span class="line">        client.requestTotalExecutors(numExecutorsTarget, localityAwareTasks, hostToLocalTaskCount)</span><br><span class="line">        logDebug(s&quot;Lowering target number of executors to $numExecutorsTarget (previously &quot; +</span><br><span class="line">          s&quot;$oldNumExecutorsTarget) because not all requested executors are actually needed&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      numExecutorsTarget - oldNumExecutorsTarget</span><br><span class="line">    &#125; else if (addTime !&#x3D; NOT_SET &amp;&amp; now &gt;&#x3D; addTime) &#123;</span><br><span class="line">    &#x2F;&#x2F;在 application 已经开始运行,申请过资源;且当前计算出来的需要的 executor 数量大于已有的 executor 数量;且任务已经被积压过(onSchedulerBacklogged事件会设置 add_time)那么会申请 executor</span><br><span class="line">      val delta &#x3D; addExecutors(maxNeeded)</span><br><span class="line">      logDebug(s&quot;Starting timer to add more executors (to &quot; +</span><br><span class="line">        s&quot;expire in $sustainedSchedulerBacklogTimeoutS seconds)&quot;)</span><br><span class="line">      addTime &#x3D; now + (sustainedSchedulerBacklogTimeoutS * 1000)</span><br><span class="line">      delta</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;依据当前stage正在运行的task数量和堆积的task数量来预估需要的executor数量</span><br><span class="line">  &#x2F;&#x2F;之所以是当前 stage,是因为onStageSubmitted和onStageCompleted方法会维护stageIdToNumTasks(hashmap),所以这个 map 里面存储的是DAG中无依赖关系的 stage-tasknum 数据</span><br><span class="line">   private def maxNumExecutorsNeeded(): Int &#x3D; &#123;</span><br><span class="line">    val numRunningOrPendingTasks &#x3D; listener.totalPendingTasks + listener.totalRunningTasks</span><br><span class="line">    (numRunningOrPendingTasks + tasksPerExecutor - 1) &#x2F; tasksPerExecutor</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;申请 executor.如果当前需要的资源数超过动态最大资源数,该次不申请并且将 numExecutorsToAdd(申请 executor 的滚动增量)设置为1,而不是乘以2.</span><br><span class="line">&#x2F;&#x2F;numExecutorsToAdd:1-&gt;2-&gt;4-&gt;8-&gt;1(已持有的数量不小于动态最大数量,则没必要需要太快的增速)-&gt;2-&gt;4</span><br><span class="line">private def addExecutors(maxNumExecutorsNeeded: Int): Int &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; Do not request more executors if it would put our target over the upper bound</span><br><span class="line">    if (numExecutorsTarget &gt;&#x3D; maxNumExecutors) &#123;</span><br><span class="line">      logDebug(s&quot;Not adding executors because our current target total &quot; +</span><br><span class="line">        s&quot;is already $numExecutorsTarget (limit $maxNumExecutors)&quot;)</span><br><span class="line">      numExecutorsToAdd &#x3D; 1</span><br><span class="line">      return 0</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    val oldNumExecutorsTarget &#x3D; numExecutorsTarget</span><br><span class="line">    &#x2F;&#x2F; There&#39;s no point in wasting time ramping up to the number of executors we already have, so</span><br><span class="line">    &#x2F;&#x2F; make sure our target is at least as much as our current allocation:</span><br><span class="line">    numExecutorsTarget &#x3D; math.max(numExecutorsTarget, executorIds.size)</span><br><span class="line">    &#x2F;&#x2F; Boost our target with the number to add for this round:   滚动增量</span><br><span class="line">    numExecutorsTarget +&#x3D; numExecutorsToAdd</span><br><span class="line">    &#x2F;&#x2F; Ensure that our target doesn&#39;t exceed what we need at the present moment:</span><br><span class="line">    numExecutorsTarget &#x3D; math.min(numExecutorsTarget, maxNumExecutorsNeeded)</span><br><span class="line">    &#x2F;&#x2F; Ensure that our target fits within configured bounds:</span><br><span class="line">    numExecutorsTarget &#x3D; math.max(math.min(numExecutorsTarget, maxNumExecutors), minNumExecutors)</span><br><span class="line"></span><br><span class="line">    val delta &#x3D; numExecutorsTarget - oldNumExecutorsTarget</span><br><span class="line">    if (delta &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; Check if there is any speculative jobs pending</span><br><span class="line">      if (listener.pendingTasks &#x3D;&#x3D; 0 &amp;&amp; listener.pendingSpeculativeTasks &gt; 0) &#123;</span><br><span class="line">        numExecutorsTarget &#x3D;</span><br><span class="line">          math.max(math.min(maxNumExecutorsNeeded + 1, maxNumExecutors), minNumExecutors)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        numExecutorsToAdd &#x3D; 1</span><br><span class="line">        return 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val addRequestAcknowledged &#x3D; try &#123;</span><br><span class="line">      testing ||</span><br><span class="line">        client.requestTotalExecutors(numExecutorsTarget, localityAwareTasks, hostToLocalTaskCount)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        ....</span><br><span class="line">        false</span><br><span class="line">    &#125;</span><br><span class="line">    if (addRequestAcknowledged) &#123;</span><br><span class="line">      val executorsString &#x3D; &quot;executor&quot; + &#123; if (delta &gt; 1) &quot;s&quot; else &quot;&quot; &#125;</span><br><span class="line">      logInfo(s&quot;Requesting $delta new $executorsString because tasks are backlogged&quot; +</span><br><span class="line">        s&quot; (new desired total will be $numExecutorsTarget)&quot;)</span><br><span class="line">      numExecutorsToAdd &#x3D; if (delta &#x3D;&#x3D; numExecutorsToAdd) &#123;</span><br><span class="line">        numExecutorsToAdd * 2</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        1</span><br><span class="line">      &#125;</span><br><span class="line">      delta</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      logWarning(</span><br><span class="line">        s&quot;Unable to reach the cluster manager to request $numExecutorsTarget total executors!&quot;)</span><br><span class="line">      numExecutorsTarget &#x3D; oldNumExecutorsTarget</span><br><span class="line">      0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>资源申请</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[YarnSchedulerBackend.scala]</span><br><span class="line">override def doRequestTotalExecutors(requestedTotal: Int): Future[Boolean] &#x3D; &#123;</span><br><span class="line">    yarnSchedulerEndpointRef.ask[Boolean](prepareRequestExecutors(requestedTotal))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ExecutorAllocationListener"><a href="#ExecutorAllocationListener" class="headerlink" title="ExecutorAllocationListener"></a>ExecutorAllocationListener</h2><p>ExecutorAllocationListener监听器监听各类事件,触发相应的回调函数,对自身以及ExecutorAllocationManager 内维护的信息做修改,辅助 ExecutorAllocationManager 做动态资源调度.看一些回调函数的源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Callback invoked when the specified executor has been added.</span><br><span class="line">   *&#x2F;</span><br><span class="line">private def onExecutorAdded(executorId: String): Unit &#x3D; synchronized &#123;</span><br><span class="line">    if (!executorIds.contains(executorId)) &#123;</span><br><span class="line">      executorIds.add(executorId)</span><br><span class="line">      &#x2F;&#x2F; If an executor (call this executor X) is not removed because the lower bound</span><br><span class="line">      &#x2F;&#x2F; has been reached, it will no longer be marked as idle. When new executors join,</span><br><span class="line">      &#x2F;&#x2F; however, we are no longer at the lower bound, and so we must mark executor X</span><br><span class="line">      &#x2F;&#x2F; as idle again so as not to forget that it is a candidate for removal. (see SPARK-4951)</span><br><span class="line">      executorIds.filter(listener.isExecutorIdle).foreach(onExecutorIdle)</span><br><span class="line">      logInfo(s&quot;New executor $executorId has registered (new total is $&#123;executorIds.size&#125;)&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      logWarning(s&quot;Duplicate executor $executorId has registered&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private def onExecutorRemoved(executorId: String): Unit &#x3D; synchronized &#123;</span><br><span class="line">    if (executorIds.contains(executorId)) &#123;</span><br><span class="line">      executorIds.remove(executorId)</span><br><span class="line">      removeTimes.remove(executorId)</span><br><span class="line">      logInfo(s&quot;Existing executor $executorId has been removed (new total is $&#123;executorIds.size&#125;)&quot;)</span><br><span class="line">      if (executorsPendingToRemove.contains(executorId)) &#123;</span><br><span class="line">        executorsPendingToRemove.remove(executorId)</span><br><span class="line">        logDebug(s&quot;Executor $executorId is no longer pending to &quot; +</span><br><span class="line">          s&quot;be removed ($&#123;executorsPendingToRemove.size&#125; left)&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      logWarning(s&quot;Unknown executor $executorId has been removed!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private def onSchedulerBacklogged(): Unit &#x3D; synchronized &#123;</span><br><span class="line">    if (addTime &#x3D;&#x3D; NOT_SET) &#123;</span><br><span class="line">      logDebug(s&quot;Starting timer to add executors because pending tasks &quot; +</span><br><span class="line">        s&quot;are building up (to expire in $schedulerBacklogTimeoutS seconds)&quot;)</span><br><span class="line">      addTime &#x3D; clock.getTimeMillis + schedulerBacklogTimeoutS * 1000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private def onExecutorIdle(executorId: String): Unit &#x3D; synchronized &#123;</span><br><span class="line">    if (executorIds.contains(executorId)) &#123;</span><br><span class="line">      if (!removeTimes.contains(executorId) &amp;&amp; !executorsPendingToRemove.contains(executorId)) &#123;</span><br><span class="line">        val hasCachedBlocks &#x3D; blockManagerMaster.hasCachedBlocks(executorId)</span><br><span class="line">        val now &#x3D; clock.getTimeMillis()</span><br><span class="line">        val timeout &#x3D; &#123;</span><br><span class="line">          if (hasCachedBlocks) &#123;	&#x2F;&#x2F;缓存了数据,shuffle write 数据等</span><br><span class="line">            now + cachedExecutorIdleTimeoutS * 1000</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            now + executorIdleTimeoutS * 1000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        val realTimeout &#x3D; if (timeout &lt;&#x3D; 0) Long.MaxValue else timeout &#x2F;&#x2F; overflow</span><br><span class="line">        removeTimes(executorId) &#x3D; realTimeout</span><br><span class="line">        logDebug(s&quot;Starting idle timer for $executorId because there are no more tasks &quot; +</span><br><span class="line">          s&quot;scheduled to run on the executor (to expire in $&#123;(realTimeout - now)&#x2F;1000&#125; seconds)&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      logWarning(s&quot;Attempted to mark unknown executor $executorId idle&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private def onExecutorBusy(executorId: String): Unit &#x3D; synchronized &#123;</span><br><span class="line">    logDebug(s&quot;Clearing idle timer for $executorId because it is now running a task&quot;)</span><br><span class="line">    removeTimes.remove(executorId)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
</blockquote>
<p>动态资源调度设计的一点思考</p>
<ol>
<li>如何增加资源<br> 负载与当前资源的权衡;资源增加算法:线性增加,对数等;资源快速满足需求快速下降  </li>
<li>如何释放资源<br> 如何判断空闲;资源上有不好处理的逻辑怎么办,数据或计算   </li>
<li>设计模式<br> 事件驱动的设计模式  </li>
<li>解耦的重要性<br> 曾经设计过一个主从式数据处理框架,但是在可拓展性上考虑的比较少.如果现在在那个系统上增加动态资源调度功能,在设计模式和解耦上比不上 spark 之万一…  </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="http://spark.apache.org/docs/2.3.1/configuration.html" target="_blank" rel="noopener">http://spark.apache.org/docs/2.3.1/configuration.html</a><br> <a href="http://spark.apache.org/docs/2.3.1/running-on-yarn.html#configuring-the-external-shuffle-service" target="_blank" rel="noopener">http://spark.apache.org/docs/2.3.1/running-on-yarn.html#configuring-the-external-shuffle-service</a>  </p>
]]></content>
      <tags>
        <tag>Spark 2.3.0</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
</search>
