<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/jerry.icon">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/jerry.icon">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://jiulongzhu.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="概述Parser 模块负责将原始 SQL 文本解析成 UnResolvedLogicPlan，Anayzer 模块负责将 UnResolvedLogicPlan(Relation|Attribute|Function) 通过 SessionCatalog 信息绑定到真正可操作的实体上(File|Column|MainClass)，即 SolvedLogicPlan，并校验其是否合法。">
<meta property="og:type" content="article">
<meta property="og:title" content="SparkSQL源码解析(2):从 UnsolvedLogicPlan 到 ResolvedLogicPlan">
<meta property="og:url" content="https:&#x2F;&#x2F;jiulongzhu.github.io&#x2F;2019-11-29-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(2):%E4%BB%8E%20UnresolvedLogicPlan%20%E5%88%B0%20ResolvedLogicPlan&#x2F;index.html">
<meta property="og:site_name" content="Acadia">
<meta property="og:description" content="概述Parser 模块负责将原始 SQL 文本解析成 UnResolvedLogicPlan，Anayzer 模块负责将 UnResolvedLogicPlan(Relation|Attribute|Function) 通过 SessionCatalog 信息绑定到真正可操作的实体上(File|Column|MainClass)，即 SolvedLogicPlan，并校验其是否合法。">
<meta property="article:published_time" content="2019-11-28T16:00:00.000Z">
<meta property="article:modified_time" content="2020-03-16T10:01:28.110Z">
<meta property="article:author" content="Acadia">
<meta property="article:tag" content="Spark 2.3.0">
<meta property="article:tag" content="源码解析">
<meta property="article:tag" content="Spark SQL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jiulongzhu.github.io/2019-11-29-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(2):%E4%BB%8E%20UnresolvedLogicPlan%20%E5%88%B0%20ResolvedLogicPlan/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>SparkSQL源码解析(2):从 UnsolvedLogicPlan 到 ResolvedLogicPlan | Acadia</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145379133-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-145379133-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Acadia</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Acadia</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://jiulongzhu.github.io/2019-11-29-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(2):%E4%BB%8E%20UnresolvedLogicPlan%20%E5%88%B0%20ResolvedLogicPlan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Acadia">
      <meta itemprop="description" content="Hello World!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Acadia">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SparkSQL源码解析(2):从 UnsolvedLogicPlan 到 ResolvedLogicPlan
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-29T00:00:00+08:00">2019-11-29</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019-11-29-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(2):%E4%BB%8E%20UnresolvedLogicPlan%20%E5%88%B0%20ResolvedLogicPlan/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019-11-29-SparkSQL 源码解析(2):从 UnresolvedLogicPlan 到 ResolvedLogicPlan/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Parser 模块负责将原始 SQL 文本解析成 UnResolvedLogicPlan，Anayzer 模块负责将 UnResolvedLogicPlan(Relation|Attribute|Function) 通过 SessionCatalog 信息绑定到真正可操作的实体上(File|Column|MainClass)，即 SolvedLogicPlan，并校验其是否合法。   </p>
<a id="more"></a>

<p>则关键点在于:   </p>
<ol>
<li>SessionCatalog 存在目的        </li>
<li>如何绑定，将 UnresolvedLogicPlan 转换为 ResolvedLogicPlan    </li>
<li>如何校验 ResolvedLogicPlan 合法  </li>
</ol>
<p>1.Analyzer 对 UnresolvedLogicPlan应用各类规则(Rule),并对各个 UnresolvedLogicPlan节点绑定 CataLog 信息,将 UnresolvedLogicPlan中的UnresolvedRelation 和 UnresolvedAttribute解析成有类型(Typed)的对象,生成解析后的逻辑算子树 SolvedLogicPlan.<br>2.对 UnresolvedLogicPlan 的大部分操作,如绑定解析优化等,主要方法都是基于规则(Rule)的,然后通过模式匹配对UnresolvedLogicPlan进行相应处理.<br>3.Catalog信息在Analyzer的构造函数中.  </p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>调用栈<br>-&gt;SparkSession#sql<br>　-&gt;DataSet#ofRows<br>　　-&gt;QueryExecution#assertAnalyzed<br>　　　-&gt;QueryExecution#analyzed (lazy)<br>　　　　-&gt;Analyzer#executeAndCheck<br>[Anayzer.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def executeAndCheck(plan: LogicalPlan): LogicalPlan &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一步: 绑定</span><br><span class="line">    val analyzed &#x3D; execute(plan)</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 第二步: 校验</span><br><span class="line">      checkAnalysis(analyzed)</span><br><span class="line">      &#x2F;&#x2F; 将 LogicPlan 的 AnalysisBarrier 装箱去掉(如果存在)</span><br><span class="line">      EliminateBarriers(analyzed)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case e: AnalysisException &#x3D;&gt;</span><br><span class="line">        val ae &#x3D; new AnalysisException(e.message, e.line, e.startPosition, Option(analyzed))</span><br><span class="line">        ae.setStackTrace(e.getStackTrace)</span><br><span class="line">        throw ae</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SessionCatalog"><a href="#SessionCatalog" class="headerlink" title="SessionCatalog"></a>SessionCatalog</h3><p>SessionCatalog 是 SparkSession 索引维护的信息库，SessionCatalog 一方面可以管理 SparkSession 创建的临时视图和 UDF，一方面可以作为外部元数据库的代理以便 SparkSession 获取外部源数据库信息(e.g. HiveSessionCatalog 操作 Hive metastore)。    </p>
<table>
<thead>
<tr>
<th align="left">成员变量</th>
<th align="left">数据类型</th>
<th align="left">功能</th>
<th align="left">Catalog 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tableRelationCache</td>
<td align="left">Cache[QualifiedTableName, LogicalPlan]</td>
<td align="left">表全限定名与逻辑计划的映射</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">tempViews</td>
<td align="left">HashMap[String, LogicalPlan]</td>
<td align="left">临时视图名与逻辑计划的映射</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">globalTempViewManager</td>
<td align="left">GlobalTempViewManager</td>
<td align="left">全局视图管理</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">externalCatalog</td>
<td align="left">ExternalCatalog</td>
<td align="left">外部元数据库的代理,从获得连接到库表分区函数等信息获取接口</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">functionRegistry</td>
<td align="left">FunctionRegistry</td>
<td align="left">函数(builtin,UDF)操作代理</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">parser</td>
<td align="left">ParserInterface</td>
<td align="left">SQL 文本解析 Parser</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">functionResourceLoader</td>
<td align="left">FunctionResourceLoader</td>
<td align="left">加载函数主类资源加载器</td>
<td align="left">SessionCatalog</td>
</tr>
<tr>
<td align="left">metastoreCatalog</td>
<td align="left">HiveMetastoreCatalog</td>
<td align="left">HiveExternalCatalog 的旧接口,deprecated</td>
<td align="left">HiveSessionCatalog</td>
</tr>
</tbody></table>
<p>引用一个通过表名绑定逻辑计划的函数: 通过表所属数据库名在全局视图，外部元数据库和临时视图内搜索以绑定逻辑计划<br>[SessionCatalog.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def lookupRelation(name: TableIdentifier): LogicalPlan &#x3D; &#123;</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      val db &#x3D; formatDatabaseName(name.database.getOrElse(currentDb))</span><br><span class="line">      val table &#x3D; formatTableName(name.table)</span><br><span class="line">      &#x2F;&#x2F; 全局视图</span><br><span class="line">      if (db &#x3D;&#x3D; globalTempViewManager.database) &#123;</span><br><span class="line">        globalTempViewManager.get(table).map &#123; viewDef &#x3D;&gt;</span><br><span class="line">          SubqueryAlias(table, viewDef)</span><br><span class="line">        &#125;.getOrElse(throw new NoSuchTableException(db, table))</span><br><span class="line">      &#125; else if (name.database.isDefined || !tempViews.contains(table)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 外部元数据库</span><br><span class="line">        val metadata &#x3D; externalCatalog.getTable(db, table)</span><br><span class="line">        if (metadata.tableType &#x3D;&#x3D; CatalogTableType.VIEW) &#123;</span><br><span class="line">          val viewText &#x3D; metadata.viewText.getOrElse(sys.error(&quot;Invalid view without text.&quot;))</span><br><span class="line">          val child &#x3D; View(</span><br><span class="line">            desc &#x3D; metadata,</span><br><span class="line">            output &#x3D; metadata.schema.toAttributes,</span><br><span class="line">            child &#x3D; parser.parsePlan(viewText))</span><br><span class="line">          SubqueryAlias(table, child)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          SubqueryAlias(table, UnresolvedCatalogRelation(metadata))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 临时视图</span><br><span class="line">        SubqueryAlias(table, tempViews(table))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>Anayzer 模块对 UnResolvedLogicPlan 应用多批规则库，其中主要是 Resolution(解析)规则库和 Substitution(转换)规则库，直到每批规则库达到了指定的迭代次数或者规则库无法再优化逻辑计划为止。  </p>
<p>调用栈<br>Analyzer#executeAndCheck<br>　-&gt;Analyzer#execute<br>　　-&gt;Analyzer#executeSameContext<br>　　　-&gt;RuleExecutor#execute<br>[RuleExecutor.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 规则批次间和批次内都是串行执行</span><br><span class="line"> * 逻辑计划在此处被 Analyzed 之后就替换了(result&#x2F;curPlan和返回值)</span><br><span class="line"> *&#x2F;</span><br><span class="line">def execute(plan: TreeType): TreeType &#x3D; &#123;</span><br><span class="line">  var curPlan &#x3D; plan</span><br><span class="line">  batches.foreach &#123; batch &#x3D;&gt;</span><br><span class="line">    val batchStartPlan &#x3D; curPlan</span><br><span class="line">    var iteration &#x3D; 1</span><br><span class="line">    var lastPlan &#x3D; curPlan	&#x2F;&#x2F;tempPlan</span><br><span class="line">    var continue &#x3D; true</span><br><span class="line">    &#x2F;&#x2F; foldLeft 依次执行规则 batch 中的所有规则,直到达到了规则的最大执行次数或者逻辑算子树不再变化</span><br><span class="line">    while (continue) &#123;</span><br><span class="line">      curPlan &#x3D; batch.rules.foldLeft(curPlan) &#123; </span><br><span class="line">        case (plan, rule) &#x3D;&gt;</span><br><span class="line">        &#x2F;&#x2F; 在逻辑计划上应用规则处理</span><br><span class="line">          val result &#x3D; rule(plan) &#x2F;&#x2F;rule.apply(plan)</span><br><span class="line">          if (!result.fastEquals(plan)) &#123;</span><br><span class="line">            logTrace(</span><br><span class="line">              s&quot;&quot;&quot;</span><br><span class="line">                |&#x3D;&#x3D;&#x3D; Applying Rule $&#123;rule.ruleName&#125; &#x3D;&#x3D;&#x3D;</span><br><span class="line">                |$&#123;sideBySide(plan.treeString, result.treeString).mkString(&quot;\n&quot;)&#125;</span><br><span class="line">              &quot;&quot;&quot;.stripMargin)</span><br><span class="line">          &#125;</span><br><span class="line">          queryExecutionMetrics.incExecutionTimeBy(rule.ruleName, runTime)</span><br><span class="line">          queryExecutionMetrics.incNumExecution(rule.ruleName)</span><br><span class="line">          ....</span><br><span class="line">           result</span><br><span class="line">      &#125;</span><br><span class="line">      iteration +&#x3D; 1</span><br><span class="line">       &#x2F;&#x2F; 达到了该规则批策略的最大迭代次数</span><br><span class="line">      if (iteration &gt; batch.strategy.maxIterations) &#123;</span><br><span class="line">        ...</span><br><span class="line">        continue &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 这批规则已经不能再优化逻辑计划了</span><br><span class="line">      if (curPlan.fastEquals(lastPlan)) &#123;</span><br><span class="line">        logTrace(</span><br><span class="line">          s&quot;Fixed point reached for batch $&#123;batch.name&#125; after $&#123;iteration - 1&#125; iterations.&quot;)</span><br><span class="line">        continue &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlan &#x3D; curPlan</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  curPlan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是其中的 rule(plan)方法，即 Rule#apply(plan)。各规则子类依据自身的功能解析转换 TreeNode，包括绑定 UnResolvedLogicPlan 为 ResolvedLogicPlan<br> [Rule.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class Rule[TreeType &lt;: TreeNode[_]] extends Logging &#123;</span><br><span class="line">  val ruleName: String &#x3D; &#123;</span><br><span class="line">    val className &#x3D; getClass.getName</span><br><span class="line">    if (className endsWith &quot;$&quot;) className.dropRight(1) else className</span><br><span class="line">  &#125;</span><br><span class="line">  def apply(plan: TreeType): TreeType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则的具体功能列表参考”附录：规则功能列表”   </p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>调用栈<br>Analyze#executeAndCheck<br>　-&gt;CheckAndAnalysis#checkAnalysis  </p>
<p>检查 ResolvedLogicPlan 中不合乎语法规范的错误，使用后序遍历(先子节点后当前节点)的方式尽可能抛出最先导致失败的错误<br>[CheckAndAnaysis.scala]  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">def checkAnalysis(plan: LogicalPlan): Unit &#x3D; &#123;</span><br><span class="line">    plan.foreachUp &#123;</span><br><span class="line">      case u: UnresolvedRelation &#x3D;&gt;</span><br><span class="line">        u.failAnalysis(s&quot;Table or view not found: $&#123;u.tableIdentifier&#125;&quot;)</span><br><span class="line"></span><br><span class="line">      case operator: LogicalPlan &#x3D;&gt;</span><br><span class="line">        operator transformExpressionsUp &#123;</span><br><span class="line">          case a: Attribute if !a.resolved &#x3D;&gt;</span><br><span class="line">            val from &#x3D; operator.inputSet.map(_.qualifiedName).mkString(&quot;, &quot;)</span><br><span class="line">            a.failAnalysis(s&quot;cannot resolve &#39;$&#123;a.sql&#125;&#39; given input columns: [$from]&quot;)</span><br><span class="line"></span><br><span class="line">          case e: Expression if e.checkInputDataTypes().isFailure &#x3D;&gt;</span><br><span class="line">            e.checkInputDataTypes() match &#123;</span><br><span class="line">              case TypeCheckResult.TypeCheckFailure(message) &#x3D;&gt;</span><br><span class="line">                e.failAnalysis(</span><br><span class="line">                  s&quot;cannot resolve &#39;$&#123;e.sql&#125;&#39; due to data type mismatch: $message&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          case c: Cast if !c.resolved &#x3D;&gt;</span><br><span class="line">            failAnalysis(</span><br><span class="line">              s&quot;invalid cast from $&#123;c.child.dataType.simpleString&#125; to $&#123;c.dataType.simpleString&#125;&quot;)</span><br><span class="line"></span><br><span class="line">          case g: Grouping &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;grouping() can only be used with GroupingSets&#x2F;Cube&#x2F;Rollup&quot;)</span><br><span class="line">          case g: GroupingID &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;grouping_id() can only be used with GroupingSets&#x2F;Cube&#x2F;Rollup&quot;)</span><br><span class="line"></span><br><span class="line">          case w @ WindowExpression(AggregateExpression(_, _, true, _), _) &#x3D;&gt;</span><br><span class="line">            failAnalysis(s&quot;Distinct window functions are not supported: $w&quot;)</span><br><span class="line"></span><br><span class="line">          case w @ WindowExpression(_: OffsetWindowFunction,</span><br><span class="line">            WindowSpecDefinition(_, order, frame: SpecifiedWindowFrame))</span><br><span class="line">             if order.isEmpty || !frame.isOffset &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;An offset window function can only be evaluated in an ordered &quot; +</span><br><span class="line">              s&quot;row-based window frame with a single offset: $w&quot;)</span><br><span class="line"></span><br><span class="line">          case w @ WindowExpression(e, s) &#x3D;&gt;</span><br><span class="line">            &#x2F;&#x2F; Only allow window functions with an aggregate expression or an offset window</span><br><span class="line">            &#x2F;&#x2F; function.</span><br><span class="line">            e match &#123;</span><br><span class="line">              case _: AggregateExpression | _: OffsetWindowFunction | _: AggregateWindowFunction &#x3D;&gt;</span><br><span class="line">                w</span><br><span class="line">              case _ &#x3D;&gt;</span><br><span class="line">                failAnalysis(s&quot;Expression &#39;$e&#39; not supported within a window function.&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          case s: SubqueryExpression &#x3D;&gt;</span><br><span class="line">            checkSubqueryExpression(operator, s)</span><br><span class="line">            s</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operator match &#123;</span><br><span class="line">          case etw: EventTimeWatermark &#x3D;&gt;</span><br><span class="line">            etw.eventTime.dataType match &#123;</span><br><span class="line">              case s: StructType</span><br><span class="line">                if s.find(_.name &#x3D;&#x3D; &quot;end&quot;).map(_.dataType) &#x3D;&#x3D; Some(TimestampType) &#x3D;&gt;</span><br><span class="line">              case _: TimestampType &#x3D;&gt;</span><br><span class="line">              case _ &#x3D;&gt;</span><br><span class="line">                failAnalysis(</span><br><span class="line">                  s&quot;Event time must be defined on a window or a timestamp, but &quot; +</span><br><span class="line">                  s&quot;$&#123;etw.eventTime.name&#125; is of type $&#123;etw.eventTime.dataType.simpleString&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">          case f: Filter if f.condition.dataType !&#x3D; BooleanType &#x3D;&gt;</span><br><span class="line">            failAnalysis(</span><br><span class="line">              s&quot;filter expression &#39;$&#123;f.condition.sql&#125;&#39; &quot; +</span><br><span class="line">                s&quot;of type $&#123;f.condition.dataType.simpleString&#125; is not a boolean.&quot;)</span><br><span class="line"></span><br><span class="line">          case Filter(condition, _) if hasNullAwarePredicateWithinNot(condition) &#x3D;&gt;</span><br><span class="line">            failAnalysis(&quot;Null-aware predicate sub-queries cannot be used in nested &quot; +</span><br><span class="line">              s&quot;conditions: $condition&quot;)</span><br><span class="line"></span><br><span class="line">          case j @ Join(_, _, _, Some(condition)) if condition.dataType !&#x3D; BooleanType &#x3D;&gt;</span><br><span class="line">            failAnalysis(</span><br><span class="line">              s&quot;join condition &#39;$&#123;condition.sql&#125;&#39; &quot; +</span><br><span class="line">                s&quot;of type $&#123;condition.dataType.simpleString&#125; is not a boolean.&quot;)</span><br><span class="line">	..........</span><br><span class="line">	&#x2F;&#x2F; 自定义的规则检查在内置规则检查之后才能开始</span><br><span class="line">    extendedCheckRules.foreach(_(plan))</span><br><span class="line">    plan.foreachUp &#123;</span><br><span class="line">      case AnalysisBarrier(child) if !child.resolved &#x3D;&gt; checkAnalysis(child)</span><br><span class="line">      case o if !o.resolved &#x3D;&gt; failAnalysis(s&quot;unresolved operator $&#123;o.simpleString&#125;&quot;)</span><br><span class="line">      case _ &#x3D;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>UnResolvedLogicPlan 在绑定了 Catalog 之后可以转换为 RDD 模式来执行了，但是由于提交的 SQL 质量参差不齐，按照 ResolvedLogicPlan 按部就班的执行会导致代价/效率差距很大 且 要求用户对执行引擎的执行模式很了解并熟悉 SQL 优化手段才能写出效率高执行快的 SQL。所以为了尽可能忽略用户的代码质量，对SQL 优化的熟悉程度，SparkSQL 都需要以很高的效率执行，SparkSQL 在后续阶段需要对 UnResolvedLogicPlan 进行优化，即 Rule-Based Optimizer，也称为 RBO。    </p>
<h2 id="附录：规则功能列表"><a href="#附录：规则功能列表" class="headerlink" title="附录：规则功能列表"></a>附录：规则功能列表</h2><p>规则库 Batch: 在 UnResolvedLogicPlan 上应用规则库 rules 的执行策略 strategy。 
[Batch.scala]  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case class Batch(name: String, strategy: Strategy, rules: Rule[TreeType]*)</span><br></pre></td></tr></table></figure>
<p>Strategy 表示规则批的最大迭代次数，有两个子类: Once 表明只需应用一次规则库即可；FixedPoint 表示最大可以应用规则库 maxIterations 次，如果应用中途无法再优化逻辑计划则跳出。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class Strategy &#123; def maxIterations: Int &#125;</span><br><span class="line">case object Once extends Strategy &#123; val maxIterations &#x3D; 1 &#125;</span><br><span class="line">case class FixedPoint(maxIterations: Int) extends Strategy</span><br></pre></td></tr></table></figure>
<p>规则 Rule 的子类有很多,在 Analyze.scala 中使用的所有规则如下<br>[Analyzer.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">lazy val batches: Seq[Batch] &#x3D; Seq(</span><br><span class="line">  Batch(&quot;Hints&quot;, fixedPoint,</span><br><span class="line">    new ResolveHints.ResolveBroadcastHints(conf),</span><br><span class="line">    ResolveHints.RemoveAllHints),</span><br><span class="line">  Batch(&quot;Simple Sanity Check&quot;, Once,</span><br><span class="line">    LookupFunctions),</span><br><span class="line">  Batch(&quot;Substitution&quot;, fixedPoint,</span><br><span class="line">    CTESubstitution,</span><br><span class="line">    WindowsSubstitution,</span><br><span class="line">    EliminateUnions,</span><br><span class="line">    new SubstituteUnresolvedOrdinals(conf)),</span><br><span class="line">  Batch(&quot;Resolution&quot;, fixedPoint,</span><br><span class="line">    ResolveTableValuedFunctions ::</span><br><span class="line">    ResolveRelations ::</span><br><span class="line">    ResolveReferences ::</span><br><span class="line">    ResolveCreateNamedStruct ::</span><br><span class="line">    ResolveDeserializer ::</span><br><span class="line">    ResolveNewInstance ::</span><br><span class="line">    ResolveUpCast ::</span><br><span class="line">    ResolveGroupingAnalytics ::</span><br><span class="line">    ResolvePivot ::</span><br><span class="line">    ResolveOrdinalInOrderByAndGroupBy ::</span><br><span class="line">    ResolveAggAliasInGroupBy ::</span><br><span class="line">    ResolveMissingReferences ::</span><br><span class="line">    ExtractGenerator ::</span><br><span class="line">    ResolveGenerate ::</span><br><span class="line">    ResolveFunctions ::</span><br><span class="line">    ResolveAliases ::</span><br><span class="line">    ResolveSubquery ::</span><br><span class="line">    ResolveSubqueryColumnAliases ::</span><br><span class="line">    ResolveWindowOrder ::</span><br><span class="line">    ResolveWindowFrame ::</span><br><span class="line">    ResolveNaturalAndUsingJoin ::</span><br><span class="line">    ExtractWindowExpressions ::</span><br><span class="line">    GlobalAggregates ::</span><br><span class="line">    ResolveAggregateFunctions ::</span><br><span class="line">    TimeWindowing ::</span><br><span class="line">    ResolveInlineTables(conf) ::</span><br><span class="line">    ResolveTimeZone(conf) ::</span><br><span class="line">    TypeCoercion.typeCoercionRules(conf) ++</span><br><span class="line">    extendedResolutionRules : _*),</span><br><span class="line">  Batch(&quot;Post-Hoc Resolution&quot;, Once, postHocResolutionRules: _*),</span><br><span class="line">  Batch(&quot;View&quot;, Once,</span><br><span class="line">    AliasViewChild(conf)),</span><br><span class="line">  Batch(&quot;Nondeterministic&quot;, Once,</span><br><span class="line">    PullOutNondeterministic),</span><br><span class="line">  Batch(&quot;UDF&quot;, Once,</span><br><span class="line">    HandleNullInputsForUDF),</span><br><span class="line">  Batch(&quot;FixNullability&quot;, Once,</span><br><span class="line">    FixNullability),</span><br><span class="line">  Batch(&quot;Subquery&quot;, Once,</span><br><span class="line">    UpdateOuterReferences),</span><br><span class="line">  Batch(&quot;Cleanup&quot;, fixedPoint,</span><br><span class="line">    CleanupAliases)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中最重要的规则库是Substitution(替换)和Resolution(解析绑定)。这些规则库之间及规则库之内都是有序的，使用规则时也是串行执行的。打乱了顺序可能有转换不充分等未知的错误<br>下表主要参照 org.apache.spark.sql.catalyst.parser.SqlBase.g4 文件和源码，带问号的为不确定的。</p>
<table>
<thead>
<tr>
<th>规则批次</th>
<th>规则</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Hints</td>
<td>ResolveBroadcastHints</td>
<td>广播</td>
<td>mapjoin</td>
</tr>
<tr>
<td>Hints</td>
<td>RemoveAllHints</td>
<td>删除无效标识符</td>
<td></td>
</tr>
<tr>
<td>Simple Sanity Check</td>
<td>LookupFunctions</td>
<td>函数存在性检验</td>
<td></td>
</tr>
<tr>
<td>Substitution</td>
<td>CTESubstitution</td>
<td>with,合并计划</td>
<td>with a as something select * from a</td>
</tr>
<tr>
<td>Substitution</td>
<td>WindowsSubstitution</td>
<td>窗口函数</td>
<td>row_number() over (partitioned by a sort by b desc)</td>
</tr>
<tr>
<td>Substitution</td>
<td>EliminateUnions</td>
<td>union的计划只有一个时删除 union</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveTableValuedFunctions</td>
<td>解析可作为表的函数</td>
<td>range函数</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveRelations</td>
<td>表绑定catalog中的逻辑计划</td>
<td>对应createXXXView接口</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveReferences</td>
<td>展开星号绑定列</td>
<td>select a.* from</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveCreateNamedStruct</td>
<td>解析结构体构造方法</td>
<td>?,没见过hql中使用结构体</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveDeserializer</td>
<td>解析反序列化类</td>
<td>decoder</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveNewInstance</td>
<td>解析创建实例</td>
<td>encoder</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveUpCast</td>
<td>解析类型转换</td>
<td>cast,在丢失精度时抛异常</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveGroupingAnalytics</td>
<td>解析rollup多维度分析</td>
<td>group by a,b,c with rollup 等价于 group by a,b,c grouping sets((a,b,c),(a,b),(a),())</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolvePivot</td>
<td>行转列</td>
<td>pivot 接口</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveOrdinalInOrderByAndGroupBy</td>
<td>解析order/sort/group by语句的下标数字</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveAggAliasInGroupBy</td>
<td>解析聚合时的表达式</td>
<td>group by case when then x else y end</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveMissingReferences</td>
<td>解析在排序时不存在的列,加上但隐藏该列</td>
<td>select a from … order by b</td>
</tr>
<tr>
<td>Resolution</td>
<td>ExtractGenerator</td>
<td>解析UDTF生成器</td>
<td>select explode(xx) from ..</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveGenerate</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveFunctions</td>
<td>解析函数为表达式</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveAliases</td>
<td>解析生成别名表达式</td>
<td>?</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveSubquery</td>
<td>解析子查询</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveSubqueryColumnAliases</td>
<td>解析子查询列别名</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveWindowOrder</td>
<td>解析窗口函数中的排序</td>
<td>over partitioned by .. order by..</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveWindowFrame</td>
<td>解析检验窗口函数</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveNaturalAndUsingJoin</td>
<td>通过输出列解析自然连接</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ExtractWindowExpressions</td>
<td>提取窗口函数表达式</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>GlobalAggregates</td>
<td>解析全局聚合</td>
<td>select max(a) from tbl</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveAggregateFunctions</td>
<td>解析不在聚合中的聚合函数</td>
<td>having/order by</td>
</tr>
<tr>
<td>Resolution</td>
<td>TimeWindowing</td>
<td>解析滑动时间窗口</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveInlineTables</td>
<td>解析内联表为LocalRelation</td>
<td>select * fom values(..),(..) as (columns)</td>
</tr>
<tr>
<td>Resolution</td>
<td>ResolveTimeZone</td>
<td>解析时区表达式</td>
<td></td>
</tr>
<tr>
<td>Resolution</td>
<td>TypeCoercion.typeCoercionRules</td>
<td>强制转换为兼容类型</td>
<td>在比较和 union 时使用,不损失精度</td>
</tr>
<tr>
<td>Resolution</td>
<td>extendedResolutionRules</td>
<td>拓展规则,空集合</td>
<td>?</td>
</tr>
<tr>
<td>Post-Hoc Resolution</td>
<td>postHocResolutionRules</td>
<td>Resolution 规则后执行的规则.空集合</td>
<td></td>
</tr>
<tr>
<td>View</td>
<td>AliasViewChild</td>
<td>视图的分析规则</td>
<td></td>
</tr>
<tr>
<td>Nondeterministic</td>
<td>PullOutNondeterministic</td>
<td>提取非确定性表达式,放到child 中</td>
<td>?</td>
</tr>
<tr>
<td>UDF</td>
<td>HandleNullInputsForUDF</td>
<td>对UDF增加基本数据类型null处理(空输入则空输出)</td>
<td></td>
</tr>
<tr>
<td>FixNullability</td>
<td>FixNullability</td>
<td>通过 child 字段的 Nullablity 修复父逻辑计划字段的 Nullablity</td>
<td></td>
</tr>
<tr>
<td>Subquery</td>
<td>UpdateOuterReferences</td>
<td>聚合表达式下推</td>
<td>?</td>
</tr>
<tr>
<td>Cleanup</td>
<td>CleanupAliases</td>
<td>删除不需要的别名</td>
<td></td>
</tr>
</tbody></table>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with a  as … select * from a 语法是 SQL 语句中的一个特殊 case，with 子句打乱了 SQL 解析的通用模式，无法从上至下从左至右进行解析，只能将整个语句解析为两个相对独立的逻辑算子树，然后通过别名将 with 语句的逻辑算子树加入到主体逻辑算子树的下面  </p>
<p>[WindowsSubstitution.scala] </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object WindowsSubstitution extends Rule[LogicalPlan] &#123;</span><br><span class="line">  def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformUp &#123;</span><br><span class="line">    &#x2F;&#x2F;使用多层 match case 来匹配拿到 window 函数,</span><br><span class="line">    case WithWindowDefinition(windowDefinitions, child) &#x3D;&gt;</span><br><span class="line">      child.transform &#123;</span><br><span class="line">        case p &#x3D;&gt; p.transformExpressions &#123;</span><br><span class="line">          case UnresolvedWindowExpression(c, WindowSpecReference(windowName)) &#x3D;&gt;</span><br><span class="line">            val errorMessage &#x3D;</span><br><span class="line">              s&quot;Window specification $windowName is not defined in the WINDOW clause.&quot;</span><br><span class="line">            val windowSpecDefinition &#x3D;</span><br><span class="line">              windowDefinitions.getOrElse(windowName, failAnalysis(errorMessage))</span><br><span class="line">            WindowExpression(c, windowSpecDefinition)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="relation"><a href="#relation" class="headerlink" title="relation"></a>relation</h3><p>绑定关系<br>[ResolveRelations.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> object ResolveRelations extends Rule[LogicalPlan] &#123;</span><br><span class="line">  &#x2F;&#x2F; 后序遍历尝试绑定每个匹配的节点到 ResolvedLogicPlan</span><br><span class="line">   def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformUp &#123;</span><br><span class="line">     case i @ InsertIntoTable(u: UnresolvedRelation, parts, child, _, _) if child.resolved &#x3D;&gt;</span><br><span class="line">      &#x2F;&#x2F; lookupTableFromCatalog(u) 从全局视图&gt;外接元数据库&gt;临时视图中绑定实体  </span><br><span class="line">      &#x2F;&#x2F; EliminateSubqueryAliases 去掉别名将子查询查询计划剥离出来</span><br><span class="line">       EliminateSubqueryAliases(lookupTableFromCatalog(u)) match &#123;</span><br><span class="line">         case v: View &#x3D;&gt;</span><br><span class="line">           u.failAnalysis(s&quot;Inserting into a view is not allowed. View: $&#123;v.desc.identifier&#125;.&quot;)</span><br><span class="line">         case other &#x3D;&gt; i.copy(table &#x3D; other)</span><br><span class="line">       &#125;</span><br><span class="line">     case u: UnresolvedRelation &#x3D;&gt; resolveRelation(u)	</span><br><span class="line">   &#125;</span><br><span class="line">   先看第一个 case,如果是 insert into 句法的话,借助 catalog的&lt;tableName,LogicPlan&gt;缓存绑定表为已解析过的逻辑计划</span><br><span class="line">   private def lookupTableFromCatalog(</span><br><span class="line">       u: UnresolvedRelation,</span><br><span class="line">       defaultDatabase: Option[String] &#x3D; None): LogicalPlan &#x3D; &#123;</span><br><span class="line">     val tableIdentWithDb &#x3D; u.tableIdentifier.copy(</span><br><span class="line">       database &#x3D; u.tableIdentifier.database.orElse(defaultDatabase))</span><br><span class="line">     try &#123;</span><br><span class="line">       catalog.lookupRelation(tableIdentWithDb)</span><br><span class="line">     &#125; catch &#123;</span><br><span class="line">	....        </span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">[SessionCatalog.scala] </span><br><span class="line"> def lookupRelation(name: TableIdentifier): LogicalPlan &#x3D; &#123;</span><br><span class="line">   synchronized &#123;</span><br><span class="line">     val db &#x3D; formatDatabaseName(name.database.getOrElse(currentDb))</span><br><span class="line">     val table &#x3D; formatTableName(name.table)</span><br><span class="line">     &#x2F;&#x2F;从全局临时视图,外接元数据库,临时视图中查找该表的逻辑计划</span><br><span class="line">     if (db &#x3D;&#x3D; globalTempViewManager.database) &#123;</span><br><span class="line">       globalTempViewManager.get(table).map &#123; viewDef &#x3D;&gt;</span><br><span class="line">         SubqueryAlias(table, viewDef)</span><br><span class="line">       &#125;.getOrElse(throw new NoSuchTableException(db, table))</span><br><span class="line">     &#125; else if (name.database.isDefined || !tempViews.contains(table)) &#123;</span><br><span class="line">       val metadata &#x3D; externalCatalog.getTable(db, table)</span><br><span class="line">       if (metadata.tableType &#x3D;&#x3D; CatalogTableType.VIEW) &#123;</span><br><span class="line">         val viewText &#x3D; metadata.viewText.getOrElse(sys.error(&quot;Invalid view without text.&quot;))</span><br><span class="line">         val child &#x3D; View(</span><br><span class="line">           desc &#x3D; metadata,</span><br><span class="line">           output &#x3D; metadata.schema.toAttributes,</span><br><span class="line">           child &#x3D; parser.parsePlan(viewText))</span><br><span class="line">         SubqueryAlias(table, child)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         SubqueryAlias(table, UnresolvedCatalogRelation(metadata))</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       SubqueryAlias(table, tempViews(table))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 再看ResolveRelations.apply方法的第二个 case u:UnresolvedRelation &#x3D;&gt; resolveRelation(u),所以首先会进入下面方法的第一个 case, 即如果不是直接在文件上运行(from json.$path)的话,先从 Catalog 中绑定逻辑计划</span><br><span class="line"> [ResolveRelation.scala]</span><br><span class="line">   def resolveRelation(plan: LogicalPlan): LogicalPlan &#x3D; plan match &#123;</span><br><span class="line">     case u: UnresolvedRelation if !isRunningDirectlyOnFiles(u.tableIdentifier) &#x3D;&gt;</span><br><span class="line">       val defaultDatabase &#x3D; AnalysisContext.get.defaultDatabase</span><br><span class="line">       val foundRelation &#x3D; lookupTableFromCatalog(u, defaultDatabase)</span><br><span class="line">       resolveRelation(foundRelation)</span><br><span class="line">     case view @ View(desc, _, child) if !child.resolved &#x3D;&gt;</span><br><span class="line">       &#x2F;&#x2F; Resolve all the UnresolvedRelations and Views in the child.</span><br><span class="line">       val newChild &#x3D; AnalysisContext.withAnalysisContext(desc.viewDefaultDatabase) &#123;</span><br><span class="line">         if (AnalysisContext.get.nestedViewDepth &gt; conf.maxNestedViewDepth) &#123;</span><br><span class="line">           view.failAnalysis(s&quot;The depth of view $&#123;view.desc.identifier&#125; exceeds the maximum &quot; +</span><br><span class="line">             s&quot;view resolution depth ($&#123;conf.maxNestedViewDepth&#125;). Analysis is aborted to &quot; +</span><br><span class="line">             s&quot;avoid errors. Increase the value of $&#123;SQLConf.MAX_NESTED_VIEW_DEPTH.key&#125; to work &quot; +</span><br><span class="line">             &quot;around this.&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">         executeSameContext(child)</span><br><span class="line">       &#125;</span><br><span class="line">       view.copy(child &#x3D; newChild)</span><br><span class="line">     case p @ SubqueryAlias(_, view: View) &#x3D;&gt;</span><br><span class="line">       val newChild &#x3D; resolveRelation(view)</span><br><span class="line">       p.copy(child &#x3D; newChild)</span><br><span class="line">     case _ &#x3D;&gt; plan</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LookupFunctions"><a href="#LookupFunctions" class="headerlink" title="LookupFunctions"></a>LookupFunctions</h3><p>函数存在性校验<br>[LookupFuncations.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object LookupFunctions extends Rule[LogicalPlan] &#123;</span><br><span class="line">    override def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformAllExpressions &#123;</span><br><span class="line">     &#x2F;&#x2F; 递归检测使用的函数在 catalog 中是否存在</span><br><span class="line">      case f: UnresolvedFunction if !catalog.functionExists(f.name) &#x3D;&gt;</span><br><span class="line">        withPosition(f) &#123;</span><br><span class="line">          throw new NoSuchFunctionException(f.name.database.getOrElse(&quot;default&quot;), f.name.funcName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>[SessionCatalog.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def functionExists(name: FunctionIdentifier): Boolean &#x3D; &#123;</span><br><span class="line">    val db &#x3D; formatDatabaseName(name.database.getOrElse(getCurrentDatabase))</span><br><span class="line">    requireDbExists(db)</span><br><span class="line">    &#x2F;&#x2F; 使用 FuncationRegistry 和外接元数据库检测函数是否存在</span><br><span class="line">    functionRegistry.functionExists(name) ||</span><br><span class="line">      externalCatalog.functionExists(db, name.funcName)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ResolveFunction"><a href="#ResolveFunction" class="headerlink" title="ResolveFunction"></a>ResolveFunction</h3><p>将函数替换为具体的表达式<br>[ResolveFunction.scala]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">object ResolveFunctions extends Rule[LogicalPlan] &#123;</span><br><span class="line">    def apply(plan: LogicalPlan): LogicalPlan &#x3D; plan.transformUp &#123;</span><br><span class="line">      case q: LogicalPlan &#x3D;&gt;</span><br><span class="line">        q transformExpressions &#123;</span><br><span class="line">          case u if !u.childrenResolved &#x3D;&gt; u &#x2F;&#x2F; Skip until children are resolved.</span><br><span class="line">          case u: UnresolvedAttribute if resolver(u.name, VirtualColumn.hiveGroupingIdName) &#x3D;&gt;</span><br><span class="line">            withPosition(u) &#123;</span><br><span class="line">              Alias(GroupingID(Nil), VirtualColumn.hiveGroupingIdName)()</span><br><span class="line">            &#125;</span><br><span class="line">          case u @ UnresolvedGenerator(name, children) &#x3D;&gt;</span><br><span class="line">            withPosition(u) &#123;</span><br><span class="line">              catalog.lookupFunction(name, children) match &#123;</span><br><span class="line">                case generator: Generator &#x3D;&gt; generator</span><br><span class="line">                case other &#x3D;&gt;</span><br><span class="line">                  failAnalysis(s&quot;$name is expected to be a generator. However, &quot; +</span><br><span class="line">                    s&quot;its class is $&#123;other.getClass.getCanonicalName&#125;, which is not a generator.&quot;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          case u @ UnresolvedFunction(funcId, children, isDistinct) &#x3D;&gt;</span><br><span class="line">            withPosition(u) &#123;</span><br><span class="line">              &#x2F;&#x2F; 使用 catalog 寻找函数</span><br><span class="line">              catalog.lookupFunction(funcId, children) match &#123;</span><br><span class="line">                case wf: AggregateWindowFunction &#x3D;&gt;</span><br><span class="line">                  if (isDistinct) &#123;</span><br><span class="line">                    failAnalysis(s&quot;$&#123;wf.prettyName&#125; does not support the modifier DISTINCT&quot;)</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    wf</span><br><span class="line">                  &#125;</span><br><span class="line">                case agg: AggregateFunction &#x3D;&gt; AggregateExpression(agg, Complete, isDistinct)</span><br><span class="line">                case other &#x3D;&gt;</span><br><span class="line">                  if (isDistinct) &#123;</span><br><span class="line">                    failAnalysis(s&quot;$&#123;other.prettyName&#125; does not support the modifier DISTINCT&quot;)</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    other</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用 SessionCatalog 优先从 FunctionRegistry 中寻找，然后从外接元数据库寻找并加载资源注册到 FunctionRegistry，有些像双亲委派模型，保证 builtin 的函数不被 UDF覆盖。<br>[SessionCatalog.scala]  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def lookupFunction(</span><br><span class="line">      name: FunctionIdentifier,</span><br><span class="line">      children: Seq[Expression]): Expression &#x3D; synchronized &#123;</span><br><span class="line">    if (name.database.isEmpty &amp;&amp; functionRegistry.functionExists(name)) &#123;</span><br><span class="line">      &#x2F;&#x2F; This function has been already loaded into the function registry.</span><br><span class="line">      return functionRegistry.lookupFunction(name, children)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If the name itself is not qualified, add the current database to it.</span><br><span class="line">    val database &#x3D; formatDatabaseName(name.database.getOrElse(getCurrentDatabase))</span><br><span class="line">    val qualifiedName &#x3D; name.copy(database &#x3D; Some(database))</span><br><span class="line"></span><br><span class="line">    if (functionRegistry.functionExists(qualifiedName)) &#123;</span><br><span class="line">      return functionRegistry.lookupFunction(qualifiedName, children)</span><br><span class="line">    &#125;</span><br><span class="line">    val catalogFunction &#x3D; try &#123;</span><br><span class="line">      externalCatalog.getFunction(database, name.funcName)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case _: AnalysisException &#x3D;&gt; failFunctionLookup(name)</span><br><span class="line">      case _: NoSuchPermanentFunctionException &#x3D;&gt; failFunctionLookup(name)</span><br><span class="line">    &#125;</span><br><span class="line">    loadFunctionResources(catalogFunction.resources)</span><br><span class="line">    registerFunction(catalogFunction.copy(identifier &#x3D; qualifiedName), overrideIfExists &#x3D; false)</span><br><span class="line">    &#x2F;&#x2F; Now, we need to create the Expression.</span><br><span class="line">    functionRegistry.lookupFunction(qualifiedName, children)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spark-2-3-0/" rel="tag"># Spark 2.3.0</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag"># 源码解析</a>
              <a href="/tags/Spark-SQL/" rel="tag"># Spark SQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019-11-28-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(1):%E4%BB%8E%20SQL%20%E5%88%B0%20UnResolvedLogicPlan/" rel="prev" title="SparkSQL源码解析(1):从 SQL 到 UnResolvedLogicPlan">
      <i class="fa fa-chevron-left"></i> SparkSQL源码解析(1):从 SQL 到 UnResolvedLogicPlan
    </a></div>
      <div class="post-nav-item">
    <a href="/2019-12-10-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(3):%E4%BB%8E%20ResolvedLogicPlan%20%E5%88%B0%20OptimizedLogicPlan/" rel="next" title="SparkSQL源码解析(3):从 ResolvedLogicPlan 到 OptimizedLogicPlan">
      SparkSQL源码解析(3):从 ResolvedLogicPlan 到 OptimizedLogicPlan <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码解析"><span class="nav-number">2.</span> <span class="nav-text">源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SessionCatalog"><span class="nav-number">2.1.</span> <span class="nav-text">SessionCatalog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定"><span class="nav-number">2.2.</span> <span class="nav-text">绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#校验"><span class="nav-number">2.3.</span> <span class="nav-text">校验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO"><span class="nav-number">3.</span> <span class="nav-text">TODO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录：规则功能列表"><span class="nav-number">4.</span> <span class="nav-text">附录：规则功能列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#with"><span class="nav-number">4.1.</span> <span class="nav-text">with</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#relation"><span class="nav-number">4.2.</span> <span class="nav-text">relation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LookupFunctions"><span class="nav-number">4.3.</span> <span class="nav-text">LookupFunctions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResolveFunction"><span class="nav-number">4.4.</span> <span class="nav-text">ResolveFunction</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Acadia</p>
  <div class="site-description" itemprop="description">Hello World!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jiulongzhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiulongzhu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xxx.jiulong.zhu@gmail.com" title="E-Mail → mailto:xxx.jiulong.zhu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Acadia</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jiulong.zhu.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://jiulongzhu.github.io/2019-11-29-SparkSQL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(2):%E4%BB%8E%20UnresolvedLogicPlan%20%E5%88%B0%20ResolvedLogicPlan/",
            identifier: "2019-11-29-SparkSQL 源码解析(2):从 UnresolvedLogicPlan 到 ResolvedLogicPlan/",
            title: "SparkSQL源码解析(2):从 UnsolvedLogicPlan 到 ResolvedLogicPlan"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://jiulong.zhu.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
