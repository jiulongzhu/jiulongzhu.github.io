<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/jerry.icon">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/jerry.icon">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://jiulongzhu.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="问题背景多个线上运行状态私有云的某些资源队列,在无任何 Application 提交及运行、资源队列完全空闲的情况下,  Used Capacity、Absolute Used Capacity、Used Resource、Num Containers指标非零异常">
<meta property="og:type" content="article">
<meta property="og:title" content="Yarn movetoqueue 导致的UI指标错误的修复思路">
<meta property="og:url" content="https:&#x2F;&#x2F;jiulongzhu.github.io&#x2F;2019-09-15-Yarn:movetoqueue%E5%AF%BC%E8%87%B4%E7%9A%84UIcontainer%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF&#x2F;index.html">
<meta property="og:site_name" content="List&#39;s Blog">
<meta property="og:description" content="问题背景多个线上运行状态私有云的某些资源队列,在无任何 Application 提交及运行、资源队列完全空闲的情况下,  Used Capacity、Absolute Used Capacity、Used Resource、Num Containers指标非零异常">
<meta property="og:image" content="https:&#x2F;&#x2F;jiulongzhu.github.io&#x2F;img&#x2F;pictures&#x2F;negative&#x2F;negative_e7a766275896.png">
<meta property="og:image" content="https:&#x2F;&#x2F;jiulongzhu.github.io&#x2F;img&#x2F;pictures&#x2F;negative&#x2F;yarn_node_update_pic.png">
<meta property="og:image" content="https:&#x2F;&#x2F;jiulongzhu.github.io&#x2F;img&#x2F;pictures&#x2F;negative&#x2F;negative_e7a766275896.png">
<meta property="og:image" content="https:&#x2F;&#x2F;jiulongzhu.github.io&#x2F;img&#x2F;pictures&#x2F;negative&#x2F;negative_aead-04d8e67b1357.png">
<meta property="article:published_time" content="2019-09-14T16:00:00.000Z">
<meta property="article:modified_time" content="2020-03-16T10:01:28.106Z">
<meta property="article:author" content="List">
<meta property="article:tag" content="源码解析">
<meta property="article:tag" content="Yarn 2.7.3">
<meta property="article:tag" content="Yarn 优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;jiulongzhu.github.io&#x2F;img&#x2F;pictures&#x2F;negative&#x2F;negative_e7a766275896.png">

<link rel="canonical" href="https://jiulongzhu.github.io/2019-09-15-Yarn:movetoqueue%E5%AF%BC%E8%87%B4%E7%9A%84UIcontainer%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Yarn movetoqueue 导致的UI指标错误的修复思路 | List's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145379133-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-145379133-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">List's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">李斯特</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://jiulongzhu.github.io/2019-09-15-Yarn:movetoqueue%E5%AF%BC%E8%87%B4%E7%9A%84UIcontainer%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="List">
      <meta itemprop="description" content="Hello World!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="List's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Yarn movetoqueue 导致的UI指标错误的修复思路
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-15T00:00:00+08:00">2019-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-16 18:01:28" itemprop="dateModified" datetime="2020-03-16T18:01:28+08:00">2020-03-16</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019-09-15-Yarn:movetoqueue%E5%AF%BC%E8%87%B4%E7%9A%84UIcontainer%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019-09-15-Yarn:movetoqueue导致的UIcontainer泄露问题的修复思路/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>多个线上运行状态私有云的某些资源队列,在无任何 Application 提交及运行、资源队列完全空闲的情况下, 
Used Capacity、Absolute Used Capacity、Used Resource、Num Containers指标非零异常  </p>
<a id="more"></a>

<blockquote>
</blockquote>
<p>在Yarn ResourceManager管理界面中,有 scheduler 选项卡,展示了Yarn 当前使用的调度器及各资源队列的信息(YarnUI-&gt;scheduler-&gt;Application Queue),其中每项指标代表的含义是:<br>Queue State: 表示当前队列的状态,有 RUNNING/STOPPED 两种状态<br>Used Capacity: 表示当前队列已使用的资源占当前队列总资源的百分比<br>Configured Capacity: 表示当前队列的资源占父队列资源的百分比<br>Configured Max Capacity: 表示当前队列资源最大能占父队列资源的百分比<br>Absolute Used Capacity: 表示当前队列已使用的资源占 root 队列资源(整个集群)的百分比<br>Absolute Configured Capacity: 表示当前队列的资源占 root 队列总资源的百分比<br>Absolute Configured Max Capacity: 表示当前的队列的资源最大能占 root 队列的百分比<br>Used Resources: 表示当前队列已使用的资源总量(资源以内存和虚拟核形态表示,基本调度单位)<br>Num Schedulable Applications: 表示当前队列调度的应用个数
Num Non-Schedulable Applications: 表示当前队列没有调度(积压,pending)的应用个数<br>Num Containers: 表示当前队列已经启动的 container 个数<br>Max Applications: 表示当前队列最大并发调度应用个数<br>Max Applications Per User: 表示当前队列对每个用户最大并发调度应用个数<br>Max Application Master Resources: 表示所有 Application 的 AM 可使用资源量之和的最大值<br>Used Application Master Resources: 表示当前队列中所有 Application 的 AM 使用资源量之和<br>Max Application Master Resources Per User: 表示当前队列中每个用户的 Application 的 AM 使用资源量之和的最大值<br>Configured Minimum User Limit Percent: 表示队列每个用户分配的最低资源百分比(资源保障)<br>Configured User Limit Factor: 表示每个用户能占用的队列资源的百分比<br>Accessible Node Labels:  表示当前队列可在哪些节点上分配资源 (*为全部节点)<br>Preemption: 是否允许资源抢占  </p>
<p>指标可分为两类:配置型指标,静态数据 不会变化,如 Configured Capacity;状态型指标,动态数据 随应用的提交运行结束而变化,如 Used Capacity.<br>运行时异常指标如下图,无 Application 运行的情况下,low 队列状态型指标为负</p>
<p><img src="/img/pictures/negative/negative_e7a766275896.png" alt=""></p>
<h2 id="先期判断"><a href="#先期判断" class="headerlink" title="先期判断"></a>先期判断</h2><h3 id="指标关联的变量定位"><a href="#指标关联的变量定位" class="headerlink" title="指标关联的变量定位"></a>指标关联的变量定位</h3><p>线上 hadoop 版本: hadoop 2.7.3<br>Yarn ResourceManager 管理界面启动的入口是org.apache.hadoop.yarn.server.resourcemanager.ResourceManager#startWebApp()<br>[ResourceManager.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void startWepApp() &#123;</span><br><span class="line">	....</span><br><span class="line">    Builder&lt;ApplicationMasterService&gt; builder &#x3D; </span><br><span class="line">        WebApps</span><br><span class="line">            .$for(&quot;cluster&quot;, ApplicationMasterService.class, masterService,</span><br><span class="line">                &quot;ws&quot;)</span><br><span class="line">            .with(conf)</span><br><span class="line">            .withHttpSpnegoPrincipalKey(</span><br><span class="line">                YarnConfiguration.RM_WEBAPP_SPNEGO_USER_NAME_KEY)</span><br><span class="line">            .withHttpSpnegoKeytabKey(</span><br><span class="line">                YarnConfiguration.RM_WEBAPP_SPNEGO_KEYTAB_FILE_KEY)</span><br><span class="line">            .at(webAppAddress);</span><br><span class="line">   	....</span><br><span class="line">    webApp &#x3D; builder.start(new RMWebApp(this));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RMWebApp 主要逻辑是使用 Google Guice 做依赖注入,并分发请求绑定后台逻辑,大致相当于 SpringMVC 系统中的 Dispatcher 的角色<br>对 Yarn UI界面左侧边栏 scheduler 的请求会转发给 RmController#scheduler()方法处理<br>[RMWebApp.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setup() &#123;</span><br><span class="line">    ...</span><br><span class="line">    bind(RMWebApp.class).toInstance(this);</span><br><span class="line">    if (rm !&#x3D; null) &#123;</span><br><span class="line">      bind(ResourceManager.class).toInstance(rm);</span><br><span class="line">      bind(ApplicationBaseProtocol.class).toInstance(rm.getClientRMService());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    route(&quot;&#x2F;scheduler&quot;, RmController.class, &quot;scheduler&quot;);</span><br><span class="line">    route(pajoin(&quot;&#x2F;queue&quot;, QUEUE_NAME), RmController.class, &quot;queue&quot;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RmController#scheduler() 先获取到 Guice 注入的 ResourceManager,然后依据 RM 使用的调度器做页面渲染.<br>页面渲染逻辑的入口是CapacitySchedulerPage#render()<br>[RmController.java]  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void scheduler() &#123;</span><br><span class="line">    ...</span><br><span class="line">    ResourceManager rm &#x3D; getInstance(ResourceManager.class);</span><br><span class="line">    ResourceScheduler rs &#x3D; rm.getResourceScheduler();</span><br><span class="line">    if (rs &#x3D;&#x3D; null || rs instanceof CapacityScheduler) &#123;</span><br><span class="line">      setTitle(&quot;Capacity Scheduler&quot;);</span><br><span class="line">      &#x2F;&#x2F;渲染</span><br><span class="line">      render(CapacitySchedulerPage.class);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rs instanceof FairScheduler) &#123;</span><br><span class="line">      setTitle(&quot;Fair Scheduler&quot;);</span><br><span class="line">      render(FairSchedulerPage.class);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line"> protected void render(Class&lt;? extends View&gt; cls) &#123;</span><br><span class="line">    context().rendered &#x3D; true;</span><br><span class="line">    getInstance(cls).render();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>泛型上界是 View,调用栈是:<br>View#render()<br>&ensp;&ensp;-&gt;HtmlPage#render()<br>&ensp;&ensp;&ensp;&ensp;&ensp;-&gt;TwoColumnLayout#render(html)<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-&gt;CapacitySchedulerPage#content()<br>[CapacitySchedulerPage.java] </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;? extends SubView&gt; content() &#123;</span><br><span class="line">    return QueuesBlock.class;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>QueuesBlock 是 CapacitySchedulerPage 的内部类,用于展示CapacityScheduler 的 DashBoard 信息,包含队列、标签、应用概览信息,并构建根队列 root 来做为后续递归渲染的起点<br>[QueuesBlock.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class QueuesBlock extends HtmlBlock &#123;</span><br><span class="line">    final CapacityScheduler cs;</span><br><span class="line">    final CSQInfo csqinfo;</span><br><span class="line">    private List&lt;NodeLabel&gt; nodeLabelsInfo;</span><br><span class="line">    </span><br><span class="line">    public void render(Block html) &#123;</span><br><span class="line">        ...</span><br><span class="line">        float used &#x3D; 0;</span><br><span class="line">        if (null &#x3D;&#x3D; nodeLabelsInfo</span><br><span class="line">            || (nodeLabelsInfo.size() &#x3D;&#x3D; 1 &amp;&amp; nodeLabelsInfo.get(0)</span><br><span class="line">                .getLabelName().isEmpty())) &#123;</span><br><span class="line">                &#x2F;&#x2F;创建根队列,作为后续渲染的起点</span><br><span class="line">          CSQueue root &#x3D; cs.getRootQueue();</span><br><span class="line">          CapacitySchedulerInfo sinfo &#x3D;</span><br><span class="line">              new CapacitySchedulerInfo(root, new NodeLabel(</span><br><span class="line">                  RMNodeLabelsManager.NO_LABEL));</span><br><span class="line">          csqinfo.csinfo &#x3D; sinfo;</span><br><span class="line">          csqinfo.qinfo &#x3D; null;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">          ul.li().</span><br><span class="line">            ...</span><br><span class="line">            _(QueueBlock.class)._();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          for (NodeLabel label : nodeLabelsInfo) &#123;</span><br><span class="line">            ....</span><br><span class="line">            underLabel.li().</span><br><span class="line">            ...</span><br><span class="line">            _(QueueBlock.class)._()._();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;Application List 界面</span><br><span class="line">      ul._()._().</span><br><span class="line">      script().$type(&quot;text&#x2F;javascript&quot;).</span><br><span class="line">          _(&quot;$(&#39;#cs&#39;).hide();&quot;)._()._().</span><br><span class="line">      _(RMAppsBlock.class);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从 rootQueue 开始递归,Queue 检查自身有没有子队列 subQueues,若无则其本身为 LeafQueue,使用 LeafQueueInfoBlock#render()渲染叶子队列信息,使用 QueueUsersInfoBlock#render()渲染队列下的用户信息;若有子队列则其本身为ParentQueue,使用 QueueBlock#render()渲染,直至叶子队列<br>[QueuesBlock.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void render(Block html) &#123;</span><br><span class="line">      ArrayList&lt;CapacitySchedulerQueueInfo&gt; subQueues &#x3D;</span><br><span class="line">          (csqinfo.qinfo &#x3D;&#x3D; null) ? csqinfo.csinfo.getQueues().getQueueInfoList()</span><br><span class="line">              : csqinfo.qinfo.getQueues().getQueueInfoList();</span><br><span class="line">      UL&lt;Hamlet&gt; ul &#x3D; html.ul(&quot;#pq&quot;);</span><br><span class="line">      for (CapacitySchedulerQueueInfo info : subQueues) &#123;</span><br><span class="line">  	  ...</span><br><span class="line">          if (info.getQueues() &#x3D;&#x3D; null) &#123;</span><br><span class="line">          li.ul(&quot;#lq&quot;).li()._(LeafQueueInfoBlock.class)._()._();</span><br><span class="line">          li.ul(&quot;#lq&quot;).li()._(QueueUsersInfoBlock.class)._()._();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          li._(QueueBlock.class);</span><br><span class="line">        &#125;</span><br><span class="line">  	...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由于异常指标位于叶子队列信息中,所以暂且不看QueueUsersInfoBlock.java<br>[LeafQueueInfoBlock.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private String nodeLabel;</span><br><span class="line">final CapacitySchedulerLeafQueueInfo lqinfo;</span><br><span class="line">@Inject LeafQueueInfoBlock(ViewContext ctx, CSQInfo info) &#123;</span><br><span class="line">      super(ctx);</span><br><span class="line">      lqinfo &#x3D; (CapacitySchedulerLeafQueueInfo) info.qinfo;</span><br><span class="line">      nodeLabel &#x3D; info.label;</span><br><span class="line">    &#125;</span><br><span class="line">protected void render(Block html) &#123;</span><br><span class="line">      if (nodeLabel &#x3D;&#x3D; null) &#123;</span><br><span class="line">        renderLeafQueueInfoWithoutParition(html);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        renderLeafQueueInfoWithPartition(html);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">虽然按照 nodeLabel 做了分支,但是核心逻辑都是</span><br><span class="line">renderQueueCapacityInfo方法和renderCommonLeafQueueInfo方法,</span><br><span class="line">这两个方法分别展示不同方面的指标,和 Yarn UI 展示的指标相同 </span><br><span class="line"></span><br><span class="line">private void renderQueueCapacityInfo(final ResponseInfo ri) &#123;</span><br><span class="line">      ri.</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Used Capacity:&quot;, percent(lqinfo.getUsedCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Configured Capacity:&quot;, percent(lqinfo.getCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Configured Max Capacity:&quot;, percent(lqinfo.getMaxCapacity() &#x2F; 100)).</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Absolute Used Capacity:&quot;, percent(lqinfo.getAbsoluteUsedCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Absolute Configured Capacity:&quot;, percent(lqinfo.getAbsoluteCapacity() &#x2F; 100)).</span><br><span class="line">      _(&quot;Absolute Configured Max Capacity:&quot;, percent(lqinfo.getAbsoluteMaxCapacity() &#x2F; 100)).</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Used Resources:&quot;, lqinfo.getResourcesUsed().toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  private void renderCommonLeafQueueInfo(final ResponseInfo ri) &#123;</span><br><span class="line">      ri.</span><br><span class="line">      _(&quot;Num Schedulable Applications:&quot;, Integer.toString(lqinfo.getNumActiveApplications())).</span><br><span class="line">      _(&quot;Num Non-Schedulable Applications:&quot;, Integer.toString(lqinfo.getNumPendingApplications())).</span><br><span class="line">      &#x2F;&#x2F;异常指标</span><br><span class="line">      _(&quot;Num Containers:&quot;, Integer.toString(lqinfo.getNumContainers())).</span><br><span class="line">      _(&quot;Max Applications:&quot;, Integer.toString(lqinfo.getMaxApplications())).</span><br><span class="line">      _(&quot;Max Applications Per User:&quot;, Integer.toString(lqinfo.getMaxApplicationsPerUser())).</span><br><span class="line">      _(&quot;Max Application Master Resources:&quot;, lqinfo.getAMResourceLimit().toString()).</span><br><span class="line">      _(&quot;Used Application Master Resources:&quot;, lqinfo.getUsedAMResource().toString()).</span><br><span class="line">      _(&quot;Max Application Master Resources Per User:&quot;, lqinfo.getUserAMResourceLimit().toString()).</span><br><span class="line">      _(&quot;Configured Minimum User Limit Percent:&quot;, Integer.toString(lqinfo.getUserLimit()) + &quot;%&quot;).</span><br><span class="line">      _(&quot;Configured User Limit Factor:&quot;, StringUtils.format(</span><br><span class="line">          &quot;%.1f&quot;, lqinfo.getUserLimitFactor())).</span><br><span class="line">      _(&quot;Accessible Node Labels:&quot;, StringUtils.join(&quot;,&quot;, lqinfo.getNodeLabels())).</span><br><span class="line">      _(&quot;Preemption:&quot;, lqinfo.getPreemptionDisabled() ? &quot;disabled&quot; : &quot;enabled&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常指标计算方式"><a href="#异常指标计算方式" class="headerlink" title="异常指标计算方式"></a>异常指标计算方式</h3><p>注:集群没有使用 label 系统,所以下述的 nodeLabel 视为””即可</p>
<ul>
<li><p>Used Capacity</p>
<p>  [AbstractCSQueue.java]</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized float getUsedCapacity(final String nodeLabel) &#123;</span><br><span class="line">    &#x2F;&#x2F;集群所有资源 * 该队列的绝对容量百分比 &#x3D; 该队列的绝对容量 </span><br><span class="line">    Resource availableToQueue &#x3D;</span><br><span class="line">        Resources.multiply(</span><br><span class="line">            labelManager.getResourceByLabel(nodeLabel, this.clusterResource),</span><br><span class="line">            queueCapacities.getAbsoluteCapacity(nodeLabel));</span><br><span class="line">   &#x2F;&#x2F;使用 queueUsage 中记录的使用量除以该队列的绝对容量得到队列的 Used Capacity</span><br><span class="line">   &#x2F;&#x2F;queueUsage 的类型为 ResourceUsage</span><br><span class="line">    return</span><br><span class="line">        Resources.divide(resourceCalculator, this.clusterResource,</span><br><span class="line">            queueUsage.getUsed(nodeLabel), availableToQueue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Absolute Used Capacity</p>
<p>  算法和Used Capacity算法相似,只是分母不同,AbsoluteUsedCapacity 计算时分母是整个集群的资源  </p>
<p>  [AbstractCSQueue.java]</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized float getAbsoluteUsedCapacity(final String nodeLabel) &#123;</span><br><span class="line">   Resource labeledResources &#x3D;</span><br><span class="line">              labelManager.getResourceByLabel(nodeLabel, this.clusterResource);</span><br><span class="line">   return Resources.divide(resourceCalculator, this.clusterResource,</span><br><span class="line">       queueUsage.getUsed(nodeLabel), labeledResources);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Used Resource</p>
<p>  &ensp;&ensp;使用的是Queue 按 Label 记录的资源信息<br>  queueResourceUsage.getUsed(nodeLabel)  </p>
</li>
<li><p>Num Containers</p>
<p>  &ensp;&ensp;使用的 Queue 本身记录的信息<br>  numContainers = leafQueue.getNumContainers();  </p>
</li>
</ul>
<blockquote>
</blockquote>
<p>综上所述:<br>四个指标中,队列层面的Used Capacity 、Absolute Used Capacity 、Used Resource 均和 ResourceUsage维护 used 资源信息有关;numContainer 是 LeafQueue 自身维护的 container 数量.这些指标的变化逻辑在 AbstractCSQueue的 assignContainer()和 releaseContainer()中,即和 container 的释放/申请有关.
而在队列完全空闲的时候,四个指标为负,初步定位可能是 Container 重复释放或无效释放的原因.</p>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><h3 id="猜测重复释放"><a href="#猜测重复释放" class="headerlink" title="猜测重复释放"></a>猜测重复释放</h3><p>在已经出现指标异常的私有云上,对出现异常时日期前后的 resourcemanager 日志进行分析,检测其中出现”Assigned container”和”Released  container”字符串的数量,从日志层面对 container 的申请和释放次数做一个简单的判断.这种方式适用于集群作业周期性较强且没有跨天任务运行的情况.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &quot;Assigned container&quot; resourcemanager.log | sort | uniq -c</span><br><span class="line">egrep -o &quot;Released container&quot; resourcemanager.log | sort | uniq -c</span><br></pre></td></tr></table></figure>

<p>从结果上看,”Assigned container”和”Released container”字符串出现次数是一致的,可能不是重复释放的问题  </p>
<h3 id="猜测无效释放"><a href="#猜测无效释放" class="headerlink" title="猜测无效释放"></a>猜测无效释放</h3><p>对无效释放的猜想源自于重复释放和 rm 日志中的”Null container completed…”,猜测可能对于 nullContainer 处理有问题,修改了系统维护的信息, 导致了负值    </p>
<p>UI 的 kill 操作,命令行 yarn application –kill 和 RMApp 的正常结束都会释放 container,由 APP_ATTEMPT_REMOVED 事件触发,
回收 AppAttemp 持有的runningContainer 和 reservedContainer,核心逻辑在 CapacityScheduler#completedContainer()方法,但是其中对于 RMContainer 和 Application 都做了校验,不会修改维护信息;如果 RMContainer 对象内持有的 contianer 对象为空的话,会抛出 NullPointerException,也不会修改维护信息. 所以无效释放的猜测不合理,此处代码证明重复释放也不合理
[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void completedContainer(RMContainer rmContainer,</span><br><span class="line">      ContainerStatus containerStatus, RMContainerEventType event) &#123; </span><br><span class="line">    &#x2F;&#x2F;rmContaienr 空值校验  </span><br><span class="line">    if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">      LOG.info(&quot;Null container completed...&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">    FiCaSchedulerApp application &#x3D;</span><br><span class="line">        getCurrentAttemptForContainer(container.getId());</span><br><span class="line">    ApplicationId appId &#x3D;</span><br><span class="line">    &#x2F;&#x2F;如果 RMContainer 映射的 container 为空,则此处会 NullPointerException</span><br><span class="line">        container.getId().getApplicationAttemptId().getApplicationId();</span><br><span class="line">    &#x2F;&#x2F;application 空值校验</span><br><span class="line">    if (application &#x3D;&#x3D; null) &#123;</span><br><span class="line">      LOG.info(&quot;Container &quot; + container + &quot; of&quot; + &quot; unknown application &quot;</span><br><span class="line">          + appId + &quot; completed with event &quot; + event);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="movetoqueue"><a href="#movetoqueue" class="headerlink" title="movetoqueue"></a>movetoqueue</h3><p>重复释放和无效释放的猜测证否之后,只好再去仔细研究 系统指标异常前的几个运行的任务日志,对 application 的 attempt 和每个 contianer 状态机的状态和 触发事件按照时间线标注出来,对application 发生的所有事件还原出来,发现了其中一个 application 的以下信息  </p>
<blockquote>
<p>1.提交到 root.high 队列后,队列资源不足,在某些节点上为该 applicaiton reserve 资源,其他 application 调度时不会再该节点上分配资源<br>2.application 被从 high 队列移动了 low 队列<br>3.container 被移动队列时,源队列和目标队列的资源有变动,两个队列都会被 re-sort,以便优先在资源利用率最低的 queue 调度,所以有每个 container 的移动有四条日志:queueMoveOut 队列的信息,queueMoveOut 的父队列信息(有几个 parentQueue 就会有几条日志),queuMoveIn 队列信息,queueMoveIn 的父队列信息<br>4.在 move container 前后有一个 container: container_e08_1565789460020_5864_01_000002,在 high队列上分配了资源,被 move 到 low 队列后,containerCompleted 之后,释放资源到了 low 队列<br>5.<b>在 move container 前后有一个 container: container_e08_1565789460020_5864_01_000080,在 high 队列上保留了资源,move 操作没有影响到该 container,但是containerCompleted之后释放资源到了 low 队列</b>. </p>
</blockquote>
<p>日志如下  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INFO LeafQueue: assignedContainer application attempt&#x3D;appattempt_1565789460020_5864_000001 container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6:8041, NodeHttpAddress: hadoop6:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: null, ] queue&#x3D;high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:420864, vCores:20&gt;, usedCapacity&#x3D;1.4421053, absoluteUsedCapacity&#x3D;0.86526316, numApps&#x3D;3, numContainers&#x3D;20 clusterResource&#x3D;&lt;memory:486400, vCores:136&gt; type&#x3D;OFF_SWITCH  </span><br><span class="line">INFO RMContainerImpl: container_e08_1565789460020_5864_01_000080 Container Transitioned from NEW to RESERVED</span><br><span class="line">INFO LeafQueue: Reserved container  application&#x3D;application_1565789460020_5864 resource&#x3D;&lt;memory:11264, vCores:1&gt; queue&#x3D;high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:443392, vCores:22&gt;, usedCapacity&#x3D;1.5192982, absoluteUsedCapacity&#x3D;0.91157895, numApps&#x3D;3, numContainers&#x3D;22 usedCapacity&#x3D;1.5192982 absoluteUsedCapacity&#x3D;0.91157895 used&#x3D;&lt;memory:443392, vCores:22&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO ParentQueue: Re-sorting assigned queue: root.high stats: high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:454656, vCores:23&gt;, usedCapacity&#x3D;1.5578947, absoluteUsedCapacity&#x3D;0.93473685, numApps&#x3D;3, numContainers&#x3D;23</span><br><span class="line">....moving</span><br><span class="line">INFO LeafQueue: movedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6:8041, NodeHttpAddress: hadoop6:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: Token &#123; kind: ContainerToken, service:  &#125;, ] resource&#x3D;&lt;memory:11264, vCores:1&gt; queueMoveOut&#x3D;high: capacity&#x3D;0.6, absoluteCapacity&#x3D;0.6, usedResources&#x3D;&lt;memory:431104, vCores:20&gt;, usedCapacity&#x3D;1.477193, absoluteUsedCapacity&#x3D;0.88631576, numApps&#x3D;3, numContainers&#x3D;20 usedCapacity&#x3D;1.477193 absoluteUsedCapacity&#x3D;0.88631576 used&#x3D;&lt;memory:431104, vCores:20&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO ParentQueue: movedContainer queueMoveOut&#x3D;root usedCapacity&#x3D;0.9768421 absoluteUsedCapacity&#x3D;0.9768421 used&#x3D;&lt;memory:475136, vCores:24&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO LeafQueue: movedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6:8041, NodeHttpAddress: hadoop6:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: Token &#123; kind: ContainerToken, service: &#125;, ] resource&#x3D;&lt;memory:11264, vCores:1&gt; queueMoveIn&#x3D;low: capacity&#x3D;0.1, absoluteCapacity&#x3D;0.1, usedResources&#x3D;&lt;memory:-22528, vCores:-3&gt;, usedCapacity&#x3D;-0.4631579, absoluteUsedCapacity&#x3D;-0.04631579, numApps&#x3D;0, numContainers&#x3D;-3 usedCapacity&#x3D;-0.4631579 absoluteUsedCapacity&#x3D;-0.04631579 used&#x3D;&lt;memory:-22528, vCores:-3&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO ParentQueue: movedContainer queueMoveIn&#x3D;root usedCapacity&#x3D;1.0 absoluteUsedCapacity&#x3D;1.0 used&#x3D;&lt;memory:486400, vCores:25&gt; cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">....moved</span><br><span class="line">INFO CapacityScheduler: App: application_1565789460020_5864 successfully moved from high to: low</span><br><span class="line">INFO LeafQueue: completedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000080, NodeId: hadoop5:8041, NodeHttpAddress: hadoop5:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: null, ] queue&#x3D;low: capacity&#x3D;0.1, absoluteCapacity&#x3D;0.1, usedResources&#x3D;&lt;memory:0, vCores:-1&gt;, usedCapacity&#x3D;0.0, absoluteUsedCapacity&#x3D;0.0, numApps&#x3D;1, numContainers&#x3D;-1 cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br><span class="line">INFO LeafQueue: completedContainer container&#x3D;Container: [ContainerId: container_e08_1565789460020_5864_01_000002, NodeId: hadoop6.:8041, NodeHttpAddress: hadoop6.cn:8042, Resource: &lt;memory:11264, vCores:1&gt;, Priority: 1, Token: Token &#123; kind: ContainerToken, service: &#125;, ] queue&#x3D;low: capacity&#x3D;0.1, absoluteCapacity&#x3D;0.1, usedResources&#x3D;&lt;memory:-1024, vCores:-2&gt;, usedCapacity&#x3D;-0.021052632, absoluteUsedCapacity&#x3D;-0.002105263, numApps&#x3D;1, numContainers&#x3D;-2 cluster&#x3D;&lt;memory:486400, vCores:136&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>猜测:application 在移动队列后,对 reservedContainer 没有移动或维护信息不同步,导致了源队列的资源泄露给了目标队列,从而目标队列的 UsedCapacity 为负<br>复现方式<br>&ensp;&ensp;&ensp;&ensp;第一步:提交 application 到资源紧张的 Queue<br>&ensp;&ensp;&ensp;&ensp;第二步:待在 RM 的日志中看到”Trying to fulfill reservation for application ${APPLICATION_ID} on node …”和”Trying to schedule on node…, available:…” 表明 CapacityScheduler为该 ApplicationId 保留了资源,跳过在此 nm 上为其他 app 分配 container<br>&ensp;&ensp;&ensp;&ensp;第三步: 使用 yarn application -movetoqueue ${APPLICATION_ID} -queue ${TOQueue}<br>&ensp;&ensp;&ensp;&ensp;第四步: 待在 RM 日志中看到了”App:${APPLICATION_ID} successfully moved ${FROMQUEUE} to ${TOQUEUE}”后,使用 yarn application –kill ${APPLICATION_ID} 或等待 app 结束<br>&ensp;&ensp;&ensp;&ensp;第五步: 在 YarnUI上查看被移动的目标队列${TOQUEUE}的信息  </p>
</blockquote>
<p>注:<br>&ensp;&ensp;&ensp;&ensp;1.一定要在资源紧张的队列上提交 app,以触发调度系统的保留资源.在空闲队列上提交任务复现不了指标异常的问题<br>&ensp;&ensp;&ensp;&ensp;2.最好移动到一个完全空闲的队列上,否则即使复现了资源泄露,也不易看出来  </p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>以下代码出自于 hadoop 2.7.3版本<br>Yarn 是一个资源调度平台,集群内存资源和 cpu 资源被 Yarn 抽象为 Resource{memory,core},客户端对 Yarn 的资源请求和 Yarn 内部的资源调度都是以 Container 为基本单位的<br>当客户端向资源队列 Queue 提交 Application 时, 客户端申请的 AM 以及 AM 申请新的执行角色(e.g. spark 的 executor)都是在Container 中运行,那么对于 Yarn 调度的 Container,资源信息被多维聚合[app状态|container状态|container用途|用户|标签]统计维护:    </p>
<ul>
<li>Queue.包括直接申请的叶子队列及其所有的父队列    <ol>
<li>Queue(AbstractCSQueue)<br>&ensp;&ensp;主要指标是 container 数量;保存着 QueueMetrics 和 ResourceUsage(ByLabel) 的引用<br> a. ParentQueue<br>&ensp;&ensp;主要指标是运行的 application数量;保存着所有资源子队列的集合<br> b. LeafQueue 
&ensp;&ensp; 主要指标是每个用户提交 app 的数量和资源用途用量(ResourceUsageByUser);保存着队列 running 和 pending 的 app[attemp]信息               </li>
<li>QueueMetrics<br>&ensp;&ensp;保留着queue 的指标信息,包括[提交|运行|积压|完成|杀死|失败]app 数量、[分配|待分配|积压]的[container|内存|虚拟核]信息、活跃的[app|user]信息;保存着用户级别的 &lt;username,QueueMetrics&gt;映射  </li>
<li>ResourceUsage<br>&ensp;&ensp;保留着&lt;label,UsageByLabel&gt;信息,分为used、pending、amused、reserved 四类  </li>
</ol>
</li>
<li>Application(SchedulerApplicationAttempt). app 中维护着当前正在运行的 container,及 yarn 为其保留的 container 信息</li>
<li>NodeManager. container 所在的 NM 维护着自身运行的所有 container,并通过 RM 心跳汇报所有 container 状态机状态,触发 RM 对container 状态的更新或释放    </li>
</ul>
<blockquote>
</blockquote>
<p>综上:<br>&ensp;&ensp;&ensp;&ensp;1.指标异常与 container 申请释放有关,所以需要研究 <b>正常申请释放与应用移动队列</b> 对上述维护信息的影响<br>&ensp;&ensp;&ensp;&ensp;2.UI 展示的 numContainers 数据取自 AbstractCSQueue 维护 numContainer 成员变量;usedCapacity,absoluteUsedCapacity,usedResource 均取自AbstractCSQueue$ResourceUsage.used 成员变量.需要关注以上变量在资源申请释放过程中的变化    </p>
<h3 id="正常的资源分配和释放过程"><a href="#正常的资源分配和释放过程" class="headerlink" title="正常的资源分配和释放过程"></a>正常的资源分配和释放过程</h3><p>RM 的资源分配和资源释放都是被动触发,客户端提交 application 到 RMClientService,app 信息暂存在指定资源队列中,待 NM 向 RM 通过心跳汇报自身信息时 RM 将对该 NM 触发调度,在情况允许的情况下(e.g. 目标队列具有该 NM 的 access 权限,NM 剩余资源满足 app 中一个 ResourceRequest 申请的资源),将在该 NM 上划出 ResourceRequest 要求的资源,并同步 Queue/Application/NodeManager 维护的信息;当 container 完成退出之后,NodeManager 注意到 container 状态机变化,并将其信息附带在心跳中汇报给 RM,触发 Queue/Application/NodeManager 状态变化和信息同步<br>以下代码较为关注资源信息的维护同步,对于其他细节不再赘述    </p>
<h3 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h3><p><img src="/img/pictures/negative/yarn_node_update_pic.png" alt=""></p>
<p>NM 通过心跳触发 CapacityScheduler 调度,CS 首先按照 NM 上报的信息同步 RM 的信息,为新启动的 container 触发 LAUNCHED 事件,为结束的 container 触发FINISHED 事件;并试图在该节点上分配资源<br>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void handle(SchedulerEvent event) &#123;</span><br><span class="line">...</span><br><span class="line">case NODE_UPDATE:</span><br><span class="line">    &#123;</span><br><span class="line">      NodeUpdateSchedulerEvent nodeUpdatedEvent &#x3D; (NodeUpdateSchedulerEvent)event;</span><br><span class="line">      RMNode node &#x3D; nodeUpdatedEvent.getRMNode();</span><br><span class="line">      &#x2F;&#x2F;同步 RM 信息</span><br><span class="line">      nodeUpdate(node);</span><br><span class="line">      if (!scheduleAsynchronously) &#123;</span><br><span class="line">      &#x2F;&#x2F;试图在 nm 分配资源</span><br><span class="line">        allocateContainersToNode(getNode(node.getNodeID()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依据汇报心跳的 NodeManager 是否被保留了资源执行相应的逻辑<br>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void allocateContainersToNode(FiCaSchedulerNode node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    RMContainer reservedContainer &#x3D; node.getReservedContainer();</span><br><span class="line">    &#x2F;&#x2F;当前 node 被某 applocation 保留了</span><br><span class="line">    if (reservedContainer !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerApp reservedApplication &#x3D;</span><br><span class="line">          getCurrentAttemptForContainer(reservedContainer.getContainerId());</span><br><span class="line">      &#x2F;&#x2F; Try to fulfill the reservation</span><br><span class="line">      LOG.info(&quot;Trying to fulfill reservation for application &quot; + </span><br><span class="line">          reservedApplication.getApplicationId() + &quot; on node: &quot; + </span><br><span class="line">          node.getNodeID());</span><br><span class="line">      LeafQueue queue &#x3D; ((LeafQueue)reservedApplication.getQueue());</span><br><span class="line">      CSAssignment assignment &#x3D;</span><br><span class="line">          queue.assignContainers(</span><br><span class="line">              clusterResource,</span><br><span class="line">              node,</span><br><span class="line">              new ResourceLimits(labelManager.getResourceByLabel(</span><br><span class="line">                  RMNodeLabelsManager.NO_LABEL, clusterResource)));</span><br><span class="line">      ....</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;当前节点未被保留</span><br><span class="line">    if (node.getReservedContainer() &#x3D;&#x3D; null) &#123;</span><br><span class="line">     	...</span><br><span class="line">     	&#x2F;&#x2F;交由 root 队列代理分配.root 是资源队列树形结构的根节点,类型一定ParentQueue</span><br><span class="line">        root.assignContainers(</span><br><span class="line">            clusterResource,</span><br><span class="line">            node,</span><br><span class="line">            new ResourceLimits(labelManager.getResourceByLabel(</span><br><span class="line">                RMNodeLabelsManager.NO_LABEL, clusterResource)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      LOG.info(&quot;Skipping scheduling since node &quot; + node.getNodeID() + </span><br><span class="line">          &quot; is reserved by application &quot; + </span><br><span class="line">          node.getReservedContainer().getContainerId().getApplicationAttemptId()</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ParentQueue 将节点委派给子队列,试图分配资源<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public synchronized CSAssignment assignContainers(Resource clusterResource,</span><br><span class="line">     FiCaSchedulerNode node, ResourceLimits resourceLimits) &#123;</span><br><span class="line">   CSAssignment assignment &#x3D; </span><br><span class="line">       new CSAssignment(Resources.createResource(0, 0), NodeType.NODE_LOCAL);</span><br><span class="line">   Set&lt;String&gt; nodeLabels &#x3D; node.getLabels();</span><br><span class="line">   ...校验 queue 对 node 的 access 权限</span><br><span class="line">   while (canAssign(clusterResource, node)) &#123;</span><br><span class="line">     ...校验 queue 资源是否超限      </span><br><span class="line">     &#x2F;&#x2F; Schedule 递归交由子队列去分配</span><br><span class="line">     CSAssignment assignedToChild &#x3D; </span><br><span class="line">         assignContainersToChildQueues(clusterResource, node, resourceLimits);</span><br><span class="line">     assignment.setType(assignedToChild.getType());</span><br><span class="line">     &#x2F;&#x2F; Done if no child-queue assigned anything</span><br><span class="line">     &#x2F;&#x2F; 如果分配到了资源, assignedToChild 大于 Resource&lt;0,0&gt;</span><br><span class="line">     if (Resources.greaterThan(</span><br><span class="line">             resourceCalculator, clusterResource, </span><br><span class="line">             assignedToChild.getResource(), Resources.none())) &#123;</span><br><span class="line">             &#x2F;&#x2F;同步维护的信息</span><br><span class="line">       super.allocateResource(clusterResource, assignedToChild.getResource(),</span><br><span class="line">           nodeLabels);</span><br><span class="line">       Resources.addTo(assignment.getResource(), assignedToChild.getResource());</span><br><span class="line">       ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;     </span><br><span class="line">   return assignment;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>先看如果分配到资源的话 同步的信息:<br>1.按照 label 去更新 ResourceUsage 中维护的用户使用资源 used(incUsed 方法)<br>2.增加了该队列的 numContainer 数量<br>需要注意的是 <b>无论后续得到的是 allocated container 还是 reserved container,都增加了 numContainer的值,增加了用户 USED 类型的内存和虚拟核数量</b><br>[AbstractCSQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">synchronized void allocateResource(Resource clusterResource, </span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    &#x2F;&#x2F; Update usedResources by labels</span><br><span class="line">    if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.incUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.incUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++numContainers;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看对 queueUsage:ResourceUsage 做了什么操作<br>ResourceUsage 中维护了一个Map结构 usages,key 是标签类型,value 是 UsageByLabel;UsageByLabel 中只有一个数组 Resource[],数组中的每个值分别表征着 USED,PENDING,AMUSED,RESERVED 用途的 Resource 数量<br>[ResourceUsage.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &lt;labelName,UsageByLabel&gt;</span><br><span class="line">private Map&lt;String, UsageByLabel&gt; usages;</span><br><span class="line">public void incUsed(String label, Resource res) &#123;</span><br><span class="line">    _inc(label, ResourceType.USED, res);</span><br><span class="line"> &#125;</span><br><span class="line"> private void _inc(String label, ResourceType type, Resource res) &#123;</span><br><span class="line">     ...</span><br><span class="line">     UsageByLabel usage &#x3D; getAndAddIfMissing(label);</span><br><span class="line">     Resources.addTo(usage.resArr[type.idx], res);      </span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>UsageByLabel 使用一个 Resource[]数组来存储资源的用途和用量<br>[UsageByLabel.java]  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static class UsageByLabel &#123;</span><br><span class="line">  &#x2F;&#x2F; usage by label, contains all UsageType</span><br><span class="line">  private Resource[] resArr;</span><br><span class="line">  public UsageByLabel(String label) &#123;</span><br><span class="line">    resArr &#x3D; new Resource[ResourceType.values().length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; resArr.length; i++) &#123;</span><br><span class="line">      resArr[i] &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private enum ResourceType &#123;</span><br><span class="line">  USED(0), PENDING(1), AMUSED(2), RESERVED(3);</span><br><span class="line">  private int idx;</span><br><span class="line">  private ResourceType(int value) &#123;</span><br><span class="line">    this.idx &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到资源分配,root 队列深度优先遍历所有子队列,尝试在叶子队列上分配资源<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public synchronized CSAssignment assignContainers(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerNode node, ResourceLimits currentResourceLimits) &#123;</span><br><span class="line">	....</span><br><span class="line">    &#x2F;&#x2F; Check for reserved resources</span><br><span class="line">    RMContainer reservedContainer &#x3D; node.getReservedContainer();</span><br><span class="line">    if (reservedContainer !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerApp application &#x3D; </span><br><span class="line">          getApplication(reservedContainer.getApplicationAttemptId());</span><br><span class="line">      synchronized (application) &#123;</span><br><span class="line">        return assignReservedContainer(application, node, reservedContainer,</span><br><span class="line">            clusterResource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对目前活跃的 application,尝试在当前 NM 上分配资源</span><br><span class="line">    for (FiCaSchedulerApp application : activeApplications) &#123;</span><br><span class="line">    	....</span><br><span class="line">      synchronized (application) &#123;</span><br><span class="line">         ....        </span><br><span class="line">          &#x2F;&#x2F; Schedule in priority order</span><br><span class="line">        for (Priority priority : application.getPriorities()) &#123;</span><br><span class="line">          ResourceRequest anyRequest &#x3D;</span><br><span class="line">              application.getResourceRequest(priority, ResourceRequest.ANY);</span><br><span class="line">         if (null &#x3D;&#x3D; anyRequest) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">          ....校验性工作</span><br><span class="line">          &#x2F;&#x2F;校验通过,在此节点上分配资源</span><br><span class="line">          CSAssignment assignment &#x3D;  </span><br><span class="line">            assignContainersOnNode(clusterResource, node, application, priority, </span><br><span class="line">                null, currentResourceLimits);</span><br><span class="line">	.....</span><br><span class="line">          &#x2F;&#x2F; Did we schedule or reserve a container?</span><br><span class="line">          Resource assigned &#x3D; assignment.getResource();</span><br><span class="line">          if (Resources.greaterThan(</span><br><span class="line">              resourceCalculator, clusterResource, assigned, Resources.none())) &#123;</span><br><span class="line">            &#x2F;&#x2F;更新当前[叶子]队列的 numContainer,ResourceUsageByLabel和 ResourceUsageByUser.</span><br><span class="line">            &#x2F;&#x2F;比 ParentQueue.allocateResource 多出了一个用户层面的资源统计</span><br><span class="line">            allocateResource(clusterResource, application, assigned,</span><br><span class="line">                node.getLabels());</span><br><span class="line">            .....            </span><br><span class="line">            return assignment;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL_ASSIGNMENT;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先看LeafQueue#allocateResource 更新信息时更新的指标和内容
LeafQueue 和ParentQueue  一样,使用抽象父类AbstractCSQueue#allocateResource() 更新当前队列的 numContainer 和 标签层面的 ResourceUsage<br>然后使用 LeafQueue 中维护的Map&lt;String,User&gt;成员变量 users来维护用户标签层面的资源信息 
[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synchronized void allocateResource(Resource clusterResource,</span><br><span class="line">      SchedulerApplicationAttempt application, Resource resource,</span><br><span class="line">      Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;使用的是 AbstractCSQueue#allocateResource,和 ParentQueue更新的指标及内容相同:numContainer,ResourceUsageByLabel</span><br><span class="line">    super.allocateResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    &#x2F;&#x2F;更新用户层面的 ResourceUsage</span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.assignContainer(resource, nodeLabels);</span><br><span class="line">    Resources.subtractFrom(application.getHeadroom(), resource); &#x2F;&#x2F; headroom</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>User 类中有一个 ResourceUsage,维护着在用户层面 各标签的资源用途和用量<br>[User.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static class User &#123;</span><br><span class="line">    ResourceUsage userResourceUsage &#x3D; new ResourceUsage();</span><br><span class="line">    volatile Resource userResourceLimit &#x3D; Resource.newInstance(0, 0);</span><br><span class="line">    int pendingApplications &#x3D; 0;</span><br><span class="line">    int activeApplications &#x3D; 0;</span><br><span class="line">     public void assignContainer(Resource resource,</span><br><span class="line">        Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">        userResourceUsage.incUsed(resource);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (String label : nodeLabels) &#123;</span><br><span class="line">          userResourceUsage.incUsed(label, resource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上文 LeafQueue#assignContainers方法 遍历每个活跃的 application,尝试在当前 nodemanager 上分配资源,调用 assignContainersOnNode()方法进行下一步的分配逻辑,并增加 app 在本地化层面分配的 container 数量,此指标逻辑不在此讨论<br>按照本地性优先级,优先分配  NODE_LOCAL(本节点)&gt;RACK_LOCAL(本机架)&gt;OFF_SWITCH(跨机架)<br>YARN 的本地性不同于 MR/SPARK 的本地性,YARN的本地性性体现在 Client/AM申请 container 的时候可以指定 container 所在的节点,此处的 NODE_LOCAL、RACK_LOCAL 和 OFF_SWITCH 是相对于申请 container 时指定的节点而言;数据本地化计算其实更多的是靠计算框架配合,按照数据所处的位置优先分配给计算节点(e.g. RDD#getPreferredLocations)<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private CSAssignment assignContainersOnNode(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerNode node, FiCaSchedulerApp application, Priority priority,</span><br><span class="line">      RMContainer reservedContainer, ResourceLimits currentResoureLimits) &#123;</span><br><span class="line">    Resource assigned &#x3D; Resources.none();</span><br><span class="line">    NodeType requestType &#x3D; null;</span><br><span class="line">    MutableObject allocatedContainer &#x3D; new MutableObject();</span><br><span class="line">    &#x2F;&#x2F; Data-local</span><br><span class="line">    ResourceRequest nodeLocalResourceRequest &#x3D;</span><br><span class="line">        application.getResourceRequest(priority, node.getNodeName());</span><br><span class="line">    if (nodeLocalResourceRequest !&#x3D; null) &#123;</span><br><span class="line">      requestType &#x3D; NodeType.NODE_LOCAL;</span><br><span class="line">      assigned &#x3D;</span><br><span class="line">          assignNodeLocalContainers(clusterResource, nodeLocalResourceRequest, </span><br><span class="line">            node, application, priority, reservedContainer,</span><br><span class="line">            allocatedContainer, currentResoureLimits);</span><br><span class="line">      if (Resources.greaterThan(resourceCalculator, clusterResource,</span><br><span class="line">          assigned, Resources.none())) &#123;</span><br><span class="line">        &#x2F;&#x2F;update locality statistics</span><br><span class="line">        if (allocatedContainer.getValue() !&#x3D; null) &#123;</span><br><span class="line">          application.incNumAllocatedContainers(NodeType.NODE_LOCAL,</span><br><span class="line">            requestType);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CSAssignment(assigned, NodeType.NODE_LOCAL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Rack-local</span><br><span class="line">    ResourceRequest rackLocalResourceRequest &#x3D;</span><br><span class="line">        application.getResourceRequest(priority, node.getRackName());</span><br><span class="line">    if (rackLocalResourceRequest !&#x3D; null) &#123;</span><br><span class="line">      if (!rackLocalResourceRequest.getRelaxLocality()) &#123;</span><br><span class="line">        return SKIP_ASSIGNMENT;</span><br><span class="line">      &#125;</span><br><span class="line">      if (requestType !&#x3D; NodeType.NODE_LOCAL) &#123;</span><br><span class="line">        requestType &#x3D; NodeType.RACK_LOCAL;</span><br><span class="line">      &#125;</span><br><span class="line">      assigned &#x3D; </span><br><span class="line">          assignRackLocalContainers(clusterResource, rackLocalResourceRequest, </span><br><span class="line">            node, application, priority, reservedContainer,</span><br><span class="line">            allocatedContainer, currentResoureLimits);</span><br><span class="line">      if (Resources.greaterThan(resourceCalculator, clusterResource,</span><br><span class="line">          assigned, Resources.none())) &#123;</span><br><span class="line">        if (allocatedContainer.getValue() !&#x3D; null) &#123;</span><br><span class="line">          application.incNumAllocatedContainers(NodeType.RACK_LOCAL,</span><br><span class="line">            requestType);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CSAssignment(assigned, NodeType.RACK_LOCAL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Off-switch</span><br><span class="line">    ResourceRequest offSwitchResourceRequest &#x3D;</span><br><span class="line">        application.getResourceRequest(priority, ResourceRequest.ANY);</span><br><span class="line">    if (offSwitchResourceRequest !&#x3D; null) &#123;</span><br><span class="line">      if (!offSwitchResourceRequest.getRelaxLocality()) &#123;</span><br><span class="line">        return SKIP_ASSIGNMENT;</span><br><span class="line">      &#125;</span><br><span class="line">      if (requestType !&#x3D; NodeType.NODE_LOCAL</span><br><span class="line">          &amp;&amp; requestType !&#x3D; NodeType.RACK_LOCAL) &#123;</span><br><span class="line">        requestType &#x3D; NodeType.OFF_SWITCH;</span><br><span class="line">      &#125;</span><br><span class="line">      assigned &#x3D;</span><br><span class="line">          assignOffSwitchContainers(clusterResource, offSwitchResourceRequest,</span><br><span class="line">            node, application, priority, reservedContainer,</span><br><span class="line">            allocatedContainer, currentResoureLimits);</span><br><span class="line">      if (allocatedContainer.getValue() !&#x3D; null) &#123;</span><br><span class="line">        application.incNumAllocatedContainers(NodeType.OFF_SWITCH, requestType);</span><br><span class="line">      &#125;</span><br><span class="line">      return new CSAssignment(assigned, NodeType.OFF_SWITCH);</span><br><span class="line">    &#125;</span><br><span class="line">    return SKIP_ASSIGNMENT;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>LeafQueue#assignNodeLocalContainers,assignRackLocalContainers,assignOffSwitchContainers的核心逻辑被封装为一处,只是本地化类型 NodeType 不同<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private Resource assignContainer(Resource clusterResource, FiCaSchedulerNode node, </span><br><span class="line">      FiCaSchedulerApp application, Priority priority, </span><br><span class="line">      ResourceRequest request, NodeType type, RMContainer rmContainer,</span><br><span class="line">      MutableObject createdContainer, ResourceLimits currentResoureLimits) &#123;</span><br><span class="line">    ....    </span><br><span class="line">    Resource capability &#x3D; request.getCapability();</span><br><span class="line">    Resource available &#x3D; node.getAvailableResource();</span><br><span class="line">    Resource totalResource &#x3D; node.getTotalResource();</span><br><span class="line">    if (!Resources.lessThanOrEqual(resourceCalculator, clusterResource,</span><br><span class="line">        capability, totalResource)) &#123;</span><br><span class="line">      LOG.warn(&quot;Node : &quot; + node.getNodeID()</span><br><span class="line">          + &quot; does not have sufficient resource for request : &quot; + request</span><br><span class="line">          + &quot; node total capability : &quot; + node.getTotalResource());</span><br><span class="line">      return Resources.none();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Create the container if necessary</span><br><span class="line">    Container container &#x3D; </span><br><span class="line">        getContainer(rmContainer, application, node, capability, priority);</span><br><span class="line">  	...</span><br><span class="line">      boolean shouldAllocOrReserveNewContainer &#x3D; shouldAllocOrReserveNewContainer(</span><br><span class="line">        application, priority, capability);</span><br><span class="line">    &#x2F;&#x2F;依据 节点可用资源量与申请的资源量 做除法来判断节点剩余资源能否满足需求 </span><br><span class="line">    int availableContainers &#x3D; </span><br><span class="line">        resourceCalculator.computeAvailableContainers(available, capability);</span><br><span class="line">    boolean needToUnreserve &#x3D; Resources.greaterThan(resourceCalculator,clusterResource,</span><br><span class="line">        currentResoureLimits.getAmountNeededUnreserve(), Resources.none());</span><br><span class="line">	</span><br><span class="line">    if (availableContainers &gt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果节点上足够分配一个 container 则分配</span><br><span class="line">      ....</span><br><span class="line">      &#x2F;&#x2F;调用 application 和 nodemanager 的方法,触发这两处的信息同步</span><br><span class="line">      RMContainer allocatedContainer &#x3D; </span><br><span class="line">          application.allocate(type, node, priority, request, container);</span><br><span class="line">          </span><br><span class="line">      node.allocateContainer(allocatedContainer);</span><br><span class="line">      </span><br><span class="line">      createdContainer.setValue(allocatedContainer);</span><br><span class="line">      return container.getResource();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	....</span><br><span class="line">        &#x2F;&#x2F;节点上没有足够的资源满足需求,则为该 application 保留该节点的资源</span><br><span class="line">        reserve(application, priority, node, rmContainer, container);</span><br><span class="line">        return request.getCapability();</span><br><span class="line">      &#125;</span><br><span class="line">      return Resources.none();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上文有三处地方需要同步资源信息:reserve()方法,FiCaSchedulerApp#allocate,FiCaSchedulerNode#allocateContainer<br>先看FiCaSchedulerApp#allocate方法,在 application 层面修改了什么信息<br>[FiCaSchedulerApp.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,</span><br><span class="line">     Priority priority, ResourceRequest request, </span><br><span class="line">     Container container) &#123;</span><br><span class="line">    ....</span><br><span class="line">   &#x2F;&#x2F;将 container 封装成 RMContainer 的形式,记录在 application 的所有 container 集合 newlyAllocatedContainers 和 运行态(相对 reserved)的 container 集合 liveContainers 中  </span><br><span class="line">   RMContainer rmContainer &#x3D; new RMContainerImpl(container, this</span><br><span class="line">       .getApplicationAttemptId(), node.getNodeID(),</span><br><span class="line">       appSchedulingInfo.getUser(), this.rmContext);</span><br><span class="line">   newlyAllocatedContainers.add(rmContainer);</span><br><span class="line">   liveContainers.put(container.getId(), rmContainer);    </span><br><span class="line">   ....</span><br><span class="line">   &#x2F;&#x2F;更新 metrics 信息</span><br><span class="line">   List&lt;ResourceRequest&gt; resourceRequestList &#x3D; appSchedulingInfo.allocate(</span><br><span class="line">       type, node, priority, request, container);</span><br><span class="line">    &#x2F;&#x2F;当前 app 消费的资源量</span><br><span class="line">   Resources.addTo(currentConsumption, container.getResource());</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F;触发 RMContainer 状态机变化,container 可以准备运行时环境,下载依赖等</span><br><span class="line">   rmContainer.handle(</span><br><span class="line">       new RMContainerEvent(container.getId(), RMContainerEventType.START));</span><br><span class="line">   RMAuditLogger.logSuccess(getUser(), </span><br><span class="line">       AuditConstants.ALLOC_CONTAINER, &quot;SchedulerApp&quot;, </span><br><span class="line">       getApplicationId(), container.getId());</span><br><span class="line">   return rmContainer;</span><br></pre></td></tr></table></figure>
<p>AppSchedulingInfo#allocate 更新 QueueMetrics 信息<br>[AppSchedulingInfo.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">synchronized public List&lt;ResourceRequest&gt; allocate(NodeType type,</span><br><span class="line">      SchedulerNode node, Priority priority, ResourceRequest request,</span><br><span class="line">      Container container) &#123;</span><br><span class="line">    List&lt;ResourceRequest&gt; resourceRequests &#x3D; new ArrayList&lt;ResourceRequest&gt;();</span><br><span class="line">    &#x2F;&#x2F;本地化层面的统计信息</span><br><span class="line">    if (type &#x3D;&#x3D; NodeType.NODE_LOCAL) &#123;</span><br><span class="line">      allocateNodeLocal(node, priority, request, container, resourceRequests);</span><br><span class="line">    &#125; else if (type &#x3D;&#x3D; NodeType.RACK_LOCAL) &#123;</span><br><span class="line">      allocateRackLocal(node, priority, request, container, resourceRequests);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      allocateOffSwitch(node, priority, request, container, resourceRequests);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueMetrics metrics &#x3D; queue.getMetrics();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;对QueueMetrics 做已经分配的资源的统计</span><br><span class="line">    metrics.allocateResources(user, 1, request.getCapability(), true);</span><br><span class="line">    metrics.incrNodeTypeAggregations(user, type);</span><br><span class="line">    return resourceRequests;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>QueueMetrics#allocateResource 对 userMetrics 做判断;对 parent 也做了判断 如果parent 非空那么会递归更新 parent 的信息,对userMetrics 和 parent 执行的方法都是 QueueMetrics#allocateResources,更新的指标一样:增加 allocate 的 container 数量,内存量,虚拟核数量<br>[QueueMetrics.java] </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void allocateResources(String user, int containers, Resource res,</span><br><span class="line">      boolean decrPending) &#123;</span><br><span class="line">    allocatedContainers.incr(containers);</span><br><span class="line">    aggregateContainersAllocated.incr(containers);</span><br><span class="line">    allocatedMB.incr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.incr(res.getVirtualCores() * containers);</span><br><span class="line">    if (decrPending) &#123;</span><br><span class="line">      _decrPendingResources(containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>FiCaSchedulerNode#allocateContainer, NodeManager 同步 allocate 信息 
[FiCaSchedulerNode.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void allocateContainer(RMContainer rmContainer) &#123;</span><br><span class="line">    Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">     &#x2F;&#x2F;减少当前 nm 的可用资源,增加当前 nm 的已分配资源</span><br><span class="line">    deductAvailableResource(container.getResource());</span><br><span class="line">    &#x2F;&#x2F;增加自身维护的 numContainer 数量,不同于 AbstractCSQueue.numContainers,维护Queue维度和 NodeManager 维度的 container 数量</span><br><span class="line">    ++numContainers;</span><br><span class="line">    &#x2F;&#x2F;启动的 container 列表</span><br><span class="line">    launchedContainers.put(container.getId(), rmContainer);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void deductAvailableResource(Resource resource) &#123;</span><br><span class="line">    Resources.subtractFrom(availableResource, resource);</span><br><span class="line">    Resources.addTo(usedResource, resource);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果在节点上 reserve 了资源,同步的信息和 allocate 的方式相似,会更新 QueueMetrics 对 reserved[containr|memory|core]的信息,更新application reservedContainer 及 currentReservationMemroy 信息,更新 NodeManager 当前 reservedContainer 信息<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void reserve(FiCaSchedulerApp application, Priority priority, </span><br><span class="line">      FiCaSchedulerNode node, RMContainer rmContainer, Container container) &#123;</span><br><span class="line">    &#x2F;&#x2F;传入的 rmContainer 为 null</span><br><span class="line">    if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">      getMetrics().reserveResource(</span><br><span class="line">          application.getUser(), container.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Inform the application </span><br><span class="line">    rmContainer &#x3D; application.reserve(node, priority, rmContainer, container);</span><br><span class="line">    &#x2F;&#x2F; Update the node</span><br><span class="line">    node.reserveResource(application, priority, rmContainer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>QueueMetrics#reserveResource在下方有一个对 parent 的判断,递归调用依次更新 ParentQueue 的信息;有一个对 userMetrics 的判断,对 QueueMetrics 中维护的 users:Map[String, QueueMetrics] 同步用户层面的统计信息,执行的方法都是当前方法QueueMetrics#reserveResource(),同步reserved 资源信息:增加 reserved container 数量,内存量,虚拟核数量  </p>
<p>[QueueMetrics.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void reserveResource(String user, Resource res) &#123;</span><br><span class="line">    reservedContainers.incr();</span><br><span class="line">    reservedMB.incr(res.getMemory());</span><br><span class="line">    reservedVCores.incr(res.getVirtualCores());</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>application 同步 reserved container 信息<br>[SchedulerApplicationAttempt.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public synchronized RMContainer reserve(SchedulerNode node, Priority priority,</span><br><span class="line">     RMContainer rmContainer, Container container) &#123;</span><br><span class="line">    &#x2F;&#x2F;上游传入的 rmContainer 为 null</span><br><span class="line">   if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">     rmContainer &#x3D; </span><br><span class="line">         new RMContainerImpl(container, getApplicationAttemptId(), </span><br><span class="line">             node.getNodeID(), appSchedulingInfo.getUser(), rmContext);</span><br><span class="line">     &#x2F;&#x2F;增加当前 application 保留的资源信息</span><br><span class="line">     Resources.addTo(currentReservation, container.getResource());</span><br><span class="line">     resetReReservations(priority);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; Note down the re-reservation</span><br><span class="line">     addReReservation(priority);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;在 container 信息中设置了绑定节点的信息....</span><br><span class="line">   rmContainer.handle(new RMContainerReservedEvent(container.getId(), </span><br><span class="line">       container.getResource(), node.getNodeID(), priority));</span><br><span class="line">       &#x2F;&#x2F;加入到维护的 reservedContainer 信息中</span><br><span class="line">   Map&lt;NodeId, RMContainer&gt; reservedContainers &#x3D; </span><br><span class="line">       this.reservedContainers.get(priority);</span><br><span class="line">   if (reservedContainers &#x3D;&#x3D; null) &#123;</span><br><span class="line">     reservedContainers &#x3D; new HashMap&lt;NodeId, RMContainer&gt;();</span><br><span class="line">     this.reservedContainers.put(priority, reservedContainers);</span><br><span class="line">   &#125;</span><br><span class="line">   reservedContainers.put(node.getNodeID(), rmContainer);</span><br><span class="line">   return rmContainer;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>FicaSchedulerNode#reserveResource(),NodeManager 同步 reserved container 信息<br>[FicaSchedulerNode.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void reserveResource(</span><br><span class="line">      SchedulerApplicationAttempt application, Priority priority,</span><br><span class="line">      RMContainer container) &#123;</span><br><span class="line">    &#x2F;&#x2F; Check if it&#39;s already reserved</span><br><span class="line">    RMContainer reservedContainer &#x3D; getReservedContainer();</span><br><span class="line">    ....空值校验性,重复保留校验等操作</span><br><span class="line">    &#x2F;&#x2F;设置当前节点保留的 container 为传入值</span><br><span class="line">    setReservedContainer(container);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>综上:<br>        CS 调度器在 NM 上为 APP 分配 container 时,会同步 [Parent | Leaf] Queue/APP/NM 三个位置维护的信息<br>    1.分配时,无论从叶子队列得到 allocated 或 reserved 类型的 container, 其 <b>ParentQueue</b>都会维护:<br>&ensp;&ensp;&ensp;&ensp;ParentQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp;ParentQueue <b>标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>    2.分配时,无论从叶子队列得到 allocated 或 reserved 类型的 container, <b>LeafQueue</b> 本身都会维护:<br>&ensp;&ensp;&ensp;&ensp; LeafQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp; LeafQueue 维护的<b>标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>&ensp;&ensp;&ensp;&ensp; LeafQueue 维护的<b>用户标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>    3.在节点上申请资源时,按照节点剩余可用资源和资源需求量做除法,若满足需求则分配为 allocatedContainer,不满足则分配 reservedContainer<br>    4.若在节点上分配 allocatedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp; Application 方面:newlyAllocatedContainers和 livingContainers 列表,app 已占用资源量<br>&ensp;&ensp;&ensp;&ensp; NodeManager 方面:numContainer 数量,NM 可用资源量,NM 已用资源量,NM 启动的 container 列表<br>&ensp;&ensp;&ensp;&ensp; QueueMetrics 方面:LeafQueue 及所有 ParentQueue<b>自身QueueMetrics</b>的allocated [containerNum | MB | core]信息;LeafQueue 及其所有 ParentQueue 在<b>用户维度 QueueMetrics</b> 的 allocated [containerNum | MB | cores]信息<br>    5.若在节点上分配 reservedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp;Application 方面:reservedContainers 列表,app 已保留资源量<br>&ensp;&ensp;&ensp;&ensp;NodeManager 方面:设置 NM 保留的 container 为本次的 reservedContainer<br>&ensp;&ensp;&ensp;&ensp;QueueMetrics 方面:LeafQueue 及所有 ParentQueue<b>自身 QueueMetrics</b>的 reserved [containerNum | MB | core]信息;LeafQueue 及其所有 ParentQueue 在<b>用户维度QueueMetrics</b> 的 reserved [containerNum | MB | core ]信息  </p>
</blockquote>
<h3 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h3><p>以客户端在命令行执行 “yarn application –kill ${APPLICATION_ID}”为例<br>RM 中响应请求 方法调用栈为:<br>-&gt;ClientRMService#forceKillApplication<br>&ensp;&ensp;-&gt;RMAppImpl$KillAttemptTransition#transition<br>&ensp;&ensp;&ensp;&ensp;-&gt;RMAppAttemptImpl$BaseFinalTransition#transition<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-&gt;CapacityScheduler#handle()   </p>
<p>application 结束时,主要做了三件事情,  </p>
<ol>
<li>Container: 释放 APP 持有的<b> living,reserved </b> container  </li>
<li>Application(QueueMetrcis): 清理 LeafQueue 及其 ParentQueue 在 <b>APP</b> 层面的统计(e.g. appRunnings);清理 LeafQueue 在<b>用户APP</b> 层面的统计  </li>
<li>AM(ResourceUsage): 释放 LeafQueue 及其 ParentQueue 在 <b>AM</b> 层面的资源用量;  释放 LeafQueue 在<b>用户AM</b> 层面的统计(AMUSED)  </li>
</ol>
<p>由于复现指标异常成功后,发现移动到目标队列后,目标队列增加的资源总量是 spark.executor.memory 的整数倍(executor-mem 11G,driver-memory 2G),所以对上述的第二点和第三点不多分析,主要关注 <b>非 AM 的container</b> 的释放,livingContainers 和 reservedContainer 的释放代码是同一个,仅仅是释放 container 的文字性说明(原文: diagnostics 意为诊断)不同<br>[CapactiyScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public void handle(SchedulerEvent event) &#123;</span><br><span class="line">....</span><br><span class="line"> case APP_ATTEMPT_REMOVED:</span><br><span class="line">    &#123;</span><br><span class="line">      AppAttemptRemovedSchedulerEvent appAttemptRemovedEvent &#x3D;</span><br><span class="line">          (AppAttemptRemovedSchedulerEvent) event;</span><br><span class="line">      doneApplicationAttempt(appAttemptRemovedEvent.getApplicationAttemptID(),</span><br><span class="line">        appAttemptRemovedEvent.getFinalAttemptState(),</span><br><span class="line">        appAttemptRemovedEvent.getKeepContainersAcrossAppAttempts());</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">    ....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private synchronized void doneApplicationAttempt(</span><br><span class="line">      ApplicationAttemptId applicationAttemptId,</span><br><span class="line">      RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers) &#123;</span><br><span class="line">    </span><br><span class="line">    FiCaSchedulerApp attempt &#x3D; getApplicationAttempt(applicationAttemptId);</span><br><span class="line">    SchedulerApplication&lt;FiCaSchedulerApp&gt; application &#x3D;</span><br><span class="line">        applications.get(applicationAttemptId.getApplicationId());</span><br><span class="line">        ....</span><br><span class="line">    &#x2F;&#x2F;从 app 维护的 livingContainer 列表中,释放掉 allocated acquired running 状态的 container</span><br><span class="line">    for (RMContainer rmContainer : attempt.getLiveContainers()) &#123;</span><br><span class="line">    &#x2F;&#x2F;在 kill 时keepContainer 为 false;在 failed 时,keepContainer 按场景可为 true</span><br><span class="line">      if (keepContainers</span><br><span class="line">          &amp;&amp; rmContainer.getState().equals(RMContainerState.RUNNING)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;1.释放 container</span><br><span class="line">      completedContainer(</span><br><span class="line">        rmContainer,</span><br><span class="line">        SchedulerUtils.createAbnormalContainerStatus(</span><br><span class="line">        &#x2F;&#x2F;COMPLETED_APPLICATION:Container of a completed application</span><br><span class="line">          rmContainer.getContainerId(), SchedulerUtils.COMPLETED_APPLICATION),</span><br><span class="line">        RMContainerEventType.KILL);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;从 app 维护的 reservedContainer 列表中,释放掉 reserved 状态的 container</span><br><span class="line">    for (RMContainer rmContainer : attempt.getReservedContainers()) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.释放 container</span><br><span class="line">      completedContainer(</span><br><span class="line">        rmContainer,</span><br><span class="line">        SchedulerUtils.createAbnormalContainerStatus(</span><br><span class="line">          rmContainer.getContainerId(), &quot;Application Complete&quot;),</span><br><span class="line">        RMContainerEventType.KILL);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2. 清理 pending 的 resourceRequest,并同步 [LeafQueue | ParentQueue] [本身 | 用户]维度的 QueueMetrics appRunnings | appPendings </span><br><span class="line">    attempt.stop(rmAppAttemptFinalState);</span><br><span class="line">    String queueName &#x3D; attempt.getQueue().getQueueName();</span><br><span class="line">    CSQueue queue &#x3D; queues.get(queueName);</span><br><span class="line">    if (!(queue instanceof LeafQueue)) &#123;</span><br><span class="line">      LOG.error(&quot;Cannot finish application &quot; + &quot;from non-leaf queue: &quot;</span><br><span class="line">          + queueName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;3. 同步 [LeafQueue | ParentQueue] [本身 | 用户]维度 QueueUsage 的 AMUSED 指标</span><br><span class="line">      queue.finishApplicationAttempt(attempt, queue.getQueueName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>CapacityScheduler#completedContainer主要做了一些校验,避免无效释放<br>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> protected synchronized void completedContainer(RMContainer rmContainer,</span><br><span class="line">    ContainerStatus containerStatus, RMContainerEventType event) &#123;</span><br><span class="line">  if (rmContainer &#x3D;&#x3D; null) &#123;</span><br><span class="line">    LOG.info(&quot;Null container completed...&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">  FiCaSchedulerApp application &#x3D;</span><br><span class="line">      getCurrentAttemptForContainer(container.getId());</span><br><span class="line">  ApplicationId appId &#x3D;</span><br><span class="line">      container.getId().getApplicationAttemptId().getApplicationId();</span><br><span class="line">  if (application &#x3D;&#x3D; null) &#123;</span><br><span class="line">    LOG.info(&quot;Container &quot; + container + &quot; of&quot; + &quot; unknown application &quot;</span><br><span class="line">        + appId + &quot; completed with event &quot; + event);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F;container 所在的 NM视图</span><br><span class="line">  FiCaSchedulerNode node &#x3D; getNode(container.getNodeId());</span><br><span class="line">   &#x2F;&#x2F;代理 container 的 LeafQueue</span><br><span class="line">  LeafQueue queue &#x3D; (LeafQueue)application.getQueue();</span><br><span class="line">  queue.completedContainer(clusterResource, application, node, </span><br><span class="line">      rmContainer, containerStatus, event, null, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先按照 RMContainer 状态机状态判断后续将当前 container 按照 reservedContainer处理或者 allocatedContainer 处理<br>然后若释放 container 成功,则同步 用户和标签维度 QueueUsage的 USED 指标,减少 Queue 运行的 container 数量<br>最后若当前 Queue 非 rootQueue,则递归同步当前 Queue 的所有 ParentQueue做上述处理<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void completedContainer(Resource clusterResource, </span><br><span class="line">      FiCaSchedulerApp application, FiCaSchedulerNode node, RMContainer rmContainer, </span><br><span class="line">      ContainerStatus containerStatus, RMContainerEventType event, CSQueue childQueue,</span><br><span class="line">      boolean sortQueues) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      boolean removed &#x3D; false;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">	&#x2F;&#x2F; 1. 若 contaienr 状态机为 reserved 状态,在节点上解除 reserve</span><br><span class="line">        if (rmContainer.getState() &#x3D;&#x3D; RMContainerState.RESERVED) &#123;</span><br><span class="line">          removed &#x3D; unreserve(application, rmContainer.getReservedPriority(),</span><br><span class="line">              node, rmContainer);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 2.若 container 状态机不为 reserved 状态,在节点上解除 allocate,并使 NM 释放 container</span><br><span class="line">          removed &#x3D;</span><br><span class="line">            application.containerCompleted(rmContainer, containerStatus, event);</span><br><span class="line">          node.releaseContainer(container);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;3.释放 同步 QueueUsage</span><br><span class="line">        if (removed) &#123;</span><br><span class="line">          releaseResource(clusterResource, application,</span><br><span class="line">              container.getResource(), node.getLabels());</span><br><span class="line">          LOG.info(&quot;completedContainer&quot; +</span><br><span class="line">              &quot; container&#x3D;&quot; + container +</span><br><span class="line">              &quot; queue&#x3D;&quot; + this +</span><br><span class="line">              &quot; cluster&#x3D;&quot; + clusterResource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;4.递归执行 Parent的释放逻辑</span><br><span class="line">      if (removed) &#123;</span><br><span class="line">        getParent().completedContainer(clusterResource, application, node,</span><br><span class="line">          rmContainer, null, event, this, sortQueues);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先看第 4 处对 ParentQueue 的处理<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void completedContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, FiCaSchedulerNode node, </span><br><span class="line">      RMContainer rmContainer, ContainerStatus containerStatus, </span><br><span class="line">      RMContainerEventType event, CSQueue completedChildQueue,</span><br><span class="line">      boolean sortQueues) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">      &#x2F;&#x2F;使用 AbstractCSQueue 中releaseResource方法</span><br><span class="line">        super.releaseResource(clusterResource, rmContainer.getContainer()</span><br><span class="line">            .getResource(), node.getLabels());</span><br><span class="line">	...</span><br><span class="line">        &#x2F;&#x2F;resort sub-queue</span><br><span class="line">     	....</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Inform the parent</span><br><span class="line">      if (parent !&#x3D; null) &#123;</span><br><span class="line"> 	&#x2F;&#x2F;递归 ParentQueue#completedContainer 方法</span><br><span class="line">        parent.completedContainer(clusterResource, application, </span><br><span class="line">            node, rmContainer, null, event, this, sortQueues);</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ParentQueue 在 container 释放时,无论是 allocatedContainer 还是 reservedContainer,都更新: 
1.按标签更新 QueueUsage 中 USED 用途的资源量<br>2.ParentQueue 中运行 container 的数量 
[AbstractCSQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;1.QueueUsageByLabel</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">        &#x2F;&#x2F;2.减少当前 Queue 的 container 的数量</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看第 3 处对 LeafQueue 的处理, 需要注意的是:无论 container 是 allocatedContainer 还是 reversedContainer 在此处都是作为ResourceUsage中 <b>USED</b> 类型的资源来减少的(虽然 ResourceType 枚举中有 RESERVED 类型),且 numContainer 都减少了 1个单位<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">synchronized void releaseResource(Resource clusterResource, </span><br><span class="line">      FiCaSchedulerApp application, Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.同步当前队列在 标签维度 ResourceUsage 中 USED 类型的资源,并减少 Queue 中 numContainer</span><br><span class="line">    super.releaseResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    &#x2F;&#x2F;2.同步 app 所属用户在标签维度上的度量信息  </span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.releaseContainer(resource, nodeLabels);</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>[AbstractCSQueue.java]  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">     &#x2F;&#x2F;1.同步 label 层面的 QueueUsage 的资源量;无论 reservedContainer 还是 allocatedContainer 都是使用 #decUsed(resource)</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">      &#x2F;&#x2F;2.减少当前队列启动的 container 数量.无论 reservedContainer 还是 allocatedContainer  </span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>LeafQueue 中维护了一个 users:Map[String,User]以保存当前各 user 在 USED,PENDING,AMUSED,RESERVED 用途使用资源的度量<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void releaseContainer(Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      &#x2F;&#x2F;还是 decUsed(resource),无论 reservedContainer 还是 allocatedContainer</span><br><span class="line">        userResourceUsage.decUsed(resource);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (String label : nodeLabels) &#123;</span><br><span class="line">          userResourceUsage.decUsed(label, resource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在回到LeafQueue#completedContainer方法,按照 RMContainer状态机状态来区分 reservedContainer 还是 allocatedContainer 做处理<br>先看对 allocated 的处理逻辑<br>[FicaSchedulerApp.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">synchronized public boolean containerCompleted(RMContainer rmContainer,</span><br><span class="line">      ContainerStatus containerStatus, RMContainerEventType event) &#123;</span><br><span class="line">    &#x2F;&#x2F;维护相应的引用列表</span><br><span class="line">    if (null &#x3D;&#x3D; liveContainers.remove(rmContainer.getContainerId())) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    newlyAllocatedContainers.remove(rmContainer);</span><br><span class="line">    Container container &#x3D; rmContainer.getContainer();</span><br><span class="line">    ContainerId containerId &#x3D; container.getId();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.RM 端准备 container 的 结束和清理等任务,待 NM 心跳通过 NodeHeartbeatResponse 交于 NM 做清理</span><br><span class="line">    rmContainer.handle(</span><br><span class="line">        new RMContainerFinishedEvent(</span><br><span class="line">            containerId,</span><br><span class="line">            containerStatus, </span><br><span class="line">            event)</span><br><span class="line">        );</span><br><span class="line">    ... </span><br><span class="line">    &#x2F;&#x2F;2.同步 QueueMetrics</span><br><span class="line">    Resource containerResource &#x3D; rmContainer.getContainer().getResource();</span><br><span class="line">    queue.getMetrics().releaseResources(getUser(), 1, containerResource);</span><br><span class="line">    &#x2F;&#x2F;3.减少当前 app 消费的资源</span><br><span class="line">    Resources.subtractFrom(currentConsumption, containerResource);</span><br><span class="line">    ....</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>主要看第2步 释放 contaienr 同步 QueueMetrics 的指标和内容,<br>1.同步 QueueMetrics 及其 ParentQueue QueueMetrics 的指标: allocate [containerNum | MB | core]<br>2.同步 QueueMetrics 及其 ParentQueue QueueMetrics 用户维度的 QueueMetrics 指标: allocate [containerNum | MB | core]<br>[QueueMetrics.java] </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void releaseResources(String user, int containers, Resource res) &#123;</span><br><span class="line">    &#x2F;&#x2F;当前资源队列指标</span><br><span class="line">    allocatedContainers.decr(containers);</span><br><span class="line">    aggregateContainersReleased.incr(containers);</span><br><span class="line">    allocatedMB.decr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.decr(res.getVirtualCores() * containers);</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    &#x2F;&#x2F;资源队列中用户指标</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;递归 父资源队列</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看释放allocatedContainer 过程中,NM 对该 container 的处理<br>1.删掉 launchedContainer 对该 container 的引用<br>2.增加该节点的可用资源,减少已经资源,减少启动的 numContainer 指标<br>[SchedulerNode.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void releaseContainer(Container container) &#123;</span><br><span class="line">    ..</span><br><span class="line">    &#x2F;&#x2F;1.删除引用</span><br><span class="line">    if (null !&#x3D; launchedContainers.remove(container.getId())) &#123;</span><br><span class="line">     &#x2F;&#x2F;2.指标维护</span><br><span class="line">      updateResource(container);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;Released container &quot; + container.getId() + &quot; of capacity &quot;</span><br><span class="line">        + container.getResource() + &quot; on host &quot; + rmNode.getNodeAddress()</span><br><span class="line">        + &quot;, which currently has &quot; + numContainers + &quot; containers, &quot;</span><br><span class="line">        + getUsedResource() + &quot; used and &quot; + getAvailableResource()</span><br><span class="line">        + &quot; available&quot; + &quot;, release resources&#x3D;&quot; + true);</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void updateResource(Container container) &#123;</span><br><span class="line">    addAvailableResource(container.getResource());</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br><span class="line">  private synchronized void addAvailableResource(Resource resource) &#123;</span><br><span class="line">     ...</span><br><span class="line">    Resources.addTo(availableResource, resource);</span><br><span class="line">    Resources.subtractFrom(usedResource, resource);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>释放 reservedContainer,对 reversedContainer 的处理<br>1.application 方面:删除对 reservedContainer 的引用,减少 currentReservation 资源数<br>2.nodemanager方面: 设置当前 nm 的reservedContainer 为 null
3.QueueMetrics 方面: 同步[ParentQueue | LeafQueue] [本身 | 用户]维度的指标 reserved [containerNum | MB | core]<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private boolean unreserve(FiCaSchedulerApp application, Priority priority,</span><br><span class="line">      FiCaSchedulerNode node, RMContainer rmContainer) &#123;</span><br><span class="line">      &#x2F;&#x2F;1.application: unreserve</span><br><span class="line">    if (application.unreserve(node, priority)) &#123;</span><br><span class="line">     &#x2F;&#x2F;2. nodemanager: unreserveResource</span><br><span class="line">      node.unreserveResource(application);</span><br><span class="line">     &#x2F;&#x2F;3.QueueMetrics</span><br><span class="line">      getMetrics().unreserveResource(application.getUser(),</span><br><span class="line">          rmContainer.getContainer().getResource());</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>application 和 nodemanager 层面的逻辑比较简单,且看 QueueMetrics 方面的同步<br>[QueueMetrics.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void unreserveResource(String user, Resource res) &#123;</span><br><span class="line">  &#x2F;&#x2F;当前资源队列 QueueMetrics的 reserved [container | MB | core] 指标</span><br><span class="line">    reservedContainers.decr();</span><br><span class="line">    reservedMB.decr(res.getMemory());</span><br><span class="line">    reservedVCores.decr(res.getVirtualCores());</span><br><span class="line">    &#x2F;&#x2F;当前资源队列 在用户维度的 reserved [container | MB | core] 指标</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;父资源队列在 其本身和用户维度的 reserved [container | MB | core] 指标</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>综上:<br>CS 调度器在为 APP 释放container 时,会同步 [Parent | Leaf]Queue/APP/NM 三个位置维护的信息  </p>
<ol>
<li>释放时,无论是释放 allocated 或 reserved 类型的 container,其 <b>ParentQueue</b> 都会维护:
&ensp;&ensp;&ensp;&ensp;ParentQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp;ParentQueue 维护的<b>标签维度</b>的QueueUsage 中 USED 用途的资源量  </li>
<li>释放时,无论是释放 allocated 或 reserved 类型的 container,其 <b>LeafQueue</b> 都会维护:<br>&ensp;&ensp;&ensp;&ensp;LeafQueue 维护的 numContainer<br>&ensp;&ensp;&ensp;&ensp;LeafQueue 维护的<b>标签维度</b>的 QueueUsage 中 USED 用途的资源量<br>&ensp;&ensp;&ensp;&ensp;LeafQueue 维护的<b>用户标签维度</b>的 QueueUsage 中 USED 用途的资源量  </li>
<li>释放 container 时,按照该 container 的状态机状态做细分,分为 reservedContainer 和 allocatedContainer 两类做处理  </li>
<li>若在节点上释放 allocatedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp;Application 方面:newlyAllocatedContainers 和 reservedContainers 列表,app已占用资源量<br>&ensp;&ensp;&ensp;&ensp;NodeManager方面:numContainer数量,NM 可用资源量,NM 已用资源量,NM 启动的 container 列表<br>&ensp;&ensp;&ensp;&ensp;QueueMetrics 方面:LeafQueue 和所有 ParentQueue <b>自身 QueueMetrics</b> 的 reserved [containerNum | MB | core]信息;LeafQueue 和所有 ParentQueue 在<b>用户维度 QueueMetrics </b> 的  reserved [containerNum | MB | core]信息  </li>
<li>若在节点上释放 reservedContainer,则维护:<br>&ensp;&ensp;&ensp;&ensp;Application 方面:reservedContainers 列表,app 已保留资源量<br>&ensp;&ensp;&ensp;&ensp; NodeManager 方面:设置 NM 保留的 container 为 null<br>&ensp;&ensp;&ensp;&ensp; QueueMetrics 方面:LeafQueue 及所有 ParentQueue<b>自身 QueueMetrics</b>的 reserved [containerNum | MB | core]信息;LeafQueue 及其所有 ParentQueue 在<b>用户维度QueueMetrics</b> 的 reserved [containerNum | MB | core ]信息  </li>
</ol>
<p>Container 释放过程和申请过程 对于 Queue/Application/NM三个位置维护的 Queue/QueueUsageByLabel/QueueUsageByUser/QueueMetrics信息,恰好是一一对应的  </p>
<p>对于 YarnUI 指标异常问题,比较关注的 Queue.numContainer 和 QueueUsageByLabel.resArr[ResourceType.USED]两个指标,一次 allocated/reversed/Container 的申请对应着 numContainer++和 ResourceUsage.incUsed;一次 container 的释放对应着 numContainer–和 ResourceUsage.decUsed   </p>
<h3 id="movetoqueue-时资源转移过程"><a href="#movetoqueue-时资源转移过程" class="headerlink" title="movetoqueue 时资源转移过程"></a>movetoqueue 时资源转移过程</h3><p>使用命令 “yarn application -movetoqueue ${APPID} -queue ${TO}”
可以将 ${APPID}的 APP 移动到目标资源队列 ${TO}<br>ClientRMService 相应请求的调用栈是:<br>-&gt;ClientRMService#moveApplicationAcrossQueues<br>&ensp;&ensp;-&gt;RMAppImpl$RMAppMoveTransition#transition<br>&ensp;&ensp;&ensp;&ensp;-&gt;CapacityScheduler#moveApplication  </p>
<p>application 从源资源队列移动到目标资源队列分为几步:  </p>
<ol>
<li>向目标队列提交application 并做校验,包括 access 权限、目标队列的 app 数量超限、目标队列中用户提交 app 数量超限,若提交成功则增加所有 ParentQueue 的 numApplication 数量(但是没有增加自身的 numApplication 数量)    </li>
<li>转移源队列中所有非 reserved 的 container 到目标队列,源队列(LeafQueue)释放 container,减少<b>标签维度和用户维度</b>的 ResourceUsage USED 类型资源量,并减少源队列的所有父队列(ParentQueue) <b>标签维度</b>的 ResourceUsage USED 类型资源量;增加目标队列(LeafQueue) <b>标签维度和用户维度</b>的 ResourceUsage USED 类型资源量,并增加目标队列的所有父队列(ParentQueue) <b>标签维度</b>的 ResourceUsage USED 类型资源量.指标数量维护在Queue/ResourceUsage/QueueMetrics 中,此处没有处理 livingContainers 的 QueueMetrics ,在第 5 步中统一处理 QueueMetrics    </li>
<li>源队列中移除 appAttemptd,并同步 QueueUsageByUser 和 QueueUsageByLabel 中 AMUSED类型的资源量  </li>
<li>在源队列的所有 ParentQueue 中移除此 Application    </li>
<li>同步源队列和目标队列中所有非 AM container 移动导致的 QueueMetrics 变化  </li>
<li>同步用户维度的 appAttempt 统计信息<br>[CapacityScheduler.java]  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String moveApplication(ApplicationId appId,</span><br><span class="line">     String targetQueueName) throws YarnException &#123;</span><br><span class="line">   FiCaSchedulerApp app &#x3D;</span><br><span class="line">       getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));</span><br><span class="line">   String sourceQueueName &#x3D; app.getQueue().getQueueName();</span><br><span class="line">   LeafQueue source &#x3D; getAndCheckLeafQueue(sourceQueueName);</span><br><span class="line">   String destQueueName &#x3D; handleMoveToPlanQueue(targetQueueName);</span><br><span class="line">   LeafQueue dest &#x3D; getAndCheckLeafQueue(destQueueName);</span><br><span class="line">   String user &#x3D; app.getUser();</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F;1. 转移 Application</span><br><span class="line">     dest.submitApplication(appId, user, destQueueName);</span><br><span class="line">   &#125; catch (AccessControlException e) &#123;</span><br><span class="line">     throw new YarnException(e);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;2.转移 livingContainer</span><br><span class="line">   for (RMContainer rmContainer : app.getLiveContainers()) &#123;</span><br><span class="line">     source.detachContainer(clusterResource, app, rmContainer);</span><br><span class="line">     &#x2F;&#x2F; attach the Container to another queue</span><br><span class="line">     dest.attachContainer(clusterResource, app, rmContainer);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;3.源资源队列移除attempt,并同步QueueUsage</span><br><span class="line">   source.finishApplicationAttempt(app, sourceQueueName);</span><br><span class="line">   &#x2F;&#x2F;4.源队列的父队列移除 application</span><br><span class="line">   source.getParent().finishApplication(appId, app.getUser());</span><br><span class="line">  &#x2F;&#x2F;5.同步源队列和目标队列的 QueueMetrics</span><br><span class="line">   app.move(dest);</span><br><span class="line">   &#x2F;&#x2F;6.提交attemp</span><br><span class="line">   dest.submitApplicationAttempt(app, user);</span><br><span class="line">   applications.get(appId).setQueue(dest);</span><br><span class="line">   LOG.info(&quot;App: &quot; + app.getApplicationId() + &quot; successfully moved from &quot;</span><br><span class="line">       + sourceQueueName + &quot; to: &quot; + destQueueName);</span><br><span class="line">   return targetQueueName;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>第 2 步中,遍历 app 的 livingContainer,把每个 container 从源队列及父队列释放,减少源队列及父队列的指标<br>先看源队列 LeafQueue 的释放逻辑<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void detachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">      releaseResource(clusterResource, application, rmContainer.getContainer()</span><br><span class="line">          .getResource(), node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; container&#x3D;&quot; + rmContainer.getContainer()</span><br><span class="line">          + &quot; resource&#x3D;&quot; + rmContainer.getContainer().getResource()</span><br><span class="line">          + &quot; queueMoveOut&#x3D;&quot; + this + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity()</span><br><span class="line">          + &quot; absoluteUsedCapacity&#x3D;&quot; + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot;</span><br><span class="line">          + queueUsage.getUsed() + &quot; cluster&#x3D;&quot; + clusterResource);</span><br><span class="line">      &#x2F;&#x2F;ParentQueue#detachContainer</span><br><span class="line">      getParent().detachContainer(clusterResource, application, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  synchronized void releaseResource(Resource clusterResource, </span><br><span class="line">      FiCaSchedulerApp application, Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">     &#x2F;&#x2F;1.减少 标签维度的 ResourceUsage USED 用途的资源;并减少当前 Queue 的 numContainer 数量</span><br><span class="line">    super.releaseResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    &#x2F;&#x2F;2.减少 提交用户在 标签维度的 ResourceUsage USED 用途的资源</span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.releaseContainer(resource, nodeLabels);</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">  &#x2F;&#x2F;ResourceUsageByLabel USED 用途的资源量</span><br><span class="line">  protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">        &#x2F;&#x2F;Queue 的运行 container 数量</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;第 2 处,ResourceUsageByUser USED 用途的资源量</span><br><span class="line">public void releaseContainer(Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">        userResourceUsage.decUsed(resource);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (String label : nodeLabels) &#123;</span><br><span class="line">          userResourceUsage.decUsed(label, resource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>ParentQueue 释放 container 时,减少了用户维度的 ResourceUsage 在 USED 用途上资源量<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void detachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">      super.releaseResource(clusterResource,</span><br><span class="line">          rmContainer.getContainer().getResource(),</span><br><span class="line">          node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; queueMoveOut&#x3D;&quot; + getQueueName()</span><br><span class="line">          + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity() + &quot; absoluteUsedCapacity&#x3D;&quot;</span><br><span class="line">          + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot; + queueUsage.getUsed() + &quot; cluster&#x3D;&quot;</span><br><span class="line">          + clusterResource);</span><br><span class="line">      &#x2F;&#x2F; Inform the parent</span><br><span class="line">      if (parent !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;递归父队列</span><br><span class="line">        parent.detachContainer(clusterResource, application, rmContainer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;AbstractCSQueue#releaseResource</span><br><span class="line">  protected synchronized void releaseResource(Resource clusterResource,</span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    &#x2F;&#x2F; Update usedResources by labels</span><br><span class="line">    if (null &#x3D;&#x3D; nodeLabels || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.decUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.decUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">    --numContainers;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将 container 从源队列转移到目标队列时,会增加目标队列及其父队列的指标<br>先看目标队列(LeafQueue)增加的指标<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void attachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">          &#x2F;&#x2F;1.增加 LeafQueue 标签维度的 ResourceUsage 和用户维度的 ResourceUsage, USED 类型的资源量;并增加numContainer</span><br><span class="line">      allocateResource(clusterResource, application, rmContainer.getContainer()</span><br><span class="line">          .getResource(), node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; container&#x3D;&quot; + rmContainer.getContainer()</span><br><span class="line">              &#x2F;&#x2F;add by jiulong.zhu@20190903</span><br><span class="line">              +&quot; containerState&#x3D;&quot;+rmContainer.getState()</span><br><span class="line">          + &quot; resource&#x3D;&quot; + rmContainer.getContainer().getResource()</span><br><span class="line">          + &quot; queueMoveIn&#x3D;&quot; + this + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity()</span><br><span class="line">          + &quot; absoluteUsedCapacity&#x3D;&quot; + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot;</span><br><span class="line">          + queueUsage.getUsed() + &quot; cluster&#x3D;&quot; + clusterResource);</span><br><span class="line">      &#x2F;&#x2F;2.增加 ParentQueue 标签维度的 ResourceUsage USED 类型的资源量;并增加 ParentQueue 的 numContainer 数量</span><br><span class="line">      getParent().attachContainer(clusterResource, application, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  synchronized void allocateResource(Resource clusterResource,</span><br><span class="line">      SchedulerApplicationAttempt application, Resource resource,</span><br><span class="line">      Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">      &#x2F;&#x2F;AbstractCSQueue#allocateResource 增加标签维度的 ResourceUsage USED 用途的用量;增加 Queue 的numContainers  </span><br><span class="line">    super.allocateResource(clusterResource, resource, nodeLabels);</span><br><span class="line">    String userName &#x3D; application.getUser();</span><br><span class="line">    &#x2F;&#x2F;增加当前用户 标签维度的 ResourceUsage USED 用途的用量  </span><br><span class="line">    User user &#x3D; getUser(userName);</span><br><span class="line">    user.assignContainer(resource, nodeLabels);</span><br><span class="line">    </span><br><span class="line">    Resources.subtractFrom(application.getHeadroom(), resource);</span><br><span class="line">    metrics.setAvailableResourcesToUser(userName, application.getHeadroom());</span><br><span class="line">    if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.info(getQueueName() + </span><br><span class="line">          &quot; user&#x3D;&quot; + userName + </span><br><span class="line">          &quot; used&#x3D;&quot; + queueUsage.getUsed() + &quot; numContainers&#x3D;&quot; + numContainers +</span><br><span class="line">          &quot; headroom &#x3D; &quot; + application.getHeadroom() +</span><br><span class="line">          &quot; user-resources&#x3D;&quot; + user.getUsed()</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;AbstractCSQueue#allocateResource</span><br><span class="line">   synchronized void allocateResource(Resource clusterResource, </span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.incUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.incUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++numContainers;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再看将 container 移动到目标队列时,目标队列的 ParentQueue 增加的逻辑<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void attachContainer(Resource clusterResource,</span><br><span class="line">      FiCaSchedulerApp application, RMContainer rmContainer) &#123;</span><br><span class="line">    if (application !&#x3D; null) &#123;</span><br><span class="line">      FiCaSchedulerNode node &#x3D;</span><br><span class="line">          scheduler.getNode(rmContainer.getContainer().getNodeId());</span><br><span class="line">          &#x2F;&#x2F;1.增加 ParentQueue 在标签维度的 ResourceUsage USED 用量 </span><br><span class="line">          &#x2F;&#x2F;AbstractCSQueue#allocateResource</span><br><span class="line">      super.allocateResource(clusterResource, rmContainer.getContainer()</span><br><span class="line">          .getResource(), node.getLabels());</span><br><span class="line">      LOG.info(&quot;movedContainer&quot; + &quot; queueMoveIn&#x3D;&quot; + getQueueName()</span><br><span class="line">          + &quot; usedCapacity&#x3D;&quot; + getUsedCapacity() + &quot; absoluteUsedCapacity&#x3D;&quot;</span><br><span class="line">          + getAbsoluteUsedCapacity() + &quot; used&#x3D;&quot; + queueUsage.getUsed() + &quot; cluster&#x3D;&quot;</span><br><span class="line">          + clusterResource);</span><br><span class="line">      &#x2F;&#x2F;2.递归增加 ParentQueue 的所有 ParentQueue 的 ResourceUsage USED 用量  </span><br><span class="line">      if (parent !&#x3D; null) &#123;</span><br><span class="line">        parent.attachContainer(clusterResource, application, rmContainer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;AbstractCSQueue#allocateResource</span><br><span class="line">  synchronized void allocateResource(Resource clusterResource, </span><br><span class="line">      Resource resource, Set&lt;String&gt; nodeLabels) &#123;</span><br><span class="line">    if (nodeLabels &#x3D;&#x3D; null || nodeLabels.isEmpty()) &#123;</span><br><span class="line">      queueUsage.incUsed(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Set&lt;String&gt; anls &#x3D; (accessibleLabels.contains(RMNodeLabelsManager.ANY))</span><br><span class="line">          ? labelManager.getClusterNodeLabels() : accessibleLabels;</span><br><span class="line">      for (String label : Sets.intersection(anls, nodeLabels)) &#123;</span><br><span class="line">        queueUsage.incUsed(label, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++numContainers;</span><br><span class="line">    CSQueueUtils.updateQueueStatistics(resourceCalculator, this, getParent(),</span><br><span class="line">        clusterResource, minimumAllocation);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 3 步:删除源队列中该 app 的 currentApplicationAttempt,并同步 LeafQueue 中用户提交的 app 数量变化<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void finishApplicationAttempt(FiCaSchedulerApp application, String queue) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      removeApplicationAttempt(application, getUser(application.getUser()));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;空实现</span><br><span class="line">    getParent().finishApplicationAttempt(application, queue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public synchronized void removeApplicationAttempt(</span><br><span class="line">      FiCaSchedulerApp application, User user) &#123;</span><br><span class="line">    boolean wasActive &#x3D; activeApplications.remove(application);</span><br><span class="line">    if (!wasActive) &#123;</span><br><span class="line">      pendingApplications.remove(application);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;正在运行的 app_attempt,则减少 LeafQueue 的 [ResourceUsage | ResourceUsageByUser] 中AMUSED 占用的资源量</span><br><span class="line">      queueUsage.decAMUsed(application.getAMResource());</span><br><span class="line">      user.getResourceUsage().decAMUsed(application.getAMResource());</span><br><span class="line">    &#125;</span><br><span class="line">    applicationAttemptMap.remove(application.getApplicationAttemptId());</span><br><span class="line">     &#x2F;&#x2F; 在 ResourceUsageByUser 同步 numApplication 指标</span><br><span class="line">    user.finishApplication(wasActive);</span><br><span class="line">    if (user.getTotalApplications() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      users.remove(application.getUser());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Check if we can activate more applications</span><br><span class="line">    activateApplications();</span><br><span class="line">    LOG.info(&quot;Application removed -&quot; +</span><br><span class="line">        &quot; appId: &quot; + application.getApplicationId() + </span><br><span class="line">        &quot; user: &quot; + application.getUser() + </span><br><span class="line">        &quot; queue: &quot; + getQueueName() +</span><br><span class="line">        &quot; #user-pending-applications: &quot; + user.getPendingApplications() +</span><br><span class="line">        &quot; #user-active-applications: &quot; + user.getActiveApplications() +</span><br><span class="line">        &quot; #queue-pending-applications: &quot; + getNumPendingApplications() +</span><br><span class="line">        &quot; #queue-active-applications: &quot; + getNumActiveApplications()</span><br><span class="line">        );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 4 步:对于源队列的所有 ParentQueue,移除 app 的 currentApplicationAttempt,并减少资源队列的运行 numApplication 值<br>[ParentQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void finishApplication(ApplicationId application, String user) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      removeApplication(application, user);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;递归 父队列</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.finishApplication(application, user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private synchronized void removeApplication(ApplicationId applicationId, </span><br><span class="line">      String user) &#123;</span><br><span class="line">    --numApplications;</span><br><span class="line">    LOG.info(&quot;Application removed -&quot; +</span><br><span class="line">        &quot; appId: &quot; + applicationId + </span><br><span class="line">        &quot; user: &quot; + user + </span><br><span class="line">        &quot; leaf-queue of parent: &quot; + getQueueName() + </span><br><span class="line">        &quot; #applications: &quot; + getNumApplications());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 5 步: 将 app 持有的所有 allocatedContainer(包括 AM container)和 reservedContainer,移动到目标队列,并修改 QueueMetrics<br>[SchedulerApplicationAttempt.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void move(Queue newQueue) &#123;</span><br><span class="line">    QueueMetrics oldMetrics &#x3D; queue.getMetrics();</span><br><span class="line">    QueueMetrics newMetrics &#x3D; newQueue.getMetrics();</span><br><span class="line">    String user &#x3D; getUser();</span><br><span class="line">    &#x2F;&#x2F;修改 livingContainer 的 QueueMetrics</span><br><span class="line">    for (RMContainer liveContainer : liveContainers.values()) &#123;</span><br><span class="line">      Resource resource &#x3D; liveContainer.getContainer().getResource();</span><br><span class="line">      oldMetrics.releaseResources(user, 1, resource);</span><br><span class="line">      newMetrics.allocateResources(user, 1, resource, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;修改 reservedContainer的 QueueMetrics</span><br><span class="line">    for (Map&lt;NodeId, RMContainer&gt; map : reservedContainers.values()) &#123;</span><br><span class="line">      for (RMContainer reservedContainer : map.values()) &#123;</span><br><span class="line">        Resource resource &#x3D; reservedContainer.getReservedResource();</span><br><span class="line">        oldMetrics.unreserveResource(user, resource);</span><br><span class="line">        newMetrics.reserveResource(user, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;移动 pending ResourceRequest,同步信息:QueueMetrics.appsRunning,Queue下的用户列表    </span><br><span class="line">    appSchedulingInfo.move(newQueue);</span><br><span class="line">    this.queue &#x3D; newQueue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>修改 livingContainers 和 reservedContainers 的所有逻辑都在 QueueMetrics中,其中<br>1.releaseResources,释放 livingContainer: [ParentQueue | LeafQueue] [本身 | 用户维度] 的 allocated [Containers | MB | Core]指标<br>2.allocateResource,申请 livingContainer: [ParentQueue | LeafQueue] [本身 | 用户维度] 的 allocated [Containers | MB | Core]指标<br>3.unreserveResource,释放 reservedContainer:[ParentQueue | LeafQueue] [本身 | 用户维度] 的 reserved [Containers| MB | Core]指标<br>4.reserveResource,申请 reservedContainer:[ParentQueue | LeafQueue] [本身 | 用户维度] 的 reserved [Container | MB | Core]指标<br>[QueueMetrics.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public void releaseResources(String user, int containers, Resource res) &#123;</span><br><span class="line">    allocatedContainers.decr(containers);</span><br><span class="line">    aggregateContainersReleased.incr(containers);</span><br><span class="line">    allocatedMB.decr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.decr(res.getVirtualCores() * containers);</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.releaseResources(user, containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> public void allocateResources(String user, int containers, Resource res,</span><br><span class="line">      boolean decrPending) &#123;</span><br><span class="line">    allocatedContainers.incr(containers);</span><br><span class="line">    aggregateContainersAllocated.incr(containers);</span><br><span class="line">    allocatedMB.incr(res.getMemory() * containers);</span><br><span class="line">    allocatedVCores.incr(res.getVirtualCores() * containers);</span><br><span class="line">    if (decrPending) &#123;</span><br><span class="line">      _decrPendingResources(containers, res);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.allocateResources(user, containers, res, decrPending);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void unreserveResource(String user, Resource res) &#123;</span><br><span class="line">    reservedContainers.decr();</span><br><span class="line">    reservedMB.decr(res.getMemory());</span><br><span class="line">    reservedVCores.decr(res.getVirtualCores());</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.unreserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void reserveResource(String user, Resource res) &#123;</span><br><span class="line">    reservedContainers.incr();</span><br><span class="line">    reservedMB.incr(res.getMemory());</span><br><span class="line">    reservedVCores.incr(res.getVirtualCores());</span><br><span class="line">    QueueMetrics userMetrics &#x3D; getUserMetrics(user);</span><br><span class="line">    if (userMetrics !&#x3D; null) &#123;</span><br><span class="line">      userMetrics.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">    if (parent !&#x3D; null) &#123;</span><br><span class="line">      parent.reserveResource(user, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第 6 步:同步目标队列 application 和 applicationAttempt信息<br>[LeafQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void submitApplicationAttempt(FiCaSchedulerApp application,</span><br><span class="line">      String userName) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      User user &#x3D; getUser(userName);</span><br><span class="line">      &#x2F;&#x2F;增加 Queue 和 User 维度 application &#x2F; applicationAttempt 的值</span><br><span class="line">      addApplicationAttempt(application, user);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; We don&#39;t want to update metrics for move app</span><br><span class="line">    if (application.isPending()) &#123;</span><br><span class="line">     &#x2F;&#x2F;增加 Queue 和 User 维度 QueueMetrics 中 appsPending 的值</span><br><span class="line">      metrics.submitAppAttempt(userName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;空实现</span><br><span class="line">    getParent().submitApplicationAttempt(application, userName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上:<br>把 application 从源资源队列到目标队列的过程中,在 Queue/ResourceUsageByLabel/ResourceUsageByUser/QueueMetrics 中的变动<br>1.对于 livingContainers,<br>&ensp;&ensp;&ensp;&ensp;Queue 方面:减少源队列及其父队列的 numContainer 值;增加目标队列及其父队列的 numContainer<br>&ensp;&ensp;&ensp;&ensp;ResourceUsage 方面:减少源队列及其父队列的 ResourceUsageByLabel USED 类型的资源量,增加目标队列及其父队列的 ResourceUsageByLabel USED 类型的资源量; 减少源队列(LeafQueue)的 ResourceUsageByUser USED 类型的资源量,增加目标队列(LeafQueue) 的 ResourceUsageByUser USED 类型的资源量;<br>&ensp;&ensp;&ensp;&ensp;QueueMetrics 方面:减少源队列及其父队列的 allocated[Container | MB | Core]指标,增加目标队列及其父队列的 allocated [Container | MB | Core]<br>2.对于 reservedContainers,<br>&ensp;&ensp;&ensp;&ensp;ResourceUsage:减少源队列[LeafQueue | ParentQueue] [本身 | 用户维度] 的reserved [Container | MB | Core]指标,增加目标队列[LeafQueue | ParentQueue] [本身 | 用户维度] 的 reserved [Container | MB | Core]指标  </p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>结合 “正常的资源分配和释放过程”和”movetoqueue 过程中的资源转移过程 “,可以还原一个被转移队列的 application 的资源变动过程<br>application 中非 reservedContianer(状态机:allocated,acquired,running) 的资源变动过程如下表  </p>
<table>
<thead>
<tr>
<th align="left">allocatedContainer</th>
<th align="center">分配</th>
<th align="center">movetoqueue</th>
<th align="center">释放</th>
</tr>
</thead>
<tbody><tr>
<td align="left">numContainer</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">ResourceUsageByLabel(USED)</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">QueueMetrics</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
</tbody></table>
<p>application 中 reservedContianer(状态机:reversed) 的资源变动过程如下表   </p>
<table>
<thead>
<tr>
<th align="left">reversedContainer</th>
<th align="center">分配</th>
<th align="center">movetoqueue</th>
<th align="center">释放</th>
</tr>
</thead>
<tbody><tr>
<td align="left">numContainer</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">ResourceUsageByLabel(USED)</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">QueueMetrics</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
</tbody></table>
<blockquote>
</blockquote>
<p>从上述两表中可知:<br>1.在没有 movetoqueue 操作的情况下, 源队列和目标队列一致,无论 allocatedContainer 或 reservedContainer 的分配和释放都是守恒的,一次指标的增加对应着一次指标的减少<br>2.在源队列资源比较充裕,且有 movetoqueue 操作的情况下,application 没有 reservedContainer 的情况下(上述表一),在分配时源队列指标增加,movetoqueue 时,源队列减少指标且目标队列增加指标,在释放时减少目标队列(app 当前归属队列)的指标.指标的增减也是平衡的,这也就是在资源充裕的队列上无法复现该问题的原因<br>3.在源队列资源比较紧张,且有 movetoqueue 操作的情况下,application 有 reservedContainer 和 allocatedContainer(上述表一和表二),对于 allocatedContainer 来说,资源在分配-&gt;movetoque-&gt;释放的过程中是平衡的(表一);但是对于 reversedContainer 来说,在源队列中分配到资源时,增加了源队列的 numContainer 和 ResourceUsageByLabel 中 USED 用途的资源量,movetoqueue 时没有相应的操作,仅仅是修改了 QueueMetrcis 内的指标,在释放时 container 资源被加入到目标队列的指标中(上述表二).<b>源队列分配出去的资源没有回收,目标队列得到了不是自身分配出去的资源</b>.这样导致了即使源队列和目标队列中完全无任务时,源队列的 numContainer 和 ResourceUsageByLabel 值为正值,目标队列的 numContainer 和 ResourceUsage 值为负值,Yarn UI -&gt;scheduler-&gt;queue 内的 Num Containers/Used Capacity/Absolute Used Capacity/Used Resources 正是基于 队列的 numContainer 和 ResourceUsageByLabel(USED) 展示和计算的,也就是指标异常的问题     </p>
<p>指标异常(无任务时 为负)
<img src="/img/pictures/negative/negative_e7a766275896.png" alt=""></p>
<p>指标异常(无任务时 为正)
<img src="/img/pictures/negative/negative_aead-04d8e67b1357.png" alt=""></p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>1.对于源队列来说,类似于资源泄露,自身资源未能回收,释放到了目标队列.这样对于后续提交到源队列的任务来说,不能分配到资源运行(USED 泄露趋于 100%),但实际上源队列没有任务在运行<br>2.对于目标队列来说,多出了一些资源,导致自身一些指标为负,可能会导致一些未知的问题.以下纯属个人猜测: 例如 同步问题,Queue 有很多的剩余资源,但是 NodeManager 上没有 available 资源;指标负值可能对内部的运算产生未预期的问题  </p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>针对 reservedContainer 在 movetoqueue 操作过程中,资源释放申请不守恒的漏洞,如下表  </p>
<table>
<thead>
<tr>
<th align="left">reversedContainer</th>
<th align="center">分配</th>
<th align="center">movetoqueue</th>
<th align="center">释放</th>
</tr>
</thead>
<tbody><tr>
<td align="left">numContainer</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">ResourceUsageByLabel(USED)</td>
<td align="center">源队列值增加</td>
<td align="center"><font color="#660000">源队列不变,目标队列不变</font></td>
<td align="center">目标队列值减少</td>
</tr>
<tr>
<td align="left">QueueMetrics</td>
<td align="center">源队列值增加</td>
<td align="center">源队列减少,目标队列增加</td>
<td align="center">目标队列值减少</td>
</tr>
</tbody></table>
<blockquote>
</blockquote>
<p>问题:<br>&ensp;&ensp;&ensp;&ensp;YarnUI 中指标 Num Container、Used Capacity、Absolute Used Capacity、Used Resource 异常和 Queue成员变量numContainer及 QueueUsageByLabel 中 USED 用途的资源量有关<br>目标:<br>&ensp;&ensp;&ensp;&ensp;解决 numContainer 和 ResourceUsageByLabel(USED)在 movetoqueue 时,没有”减少源队列的指标”且没有”增加目标队列指标”的问题<br>途径:<br>&ensp;&ensp;&ensp;&ensp;1.需要在 movetoqueue 时,每个 reservedContainer 都应触发 “源队列减少指标”和”目标队列增加指标”的行为 
&ensp;&ensp;&ensp;&ensp;源码中有封装好的代码且上文多次提到,即 LeafQueue#releaseResource方法和 LeafQueue.allocateResource方法,但是其中有额外的 对 headroom 的同步逻辑.一方面,在”正常的分配和释放”过程中,无论申请和分配的 container 是 allocated 或是 reversed 都会执行 LeafQueue#releaseResource 和 LeafQueue.allocateResource 修改 numContainer 和 ResourceUsageByLabel 的同时修改 headroom值;另一方面 move container中对 headroom 增加和减少 同一个Resource 是幂等的.所以 movetoqueue 操作对于每一个 container 的移动都可以选择触发这两个方法来增加对 numContainer 和 ResourceUsageByLabel 的操作.LeafQueue#detachContainer()和 LeafQueueattachContainer()  中有递归本队列及当前队列此逻辑的过程.直接用即可<br>修改方案:<br>&ensp;&ensp;&ensp;&ensp;CapacitySchedule#moveApplication(ApplicationId appId,String targetQueueName) 方法修改如下  </p>
<p>[CapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public synchronized String moveApplication(ApplicationId appId,</span><br><span class="line">      String targetQueueName) throws YarnException &#123;</span><br><span class="line">    FiCaSchedulerApp app &#x3D;</span><br><span class="line">        getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));</span><br><span class="line">    String sourceQueueName &#x3D; app.getQueue().getQueueName();</span><br><span class="line">    LeafQueue source &#x3D; getAndCheckLeafQueue(sourceQueueName);</span><br><span class="line">    String destQueueName &#x3D; handleMoveToPlanQueue(targetQueueName);</span><br><span class="line">    LeafQueue dest &#x3D; getAndCheckLeafQueue(destQueueName);</span><br><span class="line">    &#x2F;&#x2F; Validation check - ACLs, submission limits for user &amp; queue</span><br><span class="line">    String user &#x3D; app.getUser();</span><br><span class="line">    try &#123;</span><br><span class="line">      dest.submitApplication(appId, user, destQueueName);</span><br><span class="line">    &#125; catch (AccessControlException e) &#123;</span><br><span class="line">      throw new YarnException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Move all live containers</span><br><span class="line">    for (RMContainer rmContainer : app.getLiveContainers()) &#123;</span><br><span class="line">      source.detachContainer(clusterResource, app, rmContainer);</span><br><span class="line">      &#x2F;&#x2F; attach the Container to another queue</span><br><span class="line">      dest.attachContainer(clusterResource, app, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;description:解决 reservedContainer 在 movetoqueue 操作过程中,Queue.numContainer 指标和 ResourceUsageByLabel.USED 资源量</span><br><span class="line">    &#x2F;&#x2F;释放申请不守恒,导致 Yarn UI &quot;Num Container&quot;,&quot;Used Capacity&quot;,&quot;Absolute Used Capacity&quot;,&quot;Used Resource&quot;</span><br><span class="line">    &#x2F;&#x2F;指标在队列无任务运行时不为 0 的问题</span><br><span class="line">    &#x2F;&#x2F;modify by jiulong.zhu@20190903</span><br><span class="line">    &#x2F;&#x2F;++add start</span><br><span class="line">    for (RMContainer rmContainer : app.getReservedContainers()) &#123;</span><br><span class="line">      source.detachContainer(clusterResource, app, rmContainer);</span><br><span class="line">      dest.attachContainer(clusterResource, app, rmContainer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;++add end</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Detach the application..</span><br><span class="line">    source.finishApplicationAttempt(app, sourceQueueName);</span><br><span class="line">    source.getParent().finishApplication(appId, app.getUser());</span><br><span class="line">    &#x2F;&#x2F; Finish app &amp; update metrics</span><br><span class="line">    app.move(dest);</span><br><span class="line">    &#x2F;&#x2F; Submit to a new queue</span><br><span class="line">    dest.submitApplicationAttempt(app, user);</span><br><span class="line">    applications.get(appId).setQueue(dest);</span><br><span class="line">    LOG.info(&quot;App: &quot; + app.getApplicationId() + &quot; successfully moved from &quot;</span><br><span class="line">        + sourceQueueName + &quot; to: &quot; + destQueueName);</span><br><span class="line">    return targetQueueName;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒烟测试用例"><a href="#冒烟测试用例" class="headerlink" title="冒烟测试用例"></a>冒烟测试用例</h2><p>[TestCapacityScheduler.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testReservedContainerLeakWhenMoveApplication() throws Exception &#123;</span><br><span class="line">  CapacitySchedulerConfiguration csConf</span><br><span class="line">          &#x3D; new CapacitySchedulerConfiguration();</span><br><span class="line">  csConf.setQueues(CapacitySchedulerConfiguration.ROOT, new String[] &#123;&quot;a&quot;, &quot;b&quot;&#125;);</span><br><span class="line">  csConf.setCapacity(&quot;root.a&quot;,50);</span><br><span class="line">  csConf.setMaximumCapacity(&quot;root.a&quot;,100);</span><br><span class="line">  csConf.setUserLimitFactor(&quot;root.a&quot;,100);</span><br><span class="line">  csConf.setCapacity(&quot;root.b&quot;,50);</span><br><span class="line">  csConf.setMaximumCapacity(&quot;root.b&quot;,100);</span><br><span class="line">  csConf.setUserLimitFactor(&quot;root.b&quot;,100);</span><br><span class="line"></span><br><span class="line">  YarnConfiguration conf&#x3D;new YarnConfiguration(csConf);</span><br><span class="line">  conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class,</span><br><span class="line">          ResourceScheduler.class);</span><br><span class="line">  RMNodeLabelsManager mgr&#x3D;new NullRMNodeLabelsManager();</span><br><span class="line">  mgr.init(conf);</span><br><span class="line">  MockRM rm1 &#x3D; new MockRM(csConf);</span><br><span class="line">  CapacityScheduler scheduler&#x3D;(CapacityScheduler) rm1.getResourceScheduler();</span><br><span class="line">  rm1.getRMContext().setNodeLabelManager(mgr);</span><br><span class="line">  rm1.start();</span><br><span class="line">  MockNM nm1 &#x3D; rm1.registerNode(&quot;127.0.0.1:1234&quot;, 8 * GB);</span><br><span class="line">  MockNM nm2 &#x3D; rm1.registerNode(&quot;127.0.0.2:1234&quot;, 8 * GB);</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * simulation</span><br><span class="line">   * app1: (1 AM,1 running container)</span><br><span class="line">   * app2: (1 AM,1 reserved container)</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; launch an app to queue, AM container should be launched in nm1</span><br><span class="line">  RMApp app1 &#x3D; rm1.submitApp(1 * GB, &quot;app_1&quot;, &quot;user_1&quot;, null, &quot;a&quot;);</span><br><span class="line">  MockAM am1 &#x3D; MockRM.launchAndRegisterAM(app1, rm1, nm1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; launch another app to queue, AM container should be launched in nm1</span><br><span class="line">  RMApp app2 &#x3D; rm1.submitApp(1 * GB, &quot;app_2&quot;, &quot;user_1&quot;, null, &quot;a&quot;);</span><br><span class="line">  MockAM am2 &#x3D; MockRM.launchAndRegisterAM(app2, rm1, nm1);</span><br><span class="line"></span><br><span class="line">  am1.allocate(&quot;*&quot;, 4 * GB, 1, new ArrayList&lt;ContainerId&gt;());</span><br><span class="line">  &#x2F;&#x2F;this containerRequest should be reserved</span><br><span class="line">  am2.allocate(&quot;*&quot;, 4 * GB, 1, new ArrayList&lt;ContainerId&gt;());</span><br><span class="line"></span><br><span class="line">  RMNode rmNode1 &#x3D; rm1.getRMContext().getRMNodes().get(nm1.getNodeId());</span><br><span class="line">  &#x2F;&#x2F; Do node heartbeats 2 times</span><br><span class="line">  &#x2F;&#x2F; First time will allocate container for app1, second time will reserve</span><br><span class="line">  &#x2F;&#x2F; container for app2</span><br><span class="line">  scheduler.handle(new NodeUpdateSchedulerEvent(rmNode1));</span><br><span class="line">  scheduler.handle(new NodeUpdateSchedulerEvent(rmNode1));</span><br><span class="line"></span><br><span class="line">  FiCaSchedulerApp schedulerApp1 &#x3D;</span><br><span class="line">          scheduler.getApplicationAttempt(am1.getApplicationAttemptId());</span><br><span class="line">  FiCaSchedulerApp schedulerApp2 &#x3D;</span><br><span class="line">          scheduler.getApplicationAttempt(am2.getApplicationAttemptId());</span><br><span class="line">  &#x2F;&#x2F; APP1:  1 AM, 1 allocatedContainer</span><br><span class="line">  Assert.assertEquals(2, schedulerApp1.getLiveContainers().size());</span><br><span class="line">  &#x2F;&#x2F; APP2:  1 AM,1 reservedContainer</span><br><span class="line">  Assert.assertEquals(1,schedulerApp2.getLiveContainers().size());</span><br><span class="line">  Assert.assertEquals(1,schedulerApp2.getReservedContainers().size());</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * before,move app2 which has one reservedContainer</span><br><span class="line">   *&#x2F;</span><br><span class="line">  LeafQueue srcQueue &#x3D; (LeafQueue) scheduler.getQueue(&quot;a&quot;);</span><br><span class="line">  LeafQueue desQueue &#x3D; (LeafQueue) scheduler.getQueue(&quot;b&quot;);</span><br><span class="line">  Assert.assertEquals(4,srcQueue.getNumContainers());</span><br><span class="line">  Assert.assertEquals(10*GB,srcQueue.getUsedResources().getMemorySize());&#x2F;&#x2F; AM: 2*1GB   container: 4GB running,4GB reserved</span><br><span class="line">  Assert.assertEquals(0,desQueue.getNumContainers());</span><br><span class="line">  Assert.assertEquals(0,desQueue.getUsedResources().getMemorySize());</span><br><span class="line">  &#x2F;&#x2F;app1 ResourceUsage (0 reserved)</span><br><span class="line">  Assert.assertEquals(5*GB,schedulerApp1.getAppAttemptResourceUsage().getAllUsed().getMemorySize());</span><br><span class="line">  Assert.assertEquals(0,schedulerApp1.getCurrentReservation().getMemorySize());</span><br><span class="line">  &#x2F;&#x2F;app2  ResourceUsage (4GB reserved)</span><br><span class="line">  Assert.assertEquals(1*GB,schedulerApp2.getAppAttemptResourceUsage().getAllUsed().getMemorySize());</span><br><span class="line">  Assert.assertEquals(4*GB,schedulerApp2.getCurrentReservation().getMemorySize());</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * move app2 which has one reservedContainer</span><br><span class="line">   *&#x2F;</span><br><span class="line">  scheduler.moveApplication(app2.getApplicationId(),&quot;b&quot;);</span><br><span class="line">  &#x2F;&#x2F; finish.keep the order,if killing app1 first,the reservedContainer of app2 will be allocated</span><br><span class="line">  rm1.killApp(app2.getApplicationId());</span><br><span class="line">  rm1.killApp(app1.getApplicationId());</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * after,moved app2 which has one reservedContainer</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; after fixed</span><br><span class="line">    Assert.assertEquals(0, srcQueue.getNumContainers());</span><br><span class="line">    Assert.assertEquals(0, desQueue.getNumContainers());</span><br><span class="line">    Assert.assertEquals(0, srcQueue.getUsedResources().getMemorySize());</span><br><span class="line">    Assert.assertEquals(0, desQueue.getUsedResources().getMemorySize());</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;*&#123;</span><br><span class="line">    &#x2F;&#x2F; before fixed</span><br><span class="line">    &#x2F;&#x2F; &lt;b&gt; the reserved container borrowed from srcQueue and returned to desQueue,</span><br><span class="line">    &#x2F;&#x2F; but the numContainer and UsedResource did not sync when moving app to another queue &lt;&#x2F;b&gt;</span><br><span class="line">    Assert.assertEquals(+1,srcQueue.getNumContainers());    &#x2F;&#x2F;true</span><br><span class="line">    Assert.assertEquals(-1,desQueue.getNumContainers());    &#x2F;&#x2F;true</span><br><span class="line">    Assert.assertEquals(+4*GB, srcQueue.getUsedResources().getMemorySize());    &#x2F;&#x2F;true</span><br><span class="line">    Assert.assertEquals(-4*GB, desQueue.getUsedResources().getMemorySize());    &#x2F;&#x2F;true</span><br><span class="line">  &#125;*&#x2F;</span><br><span class="line">  rm1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线上测试用例"><a href="#线上测试用例" class="headerlink" title="线上测试用例"></a>线上测试用例</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag"># 源码解析</a>
              <a href="/tags/Yarn-2-7-3/" rel="tag"># Yarn 2.7.3</a>
              <a href="/tags/Yarn-%E4%BC%98%E5%8C%96/" rel="tag"># Yarn 优化</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019-08-09-ExecutorAllocationManager/" rel="prev" title="ExecutorAllocationManager源码分析">
      <i class="fa fa-chevron-left"></i> ExecutorAllocationManager源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2019-10-05-Yarn%20PreemptionSystem/" rel="next" title="Yarn PreemptionSystem">
      Yarn PreemptionSystem <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题背景"><span class="nav-number">1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先期判断"><span class="nav-number">2.</span> <span class="nav-text">先期判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指标关联的变量定位"><span class="nav-number">2.1.</span> <span class="nav-text">指标关联的变量定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常指标计算方式"><span class="nav-number">2.2.</span> <span class="nav-text">异常指标计算方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题复现"><span class="nav-number">3.</span> <span class="nav-text">问题复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#猜测重复释放"><span class="nav-number">3.1.</span> <span class="nav-text">猜测重复释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#猜测无效释放"><span class="nav-number">3.2.</span> <span class="nav-text">猜测无效释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#movetoqueue"><span class="nav-number">3.3.</span> <span class="nav-text">movetoqueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码解析"><span class="nav-number">4.</span> <span class="nav-text">源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正常的资源分配和释放过程"><span class="nav-number">4.1.</span> <span class="nav-text">正常的资源分配和释放过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源分配"><span class="nav-number">4.2.</span> <span class="nav-text">资源分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源释放"><span class="nav-number">4.3.</span> <span class="nav-text">资源释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#movetoqueue-时资源转移过程"><span class="nav-number">4.4.</span> <span class="nav-text">movetoqueue 时资源转移过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-number">4.5.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#危害"><span class="nav-number">4.6.</span> <span class="nav-text">危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方法"><span class="nav-number">4.7.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒烟测试用例"><span class="nav-number">5.</span> <span class="nav-text">冒烟测试用例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线上测试用例"><span class="nav-number">6.</span> <span class="nav-text">线上测试用例</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">List</p>
  <div class="site-description" itemprop="description">Hello World!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jiulongzhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiulongzhu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jiulong.zhu@gmail.com" title="E-Mail → mailto:jiulong.zhu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">List</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jiulong-zhu.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://jiulongzhu.github.io/2019-09-15-Yarn:movetoqueue%E5%AF%BC%E8%87%B4%E7%9A%84UIcontainer%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/",
            identifier: "2019-09-15-Yarn:movetoqueue导致的UIcontainer泄露问题的修复思路/",
            title: "Yarn movetoqueue 导致的UI指标错误的修复思路"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://jiulong-zhu.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
