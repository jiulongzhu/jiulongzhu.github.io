---
layout:     post
title:      基于队列优先级的小集群大容器资源抢占模式
subtitle:   Preemption for large container in mini yarn cluster  
date:       2019-11-25  
author:     jiulongzhu  
header-img: img/moon_night.jpg  
catalog: true  
tags:  
    - Yarn 2.7.3 
    - 方案 
---


## 抢占概述
　　Yarn 使用树状层级队列组织方式来管理资源，所有 NodeManager 持有的资源聚集作为资源根队列 root 来代表集群中所有可用资源  
　　层级队列中除 root 外每个队列可以设置其拥有父队列的最低配额和最高配额。最高配额是队列无论在任何情况下都不会超出的资源量，最低配额一般理解为在队列保底资源量以快速响应请求，实际上是用来决定集群资源配比权重。为了提高集群整体的资源利用率，Yarn 引入了抢占机制:  

1. 在队列中无任务运行时，队列没有必要硬遵守保留最低配额，可以将资源借给负载较高的其他队列  
2. 当借出资源的队列接收到了新提交的应用时，将出借的资源收回以满足本队列的资源需求  

<!-- more -->
 
　　其中第一点由常规调度器来实现: 队列的实际配额基于自身和其他队列的需求动态变化 介于 0与最高配额之间，当队列无任何 APP 时资源出借给繁忙的队列 实际资源量为 0，当队列负载较大时可能借用其他空闲队列的资源但不会超过其最高配额。第二点由抢占调度来实现: 出借资源的队列接收了新的 APP 之后，需要从其他超出最低配额的队列(超分配队列)中抢占(回)资源，用以启动APP。从超分配队列中抢占资源时，基于“最小化对已启动应用程序的影响”原则，选择杀死 Container 释放资源时 优先杀死最新启动 App 的最新分配的 Container，优先杀死保留的 Container，优先杀死非 AM 角色的 Container  

## 现存问题
场景: 假设集群内有两个队列:A 和 B  
　　状态 1: A完全空闲，B 负载很高，借用了 A 的全部资源    
　　状态 2: A新提交了 AppX，且 AppX 申请的每个 Container 都很大，e.g. 60G  
　　状态 3: 抢占调度从B 队列杀死了一些 Container，释放了一些资源(默认单次抢占资源总量不超过集群总资源的10%)，但这些资源分布在n个节点上    
　　状态 4: 当这 n 个节点向 RM 汇报心跳时，常规调度尝试对每个队列(有序，负载低的优先，A先于 B)的每个应用程序(有序，早提交的优先)进行分配资源，如果这n 个节点都不能启动“大 Container”，那么当 A 没有得到资源时对 B 尝试分配， B 内的 App是可以得到资源的(杀死的就是 B 内 App 的 Container)    
　　状态 5: A没有得到资源，依旧处于欠分配状态;B 得到了资源，处于超分配状态。抢占调度会再次从 B 抢占资源，杀死一些 Container。即”状态 3”  

造成的影响有四：    

1. 在抢占调度层面，一直在状态 3->4->5->3...循环执行，处于“A 欠分配，B 超分配“->”抢占调度释放 B 的资源”->”A 不能使用资源，B 能使用则分配给 B”->”A 欠分配，B 超分配”循环  
2. 在资源队列层面，A 队列一直没有得到资源，且一直触发抢占; B 队列在抢占调度释放资源，在常规调度得到 A 队列无法利用的资源  
3. 在应用程序层面，对于 A中的大 Container App，一直没有得到资源，处于等待状态;对于 B 中的 App，其部分 Container 一直处于”被抢占”->”可启动”->”启动(成为最新容器)”->”被抢占”->”可启动”...的循环状态  
4. 从 SLA 和资源利用率角度来说，A 中的 App 没有迅速响应，B 中的 App 被拖慢了速度。有一部分资源被反复无效调度  

>
Tips:  
1. 抢占调度是周期性执行的，默认 3 秒。  
2. 抢占调度和常规调度是解耦的，常规调度负责为每个队列的每个 APP的每个 ResourceRequest 调度，抢占调度负责所有队列资源的平衡，不为某个具体的 App、具体的 Container 做调度    
3. 抢占调度是”资源再平衡”的过程，空闲队列有了资源需求后，所有队列计算自身的理想容量，超分配的队列释放资源，欠分配的队列在常规调度模块优先分配资源  
4. 集群内队列是平等的， A 队列可以抢 B， B 队列也可以抢 A。这对保证核心业务来说是不友好的，非核心业务可能会抢占核心业务的资源，拖慢核心业务  
5. “最小化对已启动应用程序的影响”是抢占调度的核心原则，具体表现在:  
　　a. 每轮总抢占:默认 10%，单次抢占总资源量最多不能超过集群总资源量的 10%  
　　b. 忽略抢占阈值(deadzone,死区): 默认 0.2，超分配队列只有在 used>(1+0.2) * capacity 时，才会还回资源。e.g. capacity=100G， used=110G时则不在该队列抢占  
　　c. 自然终止因子: 默认 20%，即使容器不被杀死，也有 95%概率在5 * 15s 内终止。所以每个超分配队列最多还回超分配部分的 20%。e.g. used=100G，ideal=40G，本轮抢占该队列最终归还量为(100-40) * 20%=12G
　　d. 确定了最终归还量之后，则从队列所有 APP 中选择一些容器杀死，杀死容器的总容量大于等于最终归还量。选择容器时的规则是:优先选择最新启动的 APP最近启动的容器，优先选择保留的容器(未启动)，优先选择非 AM 角色的容器   
　　故自然终止因子决定了该轮抢占立即能得到的资源量，每轮总抢占决定了该轮抢占最多能得到的资源量  
6. 保留:常规调度为什么不在 n 个节点上做保留?  
在节点上为容器做分配/保留的限制条件有:  
　　a. 队列具有该节点的 access 权限，节点不在 APP 设置的黑名单内  
　　b. 节点上无保留且节点剩余空间大于最小容器大小(yarn.scheduler.minimum-allocation-mb)    
　　c. 最高配额限制: 如果分配该容器，叶子队列及其所有父队列均不能超过各自的最高配额  
　　d. 用户配额限制: 用户配额上限(headroom) 取值为 min{当前容量 * user_limit_factor，max{当前容量/活跃用户数，当前容量/最高用户数}}，当前容量取决于最低配额、当前尝试的ResourceRequest 、 Used 关系。一个用户在任何情况下，使用的配额不能高于队列最低配额*user_limit_factor  
　　e. AM 限制:不超过队列 AM 限制(AM资源和AM数量限制)  
主要限制在 c)和 d)。d)中 user_limit_factor 一般设置为 1，活跃用户数低于最高用户限制，则取值一般为当前容量/活跃用户数，当队列活跃用户越多，用户配额上限会越低  

## 改进方案

1. 建立业务优先级体系，为每个队列赋予业务优先级属性，优先级高的队列可以抢占低的队列，反之则不可。用以保证核心业务不被非核心业务抢占资源    
2. 在计算每个队列应得的资源时，若队列预计得到的资源不足以满足队列中最小的 ResourceRequest，则抢占是无意义的，不为该队列做抢占，其预计得到的资源将被设置为 0，这些无法利用的资源将转给其他队列   
按照对”大容器”的定义(e.g. 40G)，优先为”大容器”队列做抢占，然后为“普通容器“队列做抢占  
3. 为”大容器”抢占时，在每个节点上选取待抢占队列的最新启动的 Application 的最新分配的部分容器释放且计算释放代价，最终选取释放代价最低的节点上的容器释放。若队列分配完”大容器” 或者待抢占量不高于”大容器” 定义，则后续将其作为”普通容器” 队列来处理  
4. 为”普通容器”抢占时，选取待抢占队列中最新启动的 App 的最新 Container 开始释放    

## 抢占流程

![](/img/pictures/yarn_preempt/preemption_scheduler.png)
	 
1. 获取各队列使用状态  
　　包括: 队列的业务优先级，最低配额(capacity)，最高配额，当前使用量(used)，当前堆积需求量(pending)，最低需求量，最高需求量，初始理想容量(min{used,capacity})  
2. 按优先级计算每个队列的理想容量  
　　首先将所有队列划分为空闲队列(used<=capacity)、超分配队列(used>capacity)两类，并统计出欠分配队列(used+pending>当前理想容量)。在保证弹性最低配额的条件下，将空闲队列的(capacity-used) 和超分配队列(used-capacity) 作为全局空闲量，按规则分配给欠分配队列:  
　　a. 优先全局分配空闲资源给优先级高的欠分配队列，按优先级由高至低依次分配       
　　b. 分配的资源量取决于 min{全局空闲量，需求量，(最高配额-当前理想容量)}，记为 increment   
　　　即保证在不超过队列最高配额的情况下，从全局空闲量中优先满足高优先级队列的需求    
　　c. 然后分配全局空闲资源给无优先级但配置有最低配额的欠分配队列，按照欠分配程度(当前理想配额/最低配额 值)由低到高依次分配    
　　d. 分配的资源量取决于 min{全局空闲量 * 队列最低配额权重，需求量，(最高配额-当前理想容量)}，记为 increment     
　　e. 最后分配全局空闲资源给无优先级无最配配额的欠分配队列，按照欠分配程度由低到高依次分配  
　　f. 分配的资源量取决于 min{全局空闲量 * 队列平均权重，需求量，(最高配额-当前理想容量)}，记为 increment   
　　g. 在全局空闲量为 0 或者没有欠分配队列时终止此环节    
即: 抢占是一个再平衡的过程，资源从低优先级队列流向高优先级欠分配队列，从未配置最低配额的队列流向配置最低配额的队列，但是会保证有任务但被抢占资源队列的弹性最低配额(min{used+pending, capacity})  
3. 判断各队列是否是有效抢占  
　　判断各队列的 increment 值，若 increment < minResourceRequest，即新得到的资源不足以启动任何一个容器，在将其从欠分配队列中删除  
4. 设置其 pending 为 0  
　　依据 used + pending = 当前容量， pending 设为 0 之后，不再是欠分配队列。  
5. 再计算  
　　重新计算抢占依据 (e.g. 高优先级队列抢占的资源无法启动队列中最小的一个容器时，将此资源按优先级再分给其他队列)     

	此处的表述有歧义，但是画图过于冗余，故而放到了一个循环中，其实是三个循环。第一个循环: 优先分配有优先级配置的队列，并判断其是否是有效抢占，若是无效抢占，则把其 increment 还回到全局空闲配额中，供次级流程(后续的低优先级队列，无优先级队列)使用。第二个循环是: 分配无优先级但有最低配额的队列，判断其是否是有效抢占，若是无效抢占，则把 increment 还回到全局空闲配额中，供后续流程使用(后续无优先级有最低配额的欠分配队列，无优先级无最低配额的欠分配队列)。第三个循环是: 无优先级无最低配额的欠分配队列。第一个循环在队列分配完成后立即判断是否是有效抢占，第二三个循环需要在所属循环分配完成后按累计 increment 由高至低分别判断，若有无效抢占立即重算除其之外的所有的队列的理想配额。      
6. 计算出所有队列的待抢占量，并依据最小需求将所有欠分配队列划分为”大容器”和”普通容器”，分别进行抢占调度  
7. 对于每个”大容器”队列，循环(8->11)抢占，每次抢占量为 maxResourceRequest(足以启动队列中任何一个容器)。直到没有 NM 满足，或者待抢占量低于”大容器”定义    

	```
伪代码
Map<NodeId，QueueContainerDetail> info;
For(App: toPreemptedQueue)
	addContainer{runningContainer，reservedContainer} -> info(amContainers,nonAMContainers);
Map<TempQueue,Resource> limit = listQueuePreemptionLimit(); 
For( curQueue: allUnderReservedQueue) 
	maxRR=curQueue.getMaxResourceRequest 
	totalPreeption=curQueue.getTotalPreemption
	while(totalPreeption>maxRR )
		minCostTime=Long.MaxValue	
		Map<Queue，Container> containers，NodeId //在该节点上杀死这些容器为最小代价
		for(nodeId: NodeId)
			costTime = tryPreemptFromNode(node,limit,maxRR)
			if(costTime<minCostTime)
				minCostTime=costTime; containers,nodeId REFRESH->POINTER
		if(costTime ==Long.MaxValue)
			LOG.warn("no node meet the request in this queue, do left totalPreemption as common preemption")
	        else
			totalPreemption -= maxRR
```

8. 统计每个待抢占队列的(App，Container)->(nm) 信息  

	```
public void addContainer(TempQueue queue, RMContainer container){
      ensureQueue(queue);
      if(container.isAMContainer()){
        amContainers.get(queue).add(container);
      }else {
        nonAMContainers.get(queue).add(container);
      }
    }
	```

9. 尝试在每个 NM 上抢占，并计算抢占代价  
　　尝试使用nonAMContainers 来满足 maxResourceRequest；并维护相关信息，计算抢占代价 costTime=∑（curTime-contianer.getStartTime）  
限制条件是:  
　　a. 每个队列不超出自身待释放的资源  
　　b. 在该节点上所有超分配队列释放的资源和节点空闲资源 可以满足 maxRR  
QueueAppInfo 的核心数据结构和逻辑:   
[QueueContainerDetail.java]  

	```
NodeId nodeId;Clock clock;Long curTime;Long costTime;
Map<TempQueue, List<RMContainer>> nonAMContainers;
Map<TempQueue, List<RMContainer>> amContainers;
// 各队列 最终被抢占的 container 列表
Map<TempQueue, List<RMContainer>> toBePreemptedContainers;
// 各队列 最终被抢占的资源量
Map<TempQueue, Resource> toBePreemptedResource;
/**
     * note: since to "try preempt",
     * the maxResourceRequest and preemptedLimitOfQueue are copied.
     * @param maxResourceRequest  待抢占量 e.g. 40G
     * @param preemptedLimit queueLimit A->30G, B->20G 抢占总量限制
     */
public long tryPreemptFromNode(Resource maxResourceRequest,
                                   Map<TempQueue, Resource> preemptedLimit){
      clearCache();
      curTime=clock.getTime();
      Resource toPreempt=Resources.clone(maxResourceRequest);
      Iterator<Map.Entry<TempQueue, List<RMContainer>>> it =
          nonAMContainers.entrySet().iterator();
      while(Resources.greaterThan(rc, clusterResource,
          toPreempt, Resources.none())&& it.hasNext()){
        Map.Entry<TempQueue, List<RMContainer>> entry = it.next();
        TempQueue currentQueue = entry.getKey();
        Resource limit = Resources.clone(preemptedLimit.get(currentQueue));
        if(Resources.greaterThan(rc, clusterResource,
            limit, Resources.none()) == false || currentQueue.preemptionDisabled){
          continue;
        }
        List<RMContainer> containerList = entry.getValue();
        long sortStart = clock.getTime();
        Collections.sort(containerList, COMPARATOR_CONTAINER);
        long sortEnd = clock.getTime();
        if(sortEnd - sortStart >= 100){
          LOG.warn(" Slow Sort nonAM Containers when trying preempt maxResourceRequest {} " +
                  "at queue {} with queueLimit {} total {} container, token {}ms",
              toPreempt,
              currentQueue.getQueueName(),
              limit,
              containerList.size(),
              sortEnd-sortStart);
        }
        Iterator<RMContainer> iit=containerList.iterator();
        while(Resources.greaterThan(rc, clusterResource, limit, Resources.none()) &&
            Resources.greaterThan(rc, clusterResource, toPreempt, Resources.none()) &&
            iit.hasNext()){
          RMContainer i=iit.next();
          if(isLabelContainer(i)){
            continue;
          }
          toBePreemptedContainers.get(currentQueue).add(i);
          Resources.addTo(toBePreemptedResource.get(currentQueue),
              i.getContainer().getResource());
          Resources.subtractFrom(limit, i.getContainer().getResource());
          Resources.subtractFrom(toPreempt, i.getContainer().getResource());
          costTime += (curTime - i.getCreationTime());
        }
      }
      // 暂不抢占 AM,代价不可控 难维护
      if(Resources.greaterThan(rc, clusterResource,
          toPreempt, Resources.none())){
        costTime = Long.MAX_VALUE;
      }
      return costTime;
    }
    public void preemptFromNode(){
      for(Map.Entry<TempQueue, List<RMContainer>> entry :
          toBePreemptedContainers.entrySet()){
        nonAMContainers.get(entry.getKey()).removeAll(entry.getValue());
        amContainers.get(entry.getKey()).removeAll(entry.getValue());
      }
    }
	```
10. 选取抢占代价最低的节点，记录相应 container 集合    
　　获取在所有 NM 中，costTime 最低的 Container 集合作为待抢占容器      
11. 若当前队列的待抢占量小于”大容器”定义，则剩余资源作为”普通容器抢占”   
12. 在抢占代价最低的节点上，释放了总资源量不低于 maxResourceRequest 的 Container 集合  
13. 为所有”普通容器”做抢占:在待抢占的队列中杀死最新启动的容器(不存在于 步骤10 中) 

	```
Resource toPreempted;
For(Queue : overReservedQueue)
		For(App: Queue.getApps)
			if(toPreempted <= none) break;
			killReservedContainer(App， toPreempted); 
			killAllocatedContainerByOrder(App， toPreempted);
			rememberAM();
if(toPreempted > none)
		killAMByOrder();
	```		

## 优点缺点

### 优点

1. 在集群负载高的时候，可以保证优先级高的业务有资源执行;低优先级队列不能抢占高优先级队列的任务.(开源实现 不能保证)  
2. 可以在节点上启动大容器 (开源实现 不能保证)  
3. 可以避免无效抢占 (开源实现 不能保证)  

### 缺点
1. 集群负载高时，低优先级长时任务可能被无限拉长  
2. 在节点上选取最新启动的容器抢占，而不是在全局选择最新启动的容器抢占，导致任务恢复无效工作量增加  
3. 大容器调度时，增加了节点的资源利用率波动  

## 抢占调度(开源抢占详解)
抢占调度是周期性的，每周期抢占调度执行的策略分三步:  

1.	获取所有队列的快照  
2.	计算所有队列的理想容量，作为抢占依据  
3.	从超分配队列中，计算最终抢占量，并选取部分容器释放容量  
其中最重要的是第2步，这一步决定着:队列是否释放资源及释放多少资源  

### 获取所有队列的快照

获取信息:  
　　队列用量 used; 队列堆积需求 pending; 队列最低配额 capacity ;队列最高配额额 maxCapacity; 队列是否允许抢占 preemptionDisabled; 子队列 children   
初始化信息:  
　　理想容量 idealAssigned; 超出配额容量 toBePreempted; 最终被抢占容量 actuallyPreempted; 权重normalizedGrarantee

### 计算所有队列的理想容量，作为抢占依据
　　设置 root 队列的理想容量为 100%，递归向下按层计算 每个子队列的理想容量，子队列的子队列理想容量，直至叶子队列。每轮递归通用逻辑是:依据当前队列的理想容量和所有子队列快照信息，计算每个子队列的理想容量。  
a.  划分子队列类型  
　　对于递归过程中，当前队列的所有子队列按照”是否配置了最低配额”划分为两类:第一类，配置最低配额的子队列集合;第二类，未配置最低配额的子队列集合。区别在于:第一类要优先于第二类得到资源，满足了第一类子队列需求之后如果还有空闲资源才会分配给第二类子队列；第一类子队列在分享当前队列的配额时，之间是以最低配额为权重的，第二类由于没有配置最低配额，之间是平均分配的  
b. 优先分配 配置了最低配额的子队列  
　　b1. 设定初始理想配额  
　　　　这一过程的主要逻辑是: 为所有子队列设定动态初始理想配额，并计算出当前队列的空闲配额，记录欠分配子队列。  
　　　　初始配额设定:   
　　　　　　若 used<=capacity，则idealAssigned=used。将(capacity-used) 作为空闲资源     
　　　　　　若 used>capacity，则ideaAssigned=capacity。将(used-capacity) 作为空闲资源拿出来再分配     
　　　　计算当前队列的空闲配额:  
　　　　　　将 上述两种空闲资源之和作为队列全局空闲资源，交由欠分配子队列 再分配  
　　　　记录欠分配子队列:  
　　　　　　若子队列 used+pending > idealAssigned，即需求量大于容量 为欠分配子队列。  
　　b2. 再分配过程  
　　　　目的: 按照 b1 记录的信息，将全局空闲资源，按照分配给所有的欠分配子队列。    
　　　　方式: 以循环的方式，每轮循环为最欠分配的队列(most under served queue)分配资源。最欠分配的队列在得到资源后，欠分配程度排名可能会变化。因此这种分配方式会使各子队列资源量比值最终趋近于”最低配额”比值。”资源再平衡”的说法来源于此。  
　　　　权重: 每个子队列在欠分配子队列集合中获取资源的权重是 capacity/∑capacity，存储在队列快照中的 normalizedGrarantee字段  
　　　　变量: 全局空闲资源，欠分配子队列，子队列减少导致的分配权重增大  
　　　　增量: 循环为最欠分配的队列分配资源，每次分配的增量为min{全局空闲资源 * 权重，需求量，最高配额-当前理想配额}  
　　　　　　全局空闲资源 * 权重: 表示在该轮循环 能得到的资源  
　　　　　　需求量:used+pending-idealAssigned，表示这些资源可以满足队列的需求  
　　　　　　最高配额-当前理想配额: 表示在任何情况下，队列配额都不能超过最高配额  
　　　　增量最终会增加到理想配额idealAssigned。在全局空闲资源为 0 或者无任何欠分配队列时，idealAssigned 会作为队列最终的理想配额  

核心源码如下:

```
/**
 * orderedByNeed : 所有欠分配队列
 * unassigned: 全局空闲资源
 * /
while (!orderedByNeed.isEmpty()
   && Resources.greaterThan(rc，tot_guarant， unassigned，Resources.none())) {
  Resource wQassigned = Resource.newInstance(0， 0);
  / *
   * 设置orderedByNeed中所有队列的权重
   *  配置最低配额: capacity/sum(capacity)
   * 未配置最低配额: 1/orderedByNeed.size()
   * /
  resetCapacity(rc， unassigned， orderedByNeed， ignoreGuarantee);
  / **
   * 最欠分配的队列( most under served queue )
   * 比较 idealAssigned/capacity 值
   */
  Collection<TempQueue> underserved =
      getMostUnderservedQueues(orderedByNeed， tqComparator);
  for (Iterator<TempQueue> i = underserved.iterator(); i.hasNext();) {
    TempQueue sub = i.next();
    //全局空闲资源*权重
    Resource wQavail = Resources.multiplyAndNormalizeUp(rc，
        unassigned， sub.normalizedGuarantee， Resource.newInstance(1， 1));
    //三元组{全局空闲资源*权重，used+pending-idealAssigned，maxCapacity-idealAssigned}
    Resource wQidle = sub.offer(wQavail， rc， tot_guarant);
    //增量
    Resource wQdone = Resources.subtract(wQavail， wQidle);
    if (Resources.greaterThan(rc， tot_guarant，
          wQdone， Resources.none())) {
      //如果这个队列在这轮得到了资源，那么下一轮也可能得到资源，所以加入到原集合中;直到没有得到资源
      orderedByNeed.add(sub);
    }
    Resources.addTo(wQassigned， wQdone);
  }
  //修改全局空闲资源
  Resources.subtractFrom(unassigned， wQassigned);
}
```
c. 最后分配 未配置最低配额的子队列  
　　如果在满足了”配置最低配额的子队列“的所有需求之后，还有剩余配额，则平均分配到所有”未配置最低配额的子队列”中。    
　　除权重外，和 b 完全一致。  
　　　　权重:子队列集合中每个子队列都会平均分配全局空闲资源(区别于 按最低配额做权重)  
d. 规整队列待抢占量
　　汇总所有叶子队列的超出配额(used-idealAssigned)之和，如果此值超出“每轮总抢占“(默认集群总资源的 10%)，则按比例减少每个叶子队列的待抢占量 以保证每轮抢占的总资源量不超过”每轮总抢占”。

### 从超分配队列中，计算最终待抢占量，并选取部分容器释放容量

1. 判断超分配队列  
　　若 used>capacity*(1+maxIgnoredOverCapacity)，则判断为超分配队列，该队列需要释放资源。  
　　其中 maxIgnoredOverCapacity 表示 忽略抢占阈值，默认 0.2。 参考“Tips-5”  
2. 计算最终抢占量  
　　最终抢占量 actuallyPreempted=toBePreempted * naturalTerminationFactor。  
　　其中naturalTerminationFactor表示 自然终止因子，默认 0.2。toBePreempt=used-idealAssigned。参考”Tips-5”  
3. 选取容器  
　　选取总大小不小于actuallyPreempted的一些容器，释放掉  
　　选取规则如下:   
　　　　优先选择队列中后启动的 APP  
　　　　优先选择 APP 的保留容器  
　　　　优先选择 APP 后启动的容器  
　　如果以上普通容器全部选取完之后无法还回等量actuallyPreempted的资源，则开始选取AM 角色的容器，优先选取后启动的 AM容器  

### 释放
　　对于选取的、将要被抢占的所有容器，将<容器，时间>加入到一个全局的集合中追踪，考虑到自然终止的情况，如果集合中的容器存活时间超过 5 * 15s，则直接杀死。  





